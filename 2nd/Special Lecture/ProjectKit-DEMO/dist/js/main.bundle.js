/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\n/*! main.js © yamoo9.net, 2016 */\n\n// ------------------------------------\n// 빌드 시에 아래 주석을 해제한 후, 빌드\n// Recording 09: 디테일 패널 폼 변경 설정 및 angular-auto-validate, angular-ladda 모듈 설치/설정\n// https://youtu.be/Y26VgUbKWSA\n// ------------------------------------\n// require('jquery');\n\n// Angular 로드\nvar angular = __webpack_require__(1);\n\n// 의존 모듈 로드\n__webpack_require__(2);\n__webpack_require__(4);\n__webpack_require__(5);\n__webpack_require__(6);\n__webpack_require__(7);\n__webpack_require__(8);\n__webpack_require__(10);\n\n// App 모듈 정의 (의존 모듈 주입)\nvar bipan = angular.module('BipanListApp', ['ngResource', 'infinite-scroll', 'angularSpinner', 'jcs-autoValidate', 'angular-ladda']);\n\n// 모듈 환경 설정\nbipan.config(['$httpProvider', '$resourceProvider', 'usSpinnerConfigProvider', 'laddaProvider', function ($httpProvider, $resourceProvider, usSpinnerConfigProvider, laddaProvider) {\n\n  // ngResource\n  var token = 'Token dab1748ebaceb34ed6796bc3b7dc84741b77af54';\n  $httpProvider.defaults.headers.common['Authorization'] = token;\n  $resourceProvider.defaults.stripTrailingSlashes = false;\n\n  // usSpinnerConfigProvider\n  usSpinnerConfigProvider.setTheme('white-spinner', {\n    'color': '#ffffff',\n    'radius': 25,\n    'width': 6,\n    'length': 21,\n    'lines': 17,\n    'scale': 0.45\n  });\n\n  // laddaProvider\n  laddaProvider.setOption({\n    'style': 'expand-right'\n  });\n}]);\n\n// Controllers\n__webpack_require__(11);\n__webpack_require__(12);\n// Services\n__webpack_require__(13);\n// Filters\n__webpack_require__(14);\n__webpack_require__(15);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvbWFpbi5lczY/ZTgxYiJdLCJuYW1lcyI6WyJhbmd1bGFyIiwicmVxdWlyZSIsImJpcGFuIiwibW9kdWxlIiwiY29uZmlnIiwiJGh0dHBQcm92aWRlciIsIiRyZXNvdXJjZVByb3ZpZGVyIiwidXNTcGlubmVyQ29uZmlnUHJvdmlkZXIiLCJsYWRkYVByb3ZpZGVyIiwidG9rZW4iLCJkZWZhdWx0cyIsImhlYWRlcnMiLCJjb21tb24iLCJzdHJpcFRyYWlsaW5nU2xhc2hlcyIsInNldFRoZW1lIiwic2V0T3B0aW9uIl0sIm1hcHBpbmdzIjoiOztBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUlBLFVBQVUsbUJBQUFDLENBQVEsQ0FBUixDQUFkOztBQUVBO0FBQ0EsbUJBQUFBLENBQVEsQ0FBUjtBQUNBLG1CQUFBQSxDQUFRLENBQVI7QUFDQSxtQkFBQUEsQ0FBUSxDQUFSO0FBQ0EsbUJBQUFBLENBQVEsQ0FBUjtBQUNBLG1CQUFBQSxDQUFRLENBQVI7QUFDQSxtQkFBQUEsQ0FBUSxDQUFSO0FBQ0EsbUJBQUFBLENBQVEsRUFBUjs7QUFFQTtBQUNBLElBQUlDLFFBQVFGLFFBQVFHLE1BQVIsQ0FBZSxjQUFmLEVBQStCLENBQ3pDLFlBRHlDLEVBRXpDLGlCQUZ5QyxFQUd6QyxnQkFIeUMsRUFJekMsa0JBSnlDLEVBS3pDLGVBTHlDLENBQS9CLENBQVo7O0FBUUE7QUFDQUQsTUFBTUUsTUFBTixDQUFhLENBQ1gsZUFEVyxFQUVYLG1CQUZXLEVBR1gseUJBSFcsRUFJWCxlQUpXLEVBS1gsVUFBQ0MsYUFBRCxFQUFnQkMsaUJBQWhCLEVBQW1DQyx1QkFBbkMsRUFBNERDLGFBQTVELEVBQTZFOztBQUUzRTtBQUNBLE1BQUlDLFFBQVEsZ0RBQVo7QUFDQUosZ0JBQWNLLFFBQWQsQ0FBdUJDLE9BQXZCLENBQStCQyxNQUEvQixDQUFzQyxlQUF0QyxJQUF5REgsS0FBekQ7QUFDQUgsb0JBQWtCSSxRQUFsQixDQUEyQkcsb0JBQTNCLEdBQWtELEtBQWxEOztBQUVBO0FBQ0FOLDBCQUF3Qk8sUUFBeEIsQ0FBaUMsZUFBakMsRUFBa0Q7QUFDaEQsYUFBVyxTQURxQztBQUVoRCxjQUFXLEVBRnFDO0FBR2hELGFBQVcsQ0FIcUM7QUFJaEQsY0FBVyxFQUpxQztBQUtoRCxhQUFXLEVBTHFDO0FBTWhELGFBQVc7QUFOcUMsR0FBbEQ7O0FBU0E7QUFDQU4sZ0JBQWNPLFNBQWQsQ0FBd0I7QUFDdEIsYUFBUztBQURhLEdBQXhCO0FBSUgsQ0EzQlksQ0FBYjs7QUE2QkE7QUFDQSxtQkFBQWQsQ0FBUSxFQUFSO0FBQ0EsbUJBQUFBLENBQVEsRUFBUjtBQUNBO0FBQ0EsbUJBQUFBLENBQVEsRUFBUjtBQUNBO0FBQ0EsbUJBQUFBLENBQVEsRUFBUjtBQUNBLG1CQUFBQSxDQUFRLEVBQVIiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qISBtYWluLmpzIMKpIHlhbW9vOS5uZXQsIDIwMTYgKi9cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyDruYzrk5wg7Iuc7JeQIOyVhOuemCDso7zshJ3snYQg7ZW07KCc7ZWcIO2bhCwg67mM65OcXG4vLyBSZWNvcmRpbmcgMDk6IOuUlO2FjOydvCDtjKjrhJAg7Y+8IOuzgOqyvSDshKTsoJUg67CPIGFuZ3VsYXItYXV0by12YWxpZGF0ZSwgYW5ndWxhci1sYWRkYSDrqqjrk4gg7ISk7LmYL+yEpOyglVxuLy8gaHR0cHM6Ly95b3V0dS5iZS9ZMjZWZ1ViS1dTQVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyByZXF1aXJlKCdqcXVlcnknKTtcblxuLy8gQW5ndWxhciDroZzrk5xcbmxldCBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xuXG4vLyDsnZjsobQg66qo65OIIOuhnOuTnFxucmVxdWlyZSgnYW5ndWxhci1yZXNvdXJjZScpO1xucmVxdWlyZSgnbmctaW5maW5pdGUtc2Nyb2xsJyk7XG5yZXF1aXJlKCdzcGluJyk7XG5yZXF1aXJlKCdhbmd1bGFyLXNwaW5uZXInKTtcbnJlcXVpcmUoJ2FuZ3VsYXItYXV0by12YWxpZGF0ZScpO1xucmVxdWlyZSgnbGFkZGEnKTtcbnJlcXVpcmUoJ2FuZ3VsYXItbGFkZGEnKTtcblxuLy8gQXBwIOuqqOuTiCDsoJXsnZggKOydmOyhtCDrqqjrk4gg7KO87J6FKVxubGV0IGJpcGFuID0gYW5ndWxhci5tb2R1bGUoJ0JpcGFuTGlzdEFwcCcsIFtcbiAgJ25nUmVzb3VyY2UnLFxuICAnaW5maW5pdGUtc2Nyb2xsJyxcbiAgJ2FuZ3VsYXJTcGlubmVyJyxcbiAgJ2pjcy1hdXRvVmFsaWRhdGUnLFxuICAnYW5ndWxhci1sYWRkYScsXG5dKTtcblxuLy8g66qo65OIIO2ZmOqyvSDshKTsoJVcbmJpcGFuLmNvbmZpZyhbXG4gICckaHR0cFByb3ZpZGVyJyxcbiAgJyRyZXNvdXJjZVByb3ZpZGVyJyxcbiAgJ3VzU3Bpbm5lckNvbmZpZ1Byb3ZpZGVyJyxcbiAgJ2xhZGRhUHJvdmlkZXInLFxuICAoJGh0dHBQcm92aWRlciwgJHJlc291cmNlUHJvdmlkZXIsIHVzU3Bpbm5lckNvbmZpZ1Byb3ZpZGVyLCBsYWRkYVByb3ZpZGVyKT0+IHtcblxuICAgIC8vIG5nUmVzb3VyY2VcbiAgICBsZXQgdG9rZW4gPSAnVG9rZW4gZGFiMTc0OGViYWNlYjM0ZWQ2Nzk2YmMzYjdkYzg0NzQxYjc3YWY1NCc7XG4gICAgJGh0dHBQcm92aWRlci5kZWZhdWx0cy5oZWFkZXJzLmNvbW1vblsnQXV0aG9yaXphdGlvbiddID0gdG9rZW47XG4gICAgJHJlc291cmNlUHJvdmlkZXIuZGVmYXVsdHMuc3RyaXBUcmFpbGluZ1NsYXNoZXMgPSBmYWxzZTtcblxuICAgIC8vIHVzU3Bpbm5lckNvbmZpZ1Byb3ZpZGVyXG4gICAgdXNTcGlubmVyQ29uZmlnUHJvdmlkZXIuc2V0VGhlbWUoJ3doaXRlLXNwaW5uZXInLCB7XG4gICAgICAnY29sb3InICA6ICcjZmZmZmZmJyxcbiAgICAgICdyYWRpdXMnIDogMjUsXG4gICAgICAnd2lkdGgnICA6IDYsXG4gICAgICAnbGVuZ3RoJyA6IDIxLFxuICAgICAgJ2xpbmVzJyAgOiAxNyxcbiAgICAgICdzY2FsZScgIDogMC40NSxcbiAgICB9KTtcblxuICAgIC8vIGxhZGRhUHJvdmlkZXJcbiAgICBsYWRkYVByb3ZpZGVyLnNldE9wdGlvbih7XG4gICAgICAnc3R5bGUnOiAnZXhwYW5kLXJpZ2h0J1xuICAgIH0pO1xuXG59XSk7XG5cbi8vIENvbnRyb2xsZXJzXG5yZXF1aXJlKCcuL2NvbnRyb2xsZXJzL0xpc3RDb250cm9sbGVyJyk7XG5yZXF1aXJlKCcuL2NvbnRyb2xsZXJzL0RldGFpbENvbnRyb2xsZXInKTtcbi8vIFNlcnZpY2VzXG5yZXF1aXJlKCcuL3NlcnZpY2VzL0xpc3REYXRhU2hhcmVTZXJ2aWNlJyk7XG4vLyBGaWx0ZXJzXG5yZXF1aXJlKCcuL2ZpbHRlcnMvcmVhZGluZ1plcm9GaWx0ZXInKTtcbnJlcXVpcmUoJy4vZmlsdGVycy9kZWZhdWx0SW1hZ2VGaWx0ZXInKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9tYWluLmVzNiJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 1 */
/***/ function(module, exports) {

	eval("module.exports = angular;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJhbmd1bGFyXCI/MTFkMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBhbmd1bGFyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiYW5ndWxhclwiXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(3);\nmodule.exports = 'ngResource';\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2FuZ3VsYXItcmVzb3VyY2UvaW5kZXguanM/NDE4NiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBIiwiZmlsZSI6IjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKCcuL2FuZ3VsYXItcmVzb3VyY2UnKTtcbm1vZHVsZS5leHBvcnRzID0gJ25nUmVzb3VyY2UnO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FuZ3VsYXItcmVzb3VyY2UvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 3 */
/***/ function(module, exports) {

	eval("/**\n * @license AngularJS v1.5.9\n * (c) 2010-2016 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular) {'use strict';\n\nvar $resourceMinErr = angular.$$minErr('$resource');\n\n// Helper functions and regex to lookup a dotted path on an object\n// stopping at undefined/null.  The path must be composed of ASCII\n// identifiers (just like $parse)\nvar MEMBER_NAME_REGEX = /^(\\.[a-zA-Z_$@][0-9a-zA-Z_$@]*)+$/;\n\nfunction isValidDottedPath(path) {\n  return (path != null && path !== '' && path !== 'hasOwnProperty' &&\n      MEMBER_NAME_REGEX.test('.' + path));\n}\n\nfunction lookupDottedPath(obj, path) {\n  if (!isValidDottedPath(path)) {\n    throw $resourceMinErr('badmember', 'Dotted member path \"@{0}\" is invalid.', path);\n  }\n  var keys = path.split('.');\n  for (var i = 0, ii = keys.length; i < ii && angular.isDefined(obj); i++) {\n    var key = keys[i];\n    obj = (obj !== null) ? obj[key] : undefined;\n  }\n  return obj;\n}\n\n/**\n * Create a shallow copy of an object and clear other fields from the destination\n */\nfunction shallowClearAndCopy(src, dst) {\n  dst = dst || {};\n\n  angular.forEach(dst, function(value, key) {\n    delete dst[key];\n  });\n\n  for (var key in src) {\n    if (src.hasOwnProperty(key) && !(key.charAt(0) === '$' && key.charAt(1) === '$')) {\n      dst[key] = src[key];\n    }\n  }\n\n  return dst;\n}\n\n/**\n * @ngdoc module\n * @name ngResource\n * @description\n *\n * # ngResource\n *\n * The `ngResource` module provides interaction support with RESTful services\n * via the $resource service.\n *\n *\n * <div doc-module-components=\"ngResource\"></div>\n *\n * See {@link ngResource.$resourceProvider} and {@link ngResource.$resource} for usage.\n */\n\n/**\n * @ngdoc provider\n * @name $resourceProvider\n *\n * @description\n *\n * Use `$resourceProvider` to change the default behavior of the {@link ngResource.$resource}\n * service.\n *\n * ## Dependencies\n * Requires the {@link ngResource } module to be installed.\n *\n */\n\n/**\n * @ngdoc service\n * @name $resource\n * @requires $http\n * @requires ng.$log\n * @requires $q\n * @requires ng.$timeout\n *\n * @description\n * A factory which creates a resource object that lets you interact with\n * [RESTful](http://en.wikipedia.org/wiki/Representational_State_Transfer) server-side data sources.\n *\n * The returned resource object has action methods which provide high-level behaviors without\n * the need to interact with the low level {@link ng.$http $http} service.\n *\n * Requires the {@link ngResource `ngResource`} module to be installed.\n *\n * By default, trailing slashes will be stripped from the calculated URLs,\n * which can pose problems with server backends that do not expect that\n * behavior.  This can be disabled by configuring the `$resourceProvider` like\n * this:\n *\n * ```js\n     app.config(['$resourceProvider', function($resourceProvider) {\n       // Don't strip trailing slashes from calculated URLs\n       $resourceProvider.defaults.stripTrailingSlashes = false;\n     }]);\n * ```\n *\n * @param {string} url A parameterized URL template with parameters prefixed by `:` as in\n *   `/user/:username`. If you are using a URL with a port number (e.g.\n *   `http://example.com:8080/api`), it will be respected.\n *\n *   If you are using a url with a suffix, just add the suffix, like this:\n *   `$resource('http://example.com/resource.json')` or `$resource('http://example.com/:id.json')`\n *   or even `$resource('http://example.com/resource/:resource_id.:format')`\n *   If the parameter before the suffix is empty, :resource_id in this case, then the `/.` will be\n *   collapsed down to a single `.`.  If you need this sequence to appear and not collapse then you\n *   can escape it with `/\\.`.\n *\n * @param {Object=} paramDefaults Default values for `url` parameters. These can be overridden in\n *   `actions` methods. If a parameter value is a function, it will be called every time\n *   a param value needs to be obtained for a request (unless the param was overridden). The function\n *   will be passed the current data value as an argument.\n *\n *   Each key value in the parameter object is first bound to url template if present and then any\n *   excess keys are appended to the url search query after the `?`.\n *\n *   Given a template `/path/:verb` and parameter `{verb:'greet', salutation:'Hello'}` results in\n *   URL `/path/greet?salutation=Hello`.\n *\n *   If the parameter value is prefixed with `@`, then the value for that parameter will be\n *   extracted from the corresponding property on the `data` object (provided when calling a\n *   \"non-GET\" action method).\n *   For example, if the `defaultParam` object is `{someParam: '@someProp'}` then the value of\n *   `someParam` will be `data.someProp`.\n *   Note that the parameter will be ignored, when calling a \"GET\" action method (i.e. an action\n *   method that does not accept a request body)\n *\n * @param {Object.<Object>=} actions Hash with declaration of custom actions that should extend\n *   the default set of resource actions. The declaration should be created in the format of {@link\n *   ng.$http#usage $http.config}:\n *\n *       {action1: {method:?, params:?, isArray:?, headers:?, ...},\n *        action2: {method:?, params:?, isArray:?, headers:?, ...},\n *        ...}\n *\n *   Where:\n *\n *   - **`action`** – {string} – The name of action. This name becomes the name of the method on\n *     your resource object.\n *   - **`method`** – {string} – Case insensitive HTTP method (e.g. `GET`, `POST`, `PUT`,\n *     `DELETE`, `JSONP`, etc).\n *   - **`params`** – {Object=} – Optional set of pre-bound parameters for this action. If any of\n *     the parameter value is a function, it will be called every time when a param value needs to\n *     be obtained for a request (unless the param was overridden). The function will be passed the\n *     current data value as an argument.\n *   - **`url`** – {string} – action specific `url` override. The url templating is supported just\n *     like for the resource-level urls.\n *   - **`isArray`** – {boolean=} – If true then the returned object for this action is an array,\n *     see `returns` section.\n *   - **`transformRequest`** –\n *     `{function(data, headersGetter)|Array.<function(data, headersGetter)>}` –\n *     transform function or an array of such functions. The transform function takes the http\n *     request body and headers and returns its transformed (typically serialized) version.\n *     By default, transformRequest will contain one function that checks if the request data is\n *     an object and serializes to using `angular.toJson`. To prevent this behavior, set\n *     `transformRequest` to an empty array: `transformRequest: []`\n *   - **`transformResponse`** –\n *     `{function(data, headersGetter)|Array.<function(data, headersGetter)>}` –\n *     transform function or an array of such functions. The transform function takes the http\n *     response body and headers and returns its transformed (typically deserialized) version.\n *     By default, transformResponse will contain one function that checks if the response looks\n *     like a JSON string and deserializes it using `angular.fromJson`. To prevent this behavior,\n *     set `transformResponse` to an empty array: `transformResponse: []`\n *   - **`cache`** – `{boolean|Cache}` – If true, a default $http cache will be used to cache the\n *     GET request, otherwise if a cache instance built with\n *     {@link ng.$cacheFactory $cacheFactory}, this cache will be used for\n *     caching.\n *   - **`timeout`** – `{number}` – timeout in milliseconds.<br />\n *     **Note:** In contrast to {@link ng.$http#usage $http.config}, {@link ng.$q promises} are\n *     **not** supported in $resource, because the same value would be used for multiple requests.\n *     If you are looking for a way to cancel requests, you should use the `cancellable` option.\n *   - **`cancellable`** – `{boolean}` – if set to true, the request made by a \"non-instance\" call\n *     will be cancelled (if not already completed) by calling `$cancelRequest()` on the call's\n *     return value. Calling `$cancelRequest()` for a non-cancellable or an already\n *     completed/cancelled request will have no effect.<br />\n *   - **`withCredentials`** - `{boolean}` - whether to set the `withCredentials` flag on the\n *     XHR object. See\n *     [requests with credentials](https://developer.mozilla.org/en/http_access_control#section_5)\n *     for more information.\n *   - **`responseType`** - `{string}` - see\n *     [requestType](https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest#responseType).\n *   - **`interceptor`** - `{Object=}` - The interceptor object has two optional methods -\n *     `response` and `responseError`. Both `response` and `responseError` interceptors get called\n *     with `http response` object. See {@link ng.$http $http interceptors}.\n *\n * @param {Object} options Hash with custom settings that should extend the\n *   default `$resourceProvider` behavior.  The supported options are:\n *\n *   - **`stripTrailingSlashes`** – {boolean} – If true then the trailing\n *   slashes from any calculated URL will be stripped. (Defaults to true.)\n *   - **`cancellable`** – {boolean} – If true, the request made by a \"non-instance\" call will be\n *   cancelled (if not already completed) by calling `$cancelRequest()` on the call's return value.\n *   This can be overwritten per action. (Defaults to false.)\n *\n * @returns {Object} A resource \"class\" object with methods for the default set of resource actions\n *   optionally extended with custom `actions`. The default set contains these actions:\n *   ```js\n *   { 'get':    {method:'GET'},\n *     'save':   {method:'POST'},\n *     'query':  {method:'GET', isArray:true},\n *     'remove': {method:'DELETE'},\n *     'delete': {method:'DELETE'} };\n *   ```\n *\n *   Calling these methods invoke an {@link ng.$http} with the specified http method,\n *   destination and parameters. When the data is returned from the server then the object is an\n *   instance of the resource class. The actions `save`, `remove` and `delete` are available on it\n *   as  methods with the `$` prefix. This allows you to easily perform CRUD operations (create,\n *   read, update, delete) on server-side data like this:\n *   ```js\n *   var User = $resource('/user/:userId', {userId:'@id'});\n *   var user = User.get({userId:123}, function() {\n *     user.abc = true;\n *     user.$save();\n *   });\n *   ```\n *\n *   It is important to realize that invoking a $resource object method immediately returns an\n *   empty reference (object or array depending on `isArray`). Once the data is returned from the\n *   server the existing reference is populated with the actual data. This is a useful trick since\n *   usually the resource is assigned to a model which is then rendered by the view. Having an empty\n *   object results in no rendering, once the data arrives from the server then the object is\n *   populated with the data and the view automatically re-renders itself showing the new data. This\n *   means that in most cases one never has to write a callback function for the action methods.\n *\n *   The action methods on the class object or instance object can be invoked with the following\n *   parameters:\n *\n *   - HTTP GET \"class\" actions: `Resource.action([parameters], [success], [error])`\n *   - non-GET \"class\" actions: `Resource.action([parameters], postData, [success], [error])`\n *   - non-GET instance actions:  `instance.$action([parameters], [success], [error])`\n *\n *\n *   Success callback is called with (value, responseHeaders) arguments, where the value is\n *   the populated resource instance or collection object. The error callback is called\n *   with (httpResponse) argument.\n *\n *   Class actions return empty instance (with additional properties below).\n *   Instance actions return promise of the action.\n *\n *   The Resource instances and collections have these additional properties:\n *\n *   - `$promise`: the {@link ng.$q promise} of the original server interaction that created this\n *     instance or collection.\n *\n *     On success, the promise is resolved with the same resource instance or collection object,\n *     updated with data from server. This makes it easy to use in\n *     {@link ngRoute.$routeProvider resolve section of $routeProvider.when()} to defer view\n *     rendering until the resource(s) are loaded.\n *\n *     On failure, the promise is rejected with the {@link ng.$http http response} object, without\n *     the `resource` property.\n *\n *     If an interceptor object was provided, the promise will instead be resolved with the value\n *     returned by the interceptor.\n *\n *   - `$resolved`: `true` after first server interaction is completed (either with success or\n *      rejection), `false` before that. Knowing if the Resource has been resolved is useful in\n *      data-binding.\n *\n *   The Resource instances and collections have these additional methods:\n *\n *   - `$cancelRequest`: If there is a cancellable, pending request related to the instance or\n *      collection, calling this method will abort the request.\n *\n *   The Resource instances have these additional methods:\n *\n *   - `toJSON`: It returns a simple object without any of the extra properties added as part of\n *     the Resource API. This object can be serialized through {@link angular.toJson} safely\n *     without attaching Angular-specific fields. Notice that `JSON.stringify` (and\n *     `angular.toJson`) automatically use this method when serializing a Resource instance\n *     (see [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#toJSON()_behavior)).\n *\n * @example\n *\n * # Credit card resource\n *\n * ```js\n     // Define CreditCard class\n     var CreditCard = $resource('/user/:userId/card/:cardId',\n      {userId:123, cardId:'@id'}, {\n       charge: {method:'POST', params:{charge:true}}\n      });\n\n     // We can retrieve a collection from the server\n     var cards = CreditCard.query(function() {\n       // GET: /user/123/card\n       // server returns: [ {id:456, number:'1234', name:'Smith'} ];\n\n       var card = cards[0];\n       // each item is an instance of CreditCard\n       expect(card instanceof CreditCard).toEqual(true);\n       card.name = \"J. Smith\";\n       // non GET methods are mapped onto the instances\n       card.$save();\n       // POST: /user/123/card/456 {id:456, number:'1234', name:'J. Smith'}\n       // server returns: {id:456, number:'1234', name: 'J. Smith'};\n\n       // our custom method is mapped as well.\n       card.$charge({amount:9.99});\n       // POST: /user/123/card/456?amount=9.99&charge=true {id:456, number:'1234', name:'J. Smith'}\n     });\n\n     // we can create an instance as well\n     var newCard = new CreditCard({number:'0123'});\n     newCard.name = \"Mike Smith\";\n     newCard.$save();\n     // POST: /user/123/card {number:'0123', name:'Mike Smith'}\n     // server returns: {id:789, number:'0123', name: 'Mike Smith'};\n     expect(newCard.id).toEqual(789);\n * ```\n *\n * The object returned from this function execution is a resource \"class\" which has \"static\" method\n * for each action in the definition.\n *\n * Calling these methods invoke `$http` on the `url` template with the given `method`, `params` and\n * `headers`.\n *\n * @example\n *\n * # User resource\n *\n * When the data is returned from the server then the object is an instance of the resource type and\n * all of the non-GET methods are available with `$` prefix. This allows you to easily support CRUD\n * operations (create, read, update, delete) on server-side data.\n\n   ```js\n     var User = $resource('/user/:userId', {userId:'@id'});\n     User.get({userId:123}, function(user) {\n       user.abc = true;\n       user.$save();\n     });\n   ```\n *\n * It's worth noting that the success callback for `get`, `query` and other methods gets passed\n * in the response that came from the server as well as $http header getter function, so one\n * could rewrite the above example and get access to http headers as:\n *\n   ```js\n     var User = $resource('/user/:userId', {userId:'@id'});\n     User.get({userId:123}, function(user, getResponseHeaders){\n       user.abc = true;\n       user.$save(function(user, putResponseHeaders) {\n         //user => saved user object\n         //putResponseHeaders => $http header getter\n       });\n     });\n   ```\n *\n * You can also access the raw `$http` promise via the `$promise` property on the object returned\n *\n   ```\n     var User = $resource('/user/:userId', {userId:'@id'});\n     User.get({userId:123})\n         .$promise.then(function(user) {\n           $scope.user = user;\n         });\n   ```\n *\n * @example\n *\n * # Creating a custom 'PUT' request\n *\n * In this example we create a custom method on our resource to make a PUT request\n * ```js\n *    var app = angular.module('app', ['ngResource', 'ngRoute']);\n *\n *    // Some APIs expect a PUT request in the format URL/object/ID\n *    // Here we are creating an 'update' method\n *    app.factory('Notes', ['$resource', function($resource) {\n *    return $resource('/notes/:id', null,\n *        {\n *            'update': { method:'PUT' }\n *        });\n *    }]);\n *\n *    // In our controller we get the ID from the URL using ngRoute and $routeParams\n *    // We pass in $routeParams and our Notes factory along with $scope\n *    app.controller('NotesCtrl', ['$scope', '$routeParams', 'Notes',\n                                      function($scope, $routeParams, Notes) {\n *    // First get a note object from the factory\n *    var note = Notes.get({ id:$routeParams.id });\n *    $id = note.id;\n *\n *    // Now call update passing in the ID first then the object you are updating\n *    Notes.update({ id:$id }, note);\n *\n *    // This will PUT /notes/ID with the note object in the request payload\n *    }]);\n * ```\n *\n * @example\n *\n * # Cancelling requests\n *\n * If an action's configuration specifies that it is cancellable, you can cancel the request related\n * to an instance or collection (as long as it is a result of a \"non-instance\" call):\n *\n   ```js\n     // ...defining the `Hotel` resource...\n     var Hotel = $resource('/api/hotel/:id', {id: '@id'}, {\n       // Let's make the `query()` method cancellable\n       query: {method: 'get', isArray: true, cancellable: true}\n     });\n\n     // ...somewhere in the PlanVacationController...\n     ...\n     this.onDestinationChanged = function onDestinationChanged(destination) {\n       // We don't care about any pending request for hotels\n       // in a different destination any more\n       this.availableHotels.$cancelRequest();\n\n       // Let's query for hotels in '<destination>'\n       // (calls: /api/hotel?location=<destination>)\n       this.availableHotels = Hotel.query({location: destination});\n     };\n   ```\n *\n */\nangular.module('ngResource', ['ng']).\n  provider('$resource', function ResourceProvider() {\n    var PROTOCOL_AND_DOMAIN_REGEX = /^https?:\\/\\/[^\\/]*/;\n\n    var provider = this;\n\n    /**\n     * @ngdoc property\n     * @name $resourceProvider#defaults\n     * @description\n     * Object containing default options used when creating `$resource` instances.\n     *\n     * The default values satisfy a wide range of usecases, but you may choose to overwrite any of\n     * them to further customize your instances. The available properties are:\n     *\n     * - **stripTrailingSlashes** – `{boolean}` – If true, then the trailing slashes from any\n     *   calculated URL will be stripped.<br />\n     *   (Defaults to true.)\n     * - **cancellable** – `{boolean}` – If true, the request made by a \"non-instance\" call will be\n     *   cancelled (if not already completed) by calling `$cancelRequest()` on the call's return\n     *   value. For more details, see {@link ngResource.$resource}. This can be overwritten per\n     *   resource class or action.<br />\n     *   (Defaults to false.)\n     * - **actions** - `{Object.<Object>}` - A hash with default actions declarations. Actions are\n     *   high-level methods corresponding to RESTful actions/methods on resources. An action may\n     *   specify what HTTP method to use, what URL to hit, if the return value will be a single\n     *   object or a collection (array) of objects etc. For more details, see\n     *   {@link ngResource.$resource}. The actions can also be enhanced or overwritten per resource\n     *   class.<br />\n     *   The default actions are:\n     *   ```js\n     *   {\n     *     get: {method: 'GET'},\n     *     save: {method: 'POST'},\n     *     query: {method: 'GET', isArray: true},\n     *     remove: {method: 'DELETE'},\n     *     delete: {method: 'DELETE'}\n     *   }\n     *   ```\n     *\n     * #### Example\n     *\n     * For example, you can specify a new `update` action that uses the `PUT` HTTP verb:\n     *\n     * ```js\n     *   angular.\n     *     module('myApp').\n     *     config(['resourceProvider', function ($resourceProvider) {\n     *       $resourceProvider.defaults.actions.update = {\n     *         method: 'PUT'\n     *       };\n     *     });\n     * ```\n     *\n     * Or you can even overwrite the whole `actions` list and specify your own:\n     *\n     * ```js\n     *   angular.\n     *     module('myApp').\n     *     config(['resourceProvider', function ($resourceProvider) {\n     *       $resourceProvider.defaults.actions = {\n     *         create: {method: 'POST'}\n     *         get:    {method: 'GET'},\n     *         getAll: {method: 'GET', isArray:true},\n     *         update: {method: 'PUT'},\n     *         delete: {method: 'DELETE'}\n     *       };\n     *     });\n     * ```\n     *\n     */\n    this.defaults = {\n      // Strip slashes by default\n      stripTrailingSlashes: true,\n\n      // Make non-instance requests cancellable (via `$cancelRequest()`)\n      cancellable: false,\n\n      // Default actions configuration\n      actions: {\n        'get': {method: 'GET'},\n        'save': {method: 'POST'},\n        'query': {method: 'GET', isArray: true},\n        'remove': {method: 'DELETE'},\n        'delete': {method: 'DELETE'}\n      }\n    };\n\n    this.$get = ['$http', '$log', '$q', '$timeout', function($http, $log, $q, $timeout) {\n\n      var noop = angular.noop,\n        forEach = angular.forEach,\n        extend = angular.extend,\n        copy = angular.copy,\n        isFunction = angular.isFunction;\n\n      /**\n       * We need our custom method because encodeURIComponent is too aggressive and doesn't follow\n       * http://www.ietf.org/rfc/rfc3986.txt with regards to the character set\n       * (pchar) allowed in path segments:\n       *    segment       = *pchar\n       *    pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n       *    pct-encoded   = \"%\" HEXDIG HEXDIG\n       *    unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n       *    sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n       *                     / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n       */\n      function encodeUriSegment(val) {\n        return encodeUriQuery(val, true).\n          replace(/%26/gi, '&').\n          replace(/%3D/gi, '=').\n          replace(/%2B/gi, '+');\n      }\n\n\n      /**\n       * This method is intended for encoding *key* or *value* parts of query component. We need a\n       * custom method because encodeURIComponent is too aggressive and encodes stuff that doesn't\n       * have to be encoded per http://tools.ietf.org/html/rfc3986:\n       *    query       = *( pchar / \"/\" / \"?\" )\n       *    pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n       *    unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n       *    pct-encoded   = \"%\" HEXDIG HEXDIG\n       *    sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n       *                     / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n       */\n      function encodeUriQuery(val, pctEncodeSpaces) {\n        return encodeURIComponent(val).\n          replace(/%40/gi, '@').\n          replace(/%3A/gi, ':').\n          replace(/%24/g, '$').\n          replace(/%2C/gi, ',').\n          replace(/%20/g, (pctEncodeSpaces ? '%20' : '+'));\n      }\n\n      function Route(template, defaults) {\n        this.template = template;\n        this.defaults = extend({}, provider.defaults, defaults);\n        this.urlParams = {};\n      }\n\n      Route.prototype = {\n        setUrlParams: function(config, params, actionUrl) {\n          var self = this,\n            url = actionUrl || self.template,\n            val,\n            encodedVal,\n            protocolAndDomain = '';\n\n          var urlParams = self.urlParams = {};\n          forEach(url.split(/\\W/), function(param) {\n            if (param === 'hasOwnProperty') {\n              throw $resourceMinErr('badname', 'hasOwnProperty is not a valid parameter name.');\n            }\n            if (!(new RegExp('^\\\\d+$').test(param)) && param &&\n              (new RegExp('(^|[^\\\\\\\\]):' + param + '(\\\\W|$)').test(url))) {\n              urlParams[param] = {\n                isQueryParamValue: (new RegExp('\\\\?.*=:' + param + '(?:\\\\W|$)')).test(url)\n              };\n            }\n          });\n          url = url.replace(/\\\\:/g, ':');\n          url = url.replace(PROTOCOL_AND_DOMAIN_REGEX, function(match) {\n            protocolAndDomain = match;\n            return '';\n          });\n\n          params = params || {};\n          forEach(self.urlParams, function(paramInfo, urlParam) {\n            val = params.hasOwnProperty(urlParam) ? params[urlParam] : self.defaults[urlParam];\n            if (angular.isDefined(val) && val !== null) {\n              if (paramInfo.isQueryParamValue) {\n                encodedVal = encodeUriQuery(val, true);\n              } else {\n                encodedVal = encodeUriSegment(val);\n              }\n              url = url.replace(new RegExp(':' + urlParam + '(\\\\W|$)', 'g'), function(match, p1) {\n                return encodedVal + p1;\n              });\n            } else {\n              url = url.replace(new RegExp('(/?):' + urlParam + '(\\\\W|$)', 'g'), function(match,\n                  leadingSlashes, tail) {\n                if (tail.charAt(0) === '/') {\n                  return tail;\n                } else {\n                  return leadingSlashes + tail;\n                }\n              });\n            }\n          });\n\n          // strip trailing slashes and set the url (unless this behavior is specifically disabled)\n          if (self.defaults.stripTrailingSlashes) {\n            url = url.replace(/\\/+$/, '') || '/';\n          }\n\n          // then replace collapse `/.` if found in the last URL path segment before the query\n          // E.g. `http://url.com/id./format?q=x` becomes `http://url.com/id.format?q=x`\n          url = url.replace(/\\/\\.(?=\\w+($|\\?))/, '.');\n          // replace escaped `/\\.` with `/.`\n          config.url = protocolAndDomain + url.replace(/\\/\\\\\\./, '/.');\n\n\n          // set params - delegate param encoding to $http\n          forEach(params, function(value, key) {\n            if (!self.urlParams[key]) {\n              config.params = config.params || {};\n              config.params[key] = value;\n            }\n          });\n        }\n      };\n\n\n      function resourceFactory(url, paramDefaults, actions, options) {\n        var route = new Route(url, options);\n\n        actions = extend({}, provider.defaults.actions, actions);\n\n        function extractParams(data, actionParams) {\n          var ids = {};\n          actionParams = extend({}, paramDefaults, actionParams);\n          forEach(actionParams, function(value, key) {\n            if (isFunction(value)) { value = value(data); }\n            ids[key] = value && value.charAt && value.charAt(0) === '@' ?\n              lookupDottedPath(data, value.substr(1)) : value;\n          });\n          return ids;\n        }\n\n        function defaultResponseInterceptor(response) {\n          return response.resource;\n        }\n\n        function Resource(value) {\n          shallowClearAndCopy(value || {}, this);\n        }\n\n        Resource.prototype.toJSON = function() {\n          var data = extend({}, this);\n          delete data.$promise;\n          delete data.$resolved;\n          return data;\n        };\n\n        forEach(actions, function(action, name) {\n          var hasBody = /^(POST|PUT|PATCH)$/i.test(action.method);\n          var numericTimeout = action.timeout;\n          var cancellable = angular.isDefined(action.cancellable) ? action.cancellable :\n              (options && angular.isDefined(options.cancellable)) ? options.cancellable :\n              provider.defaults.cancellable;\n\n          if (numericTimeout && !angular.isNumber(numericTimeout)) {\n            $log.debug('ngResource:\\n' +\n                       '  Only numeric values are allowed as `timeout`.\\n' +\n                       '  Promises are not supported in $resource, because the same value would ' +\n                       'be used for multiple requests. If you are looking for a way to cancel ' +\n                       'requests, you should use the `cancellable` option.');\n            delete action.timeout;\n            numericTimeout = null;\n          }\n\n          Resource[name] = function(a1, a2, a3, a4) {\n            var params = {}, data, success, error;\n\n            switch (arguments.length) {\n              case 4:\n                error = a4;\n                success = a3;\n                // falls through\n              case 3:\n              case 2:\n                if (isFunction(a2)) {\n                  if (isFunction(a1)) {\n                    success = a1;\n                    error = a2;\n                    break;\n                  }\n\n                  success = a2;\n                  error = a3;\n                  // falls through\n                } else {\n                  params = a1;\n                  data = a2;\n                  success = a3;\n                  break;\n                }\n                // falls through\n              case 1:\n                if (isFunction(a1)) success = a1;\n                else if (hasBody) data = a1;\n                else params = a1;\n                break;\n              case 0: break;\n              default:\n                throw $resourceMinErr('badargs',\n                  'Expected up to 4 arguments [params, data, success, error], got {0} arguments',\n                  arguments.length);\n            }\n\n            var isInstanceCall = this instanceof Resource;\n            var value = isInstanceCall ? data : (action.isArray ? [] : new Resource(data));\n            var httpConfig = {};\n            var responseInterceptor = action.interceptor && action.interceptor.response ||\n              defaultResponseInterceptor;\n            var responseErrorInterceptor = action.interceptor && action.interceptor.responseError ||\n              undefined;\n            var timeoutDeferred;\n            var numericTimeoutPromise;\n\n            forEach(action, function(value, key) {\n              switch (key) {\n                default:\n                  httpConfig[key] = copy(value);\n                  break;\n                case 'params':\n                case 'isArray':\n                case 'interceptor':\n                case 'cancellable':\n                  break;\n              }\n            });\n\n            if (!isInstanceCall && cancellable) {\n              timeoutDeferred = $q.defer();\n              httpConfig.timeout = timeoutDeferred.promise;\n\n              if (numericTimeout) {\n                numericTimeoutPromise = $timeout(timeoutDeferred.resolve, numericTimeout);\n              }\n            }\n\n            if (hasBody) httpConfig.data = data;\n            route.setUrlParams(httpConfig,\n              extend({}, extractParams(data, action.params || {}), params),\n              action.url);\n\n            var promise = $http(httpConfig).then(function(response) {\n              var data = response.data;\n\n              if (data) {\n                // Need to convert action.isArray to boolean in case it is undefined\n                if (angular.isArray(data) !== (!!action.isArray)) {\n                  throw $resourceMinErr('badcfg',\n                      'Error in resource configuration for action `{0}`. Expected response to ' +\n                      'contain an {1} but got an {2} (Request: {3} {4})', name, action.isArray ? 'array' : 'object',\n                    angular.isArray(data) ? 'array' : 'object', httpConfig.method, httpConfig.url);\n                }\n                if (action.isArray) {\n                  value.length = 0;\n                  forEach(data, function(item) {\n                    if (typeof item === 'object') {\n                      value.push(new Resource(item));\n                    } else {\n                      // Valid JSON values may be string literals, and these should not be converted\n                      // into objects. These items will not have access to the Resource prototype\n                      // methods, but unfortunately there\n                      value.push(item);\n                    }\n                  });\n                } else {\n                  var promise = value.$promise;     // Save the promise\n                  shallowClearAndCopy(data, value);\n                  value.$promise = promise;         // Restore the promise\n                }\n              }\n              response.resource = value;\n\n              return response;\n            }, function(response) {\n              (error || noop)(response);\n              return $q.reject(response);\n            });\n\n            promise['finally'](function() {\n              value.$resolved = true;\n              if (!isInstanceCall && cancellable) {\n                value.$cancelRequest = angular.noop;\n                $timeout.cancel(numericTimeoutPromise);\n                timeoutDeferred = numericTimeoutPromise = httpConfig.timeout = null;\n              }\n            });\n\n            promise = promise.then(\n              function(response) {\n                var value = responseInterceptor(response);\n                (success || noop)(value, response.headers);\n                return value;\n              },\n              responseErrorInterceptor);\n\n            if (!isInstanceCall) {\n              // we are creating instance / collection\n              // - set the initial promise\n              // - return the instance / collection\n              value.$promise = promise;\n              value.$resolved = false;\n              if (cancellable) value.$cancelRequest = timeoutDeferred.resolve;\n\n              return value;\n            }\n\n            // instance call\n            return promise;\n          };\n\n\n          Resource.prototype['$' + name] = function(params, success, error) {\n            if (isFunction(params)) {\n              error = success; success = params; params = {};\n            }\n            var result = Resource[name].call(this, params, this, success, error);\n            return result.$promise || result;\n          };\n        });\n\n        Resource.bind = function(additionalParamDefaults) {\n          return resourceFactory(url, extend({}, paramDefaults, additionalParamDefaults), actions);\n        };\n\n        return Resource;\n      }\n\n      return resourceFactory;\n    }];\n  });\n\n\n})(window, window.angular);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2FuZ3VsYXItcmVzb3VyY2UvYW5ndWxhci1yZXNvdXJjZS5qcz9mMzc3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4REFBOEQsRUFBRTtBQUNoRTtBQUNBO0FBQ0EsbUNBQW1DLGtDQUFrQztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxtQ0FBbUMsTUFBTSwyQkFBMkI7QUFDNUU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxxQkFBcUI7QUFDakU7QUFDQSxpQkFBaUIsOEJBQThCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsaUNBQWlDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsdUJBQXVCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsOEZBQThGO0FBQzlGLGlDQUFpQztBQUNqQztBQUNBLFVBQVUsVUFBVSw4Q0FBOEM7QUFDbEUsb0JBQW9CLDhDQUE4QztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0EsdUJBQXVCLE9BQU87QUFDOUI7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQSxTQUFTLG9FQUFvRTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG9FQUFvRTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGNBQWM7QUFDckM7QUFDQSxRQUFRLHFDQUFxQztBQUM3QztBQUNBLHlCQUF5QixPQUFPO0FBQ2hDLGlDQUFpQyxrQ0FBa0MsR0FBRyxxQkFBcUI7QUFDM0Y7QUFDQTtBQUNBLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixPQUFPO0FBQ3JDO0FBQ0EsNkJBQTZCLFFBQVE7QUFDckM7QUFDQSx5Q0FBeUMsa0NBQWtDO0FBQzNFO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQSxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0EsTUFBTSxZQUFZLGFBQWE7QUFDL0Isa0JBQWtCLGNBQWM7QUFDaEMsa0JBQWtCLDJCQUEyQjtBQUM3QyxrQkFBa0IsZ0JBQWdCO0FBQ2xDLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBLHNDQUFzQyxlQUFlO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsYUFBYTtBQUN6RCwwQkFBMEIsV0FBVztBQUNyQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNFQUFzRTtBQUM5RTtBQUNBO0FBQ0EscURBQXFELDZCQUE2QjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLHFCQUFxQjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyx5QkFBeUI7QUFDaEMsZ0JBQWdCLHVCQUF1QjtBQUN2QyxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixvQ0FBb0M7O0FBRWpFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQywyQkFBMkI7O0FBRTNCO0FBQ0EscUJBQXFCLFlBQVk7QUFDakMsNERBQTREO0FBQzVELE1BQU07O0FBRU47QUFDQSxtQ0FBbUMsY0FBYztBQUNqRDtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QyxhQUFhO0FBQ3pELGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGFBQWE7QUFDekQsZUFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGFBQWE7QUFDekQsZUFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLFdBQVc7QUFDWCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsVUFBVTtBQUN4RDtBQUNBLGVBQWU7QUFDZixNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDLHNCQUFzQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0EsNkJBQTZCLFFBQVE7QUFDckM7QUFDQSx1Q0FBdUMsMkJBQTJCO0FBQ2xFO0FBQ0E7QUFDQSx5QkFBeUIsZ0JBQWdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMkJBQTJCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGNBQWM7QUFDL0Isa0JBQWtCLGVBQWU7QUFDakMsbUJBQW1CLDZCQUE2QjtBQUNoRCxvQkFBb0IsaUJBQWlCO0FBQ3JDLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qix3QkFBd0IsY0FBYztBQUN0Qyx3QkFBd0IsNEJBQTRCO0FBQ3BELHdCQUF3QixjQUFjO0FBQ3RDLHdCQUF3QjtBQUN4QjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUIsaUJBQWlCLGVBQWU7QUFDaEMsa0JBQWtCLDZCQUE2QjtBQUMvQyxtQkFBbUIsaUJBQWlCO0FBQ3BDLG1CQUFtQjtBQUNuQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOzs7QUFHQTtBQUNBOztBQUVBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBLG9DQUFvQyxxQkFBcUI7QUFDekQ7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QztBQUN6Qzs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRixFQUFFO0FBQ3JGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLHlDQUF5QztBQUNoRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLEVBQUU7QUFDdEUsbUNBQW1DLEVBQUUsYUFBYSxFQUFFLFlBQVksRUFBRSxFQUFFLEVBQUU7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixpQkFBaUI7QUFDakIsK0NBQStDO0FBQy9DO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLDhCQUE4QixrQkFBa0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsK0NBQStDO0FBQy9DOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7O0FBR0gsQ0FBQyIsImZpbGUiOiIzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBBbmd1bGFySlMgdjEuNS45XG4gKiAoYykgMjAxMC0yMDE2IEdvb2dsZSwgSW5jLiBodHRwOi8vYW5ndWxhcmpzLm9yZ1xuICogTGljZW5zZTogTUlUXG4gKi9cbihmdW5jdGlvbih3aW5kb3csIGFuZ3VsYXIpIHsndXNlIHN0cmljdCc7XG5cbnZhciAkcmVzb3VyY2VNaW5FcnIgPSBhbmd1bGFyLiQkbWluRXJyKCckcmVzb3VyY2UnKTtcblxuLy8gSGVscGVyIGZ1bmN0aW9ucyBhbmQgcmVnZXggdG8gbG9va3VwIGEgZG90dGVkIHBhdGggb24gYW4gb2JqZWN0XG4vLyBzdG9wcGluZyBhdCB1bmRlZmluZWQvbnVsbC4gIFRoZSBwYXRoIG11c3QgYmUgY29tcG9zZWQgb2YgQVNDSUlcbi8vIGlkZW50aWZpZXJzIChqdXN0IGxpa2UgJHBhcnNlKVxudmFyIE1FTUJFUl9OQU1FX1JFR0VYID0gL14oXFwuW2EtekEtWl8kQF1bMC05YS16QS1aXyRAXSopKyQvO1xuXG5mdW5jdGlvbiBpc1ZhbGlkRG90dGVkUGF0aChwYXRoKSB7XG4gIHJldHVybiAocGF0aCAhPSBudWxsICYmIHBhdGggIT09ICcnICYmIHBhdGggIT09ICdoYXNPd25Qcm9wZXJ0eScgJiZcbiAgICAgIE1FTUJFUl9OQU1FX1JFR0VYLnRlc3QoJy4nICsgcGF0aCkpO1xufVxuXG5mdW5jdGlvbiBsb29rdXBEb3R0ZWRQYXRoKG9iaiwgcGF0aCkge1xuICBpZiAoIWlzVmFsaWREb3R0ZWRQYXRoKHBhdGgpKSB7XG4gICAgdGhyb3cgJHJlc291cmNlTWluRXJyKCdiYWRtZW1iZXInLCAnRG90dGVkIG1lbWJlciBwYXRoIFwiQHswfVwiIGlzIGludmFsaWQuJywgcGF0aCk7XG4gIH1cbiAgdmFyIGtleXMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IGtleXMubGVuZ3RoOyBpIDwgaWkgJiYgYW5ndWxhci5pc0RlZmluZWQob2JqKTsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgb2JqID0gKG9iaiAhPT0gbnVsbCkgPyBvYmpba2V5XSA6IHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIHNoYWxsb3cgY29weSBvZiBhbiBvYmplY3QgYW5kIGNsZWFyIG90aGVyIGZpZWxkcyBmcm9tIHRoZSBkZXN0aW5hdGlvblxuICovXG5mdW5jdGlvbiBzaGFsbG93Q2xlYXJBbmRDb3B5KHNyYywgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCB7fTtcblxuICBhbmd1bGFyLmZvckVhY2goZHN0LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgZGVsZXRlIGRzdFtrZXldO1xuICB9KTtcblxuICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgaWYgKHNyYy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmICEoa2V5LmNoYXJBdCgwKSA9PT0gJyQnICYmIGtleS5jaGFyQXQoMSkgPT09ICckJykpIHtcbiAgICAgIGRzdFtrZXldID0gc3JjW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRzdDtcbn1cblxuLyoqXG4gKiBAbmdkb2MgbW9kdWxlXG4gKiBAbmFtZSBuZ1Jlc291cmNlXG4gKiBAZGVzY3JpcHRpb25cbiAqXG4gKiAjIG5nUmVzb3VyY2VcbiAqXG4gKiBUaGUgYG5nUmVzb3VyY2VgIG1vZHVsZSBwcm92aWRlcyBpbnRlcmFjdGlvbiBzdXBwb3J0IHdpdGggUkVTVGZ1bCBzZXJ2aWNlc1xuICogdmlhIHRoZSAkcmVzb3VyY2Ugc2VydmljZS5cbiAqXG4gKlxuICogPGRpdiBkb2MtbW9kdWxlLWNvbXBvbmVudHM9XCJuZ1Jlc291cmNlXCI+PC9kaXY+XG4gKlxuICogU2VlIHtAbGluayBuZ1Jlc291cmNlLiRyZXNvdXJjZVByb3ZpZGVyfSBhbmQge0BsaW5rIG5nUmVzb3VyY2UuJHJlc291cmNlfSBmb3IgdXNhZ2UuXG4gKi9cblxuLyoqXG4gKiBAbmdkb2MgcHJvdmlkZXJcbiAqIEBuYW1lICRyZXNvdXJjZVByb3ZpZGVyXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKlxuICogVXNlIGAkcmVzb3VyY2VQcm92aWRlcmAgdG8gY2hhbmdlIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mIHRoZSB7QGxpbmsgbmdSZXNvdXJjZS4kcmVzb3VyY2V9XG4gKiBzZXJ2aWNlLlxuICpcbiAqICMjIERlcGVuZGVuY2llc1xuICogUmVxdWlyZXMgdGhlIHtAbGluayBuZ1Jlc291cmNlIH0gbW9kdWxlIHRvIGJlIGluc3RhbGxlZC5cbiAqXG4gKi9cblxuLyoqXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJHJlc291cmNlXG4gKiBAcmVxdWlyZXMgJGh0dHBcbiAqIEByZXF1aXJlcyBuZy4kbG9nXG4gKiBAcmVxdWlyZXMgJHFcbiAqIEByZXF1aXJlcyBuZy4kdGltZW91dFxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQSBmYWN0b3J5IHdoaWNoIGNyZWF0ZXMgYSByZXNvdXJjZSBvYmplY3QgdGhhdCBsZXRzIHlvdSBpbnRlcmFjdCB3aXRoXG4gKiBbUkVTVGZ1bF0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9SZXByZXNlbnRhdGlvbmFsX1N0YXRlX1RyYW5zZmVyKSBzZXJ2ZXItc2lkZSBkYXRhIHNvdXJjZXMuXG4gKlxuICogVGhlIHJldHVybmVkIHJlc291cmNlIG9iamVjdCBoYXMgYWN0aW9uIG1ldGhvZHMgd2hpY2ggcHJvdmlkZSBoaWdoLWxldmVsIGJlaGF2aW9ycyB3aXRob3V0XG4gKiB0aGUgbmVlZCB0byBpbnRlcmFjdCB3aXRoIHRoZSBsb3cgbGV2ZWwge0BsaW5rIG5nLiRodHRwICRodHRwfSBzZXJ2aWNlLlxuICpcbiAqIFJlcXVpcmVzIHRoZSB7QGxpbmsgbmdSZXNvdXJjZSBgbmdSZXNvdXJjZWB9IG1vZHVsZSB0byBiZSBpbnN0YWxsZWQuXG4gKlxuICogQnkgZGVmYXVsdCwgdHJhaWxpbmcgc2xhc2hlcyB3aWxsIGJlIHN0cmlwcGVkIGZyb20gdGhlIGNhbGN1bGF0ZWQgVVJMcyxcbiAqIHdoaWNoIGNhbiBwb3NlIHByb2JsZW1zIHdpdGggc2VydmVyIGJhY2tlbmRzIHRoYXQgZG8gbm90IGV4cGVjdCB0aGF0XG4gKiBiZWhhdmlvci4gIFRoaXMgY2FuIGJlIGRpc2FibGVkIGJ5IGNvbmZpZ3VyaW5nIHRoZSBgJHJlc291cmNlUHJvdmlkZXJgIGxpa2VcbiAqIHRoaXM6XG4gKlxuICogYGBganNcbiAgICAgYXBwLmNvbmZpZyhbJyRyZXNvdXJjZVByb3ZpZGVyJywgZnVuY3Rpb24oJHJlc291cmNlUHJvdmlkZXIpIHtcbiAgICAgICAvLyBEb24ndCBzdHJpcCB0cmFpbGluZyBzbGFzaGVzIGZyb20gY2FsY3VsYXRlZCBVUkxzXG4gICAgICAgJHJlc291cmNlUHJvdmlkZXIuZGVmYXVsdHMuc3RyaXBUcmFpbGluZ1NsYXNoZXMgPSBmYWxzZTtcbiAgICAgfV0pO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBBIHBhcmFtZXRlcml6ZWQgVVJMIHRlbXBsYXRlIHdpdGggcGFyYW1ldGVycyBwcmVmaXhlZCBieSBgOmAgYXMgaW5cbiAqICAgYC91c2VyLzp1c2VybmFtZWAuIElmIHlvdSBhcmUgdXNpbmcgYSBVUkwgd2l0aCBhIHBvcnQgbnVtYmVyIChlLmcuXG4gKiAgIGBodHRwOi8vZXhhbXBsZS5jb206ODA4MC9hcGlgKSwgaXQgd2lsbCBiZSByZXNwZWN0ZWQuXG4gKlxuICogICBJZiB5b3UgYXJlIHVzaW5nIGEgdXJsIHdpdGggYSBzdWZmaXgsIGp1c3QgYWRkIHRoZSBzdWZmaXgsIGxpa2UgdGhpczpcbiAqICAgYCRyZXNvdXJjZSgnaHR0cDovL2V4YW1wbGUuY29tL3Jlc291cmNlLmpzb24nKWAgb3IgYCRyZXNvdXJjZSgnaHR0cDovL2V4YW1wbGUuY29tLzppZC5qc29uJylgXG4gKiAgIG9yIGV2ZW4gYCRyZXNvdXJjZSgnaHR0cDovL2V4YW1wbGUuY29tL3Jlc291cmNlLzpyZXNvdXJjZV9pZC46Zm9ybWF0JylgXG4gKiAgIElmIHRoZSBwYXJhbWV0ZXIgYmVmb3JlIHRoZSBzdWZmaXggaXMgZW1wdHksIDpyZXNvdXJjZV9pZCBpbiB0aGlzIGNhc2UsIHRoZW4gdGhlIGAvLmAgd2lsbCBiZVxuICogICBjb2xsYXBzZWQgZG93biB0byBhIHNpbmdsZSBgLmAuICBJZiB5b3UgbmVlZCB0aGlzIHNlcXVlbmNlIHRvIGFwcGVhciBhbmQgbm90IGNvbGxhcHNlIHRoZW4geW91XG4gKiAgIGNhbiBlc2NhcGUgaXQgd2l0aCBgL1xcLmAuXG4gKlxuICogQHBhcmFtIHtPYmplY3Q9fSBwYXJhbURlZmF1bHRzIERlZmF1bHQgdmFsdWVzIGZvciBgdXJsYCBwYXJhbWV0ZXJzLiBUaGVzZSBjYW4gYmUgb3ZlcnJpZGRlbiBpblxuICogICBgYWN0aW9uc2AgbWV0aG9kcy4gSWYgYSBwYXJhbWV0ZXIgdmFsdWUgaXMgYSBmdW5jdGlvbiwgaXQgd2lsbCBiZSBjYWxsZWQgZXZlcnkgdGltZVxuICogICBhIHBhcmFtIHZhbHVlIG5lZWRzIHRvIGJlIG9idGFpbmVkIGZvciBhIHJlcXVlc3QgKHVubGVzcyB0aGUgcGFyYW0gd2FzIG92ZXJyaWRkZW4pLiBUaGUgZnVuY3Rpb25cbiAqICAgd2lsbCBiZSBwYXNzZWQgdGhlIGN1cnJlbnQgZGF0YSB2YWx1ZSBhcyBhbiBhcmd1bWVudC5cbiAqXG4gKiAgIEVhY2gga2V5IHZhbHVlIGluIHRoZSBwYXJhbWV0ZXIgb2JqZWN0IGlzIGZpcnN0IGJvdW5kIHRvIHVybCB0ZW1wbGF0ZSBpZiBwcmVzZW50IGFuZCB0aGVuIGFueVxuICogICBleGNlc3Mga2V5cyBhcmUgYXBwZW5kZWQgdG8gdGhlIHVybCBzZWFyY2ggcXVlcnkgYWZ0ZXIgdGhlIGA/YC5cbiAqXG4gKiAgIEdpdmVuIGEgdGVtcGxhdGUgYC9wYXRoLzp2ZXJiYCBhbmQgcGFyYW1ldGVyIGB7dmVyYjonZ3JlZXQnLCBzYWx1dGF0aW9uOidIZWxsbyd9YCByZXN1bHRzIGluXG4gKiAgIFVSTCBgL3BhdGgvZ3JlZXQ/c2FsdXRhdGlvbj1IZWxsb2AuXG4gKlxuICogICBJZiB0aGUgcGFyYW1ldGVyIHZhbHVlIGlzIHByZWZpeGVkIHdpdGggYEBgLCB0aGVuIHRoZSB2YWx1ZSBmb3IgdGhhdCBwYXJhbWV0ZXIgd2lsbCBiZVxuICogICBleHRyYWN0ZWQgZnJvbSB0aGUgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSBvbiB0aGUgYGRhdGFgIG9iamVjdCAocHJvdmlkZWQgd2hlbiBjYWxsaW5nIGFcbiAqICAgXCJub24tR0VUXCIgYWN0aW9uIG1ldGhvZCkuXG4gKiAgIEZvciBleGFtcGxlLCBpZiB0aGUgYGRlZmF1bHRQYXJhbWAgb2JqZWN0IGlzIGB7c29tZVBhcmFtOiAnQHNvbWVQcm9wJ31gIHRoZW4gdGhlIHZhbHVlIG9mXG4gKiAgIGBzb21lUGFyYW1gIHdpbGwgYmUgYGRhdGEuc29tZVByb3BgLlxuICogICBOb3RlIHRoYXQgdGhlIHBhcmFtZXRlciB3aWxsIGJlIGlnbm9yZWQsIHdoZW4gY2FsbGluZyBhIFwiR0VUXCIgYWN0aW9uIG1ldGhvZCAoaS5lLiBhbiBhY3Rpb25cbiAqICAgbWV0aG9kIHRoYXQgZG9lcyBub3QgYWNjZXB0IGEgcmVxdWVzdCBib2R5KVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0LjxPYmplY3Q+PX0gYWN0aW9ucyBIYXNoIHdpdGggZGVjbGFyYXRpb24gb2YgY3VzdG9tIGFjdGlvbnMgdGhhdCBzaG91bGQgZXh0ZW5kXG4gKiAgIHRoZSBkZWZhdWx0IHNldCBvZiByZXNvdXJjZSBhY3Rpb25zLiBUaGUgZGVjbGFyYXRpb24gc2hvdWxkIGJlIGNyZWF0ZWQgaW4gdGhlIGZvcm1hdCBvZiB7QGxpbmtcbiAqICAgbmcuJGh0dHAjdXNhZ2UgJGh0dHAuY29uZmlnfTpcbiAqXG4gKiAgICAgICB7YWN0aW9uMToge21ldGhvZDo/LCBwYXJhbXM6PywgaXNBcnJheTo/LCBoZWFkZXJzOj8sIC4uLn0sXG4gKiAgICAgICAgYWN0aW9uMjoge21ldGhvZDo/LCBwYXJhbXM6PywgaXNBcnJheTo/LCBoZWFkZXJzOj8sIC4uLn0sXG4gKiAgICAgICAgLi4ufVxuICpcbiAqICAgV2hlcmU6XG4gKlxuICogICAtICoqYGFjdGlvbmAqKiDigJMge3N0cmluZ30g4oCTIFRoZSBuYW1lIG9mIGFjdGlvbi4gVGhpcyBuYW1lIGJlY29tZXMgdGhlIG5hbWUgb2YgdGhlIG1ldGhvZCBvblxuICogICAgIHlvdXIgcmVzb3VyY2Ugb2JqZWN0LlxuICogICAtICoqYG1ldGhvZGAqKiDigJMge3N0cmluZ30g4oCTIENhc2UgaW5zZW5zaXRpdmUgSFRUUCBtZXRob2QgKGUuZy4gYEdFVGAsIGBQT1NUYCwgYFBVVGAsXG4gKiAgICAgYERFTEVURWAsIGBKU09OUGAsIGV0YykuXG4gKiAgIC0gKipgcGFyYW1zYCoqIOKAkyB7T2JqZWN0PX0g4oCTIE9wdGlvbmFsIHNldCBvZiBwcmUtYm91bmQgcGFyYW1ldGVycyBmb3IgdGhpcyBhY3Rpb24uIElmIGFueSBvZlxuICogICAgIHRoZSBwYXJhbWV0ZXIgdmFsdWUgaXMgYSBmdW5jdGlvbiwgaXQgd2lsbCBiZSBjYWxsZWQgZXZlcnkgdGltZSB3aGVuIGEgcGFyYW0gdmFsdWUgbmVlZHMgdG9cbiAqICAgICBiZSBvYnRhaW5lZCBmb3IgYSByZXF1ZXN0ICh1bmxlc3MgdGhlIHBhcmFtIHdhcyBvdmVycmlkZGVuKS4gVGhlIGZ1bmN0aW9uIHdpbGwgYmUgcGFzc2VkIHRoZVxuICogICAgIGN1cnJlbnQgZGF0YSB2YWx1ZSBhcyBhbiBhcmd1bWVudC5cbiAqICAgLSAqKmB1cmxgKiog4oCTIHtzdHJpbmd9IOKAkyBhY3Rpb24gc3BlY2lmaWMgYHVybGAgb3ZlcnJpZGUuIFRoZSB1cmwgdGVtcGxhdGluZyBpcyBzdXBwb3J0ZWQganVzdFxuICogICAgIGxpa2UgZm9yIHRoZSByZXNvdXJjZS1sZXZlbCB1cmxzLlxuICogICAtICoqYGlzQXJyYXlgKiog4oCTIHtib29sZWFuPX0g4oCTIElmIHRydWUgdGhlbiB0aGUgcmV0dXJuZWQgb2JqZWN0IGZvciB0aGlzIGFjdGlvbiBpcyBhbiBhcnJheSxcbiAqICAgICBzZWUgYHJldHVybnNgIHNlY3Rpb24uXG4gKiAgIC0gKipgdHJhbnNmb3JtUmVxdWVzdGAqKiDigJNcbiAqICAgICBge2Z1bmN0aW9uKGRhdGEsIGhlYWRlcnNHZXR0ZXIpfEFycmF5LjxmdW5jdGlvbihkYXRhLCBoZWFkZXJzR2V0dGVyKT59YCDigJNcbiAqICAgICB0cmFuc2Zvcm0gZnVuY3Rpb24gb3IgYW4gYXJyYXkgb2Ygc3VjaCBmdW5jdGlvbnMuIFRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24gdGFrZXMgdGhlIGh0dHBcbiAqICAgICByZXF1ZXN0IGJvZHkgYW5kIGhlYWRlcnMgYW5kIHJldHVybnMgaXRzIHRyYW5zZm9ybWVkICh0eXBpY2FsbHkgc2VyaWFsaXplZCkgdmVyc2lvbi5cbiAqICAgICBCeSBkZWZhdWx0LCB0cmFuc2Zvcm1SZXF1ZXN0IHdpbGwgY29udGFpbiBvbmUgZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgdGhlIHJlcXVlc3QgZGF0YSBpc1xuICogICAgIGFuIG9iamVjdCBhbmQgc2VyaWFsaXplcyB0byB1c2luZyBgYW5ndWxhci50b0pzb25gLiBUbyBwcmV2ZW50IHRoaXMgYmVoYXZpb3IsIHNldFxuICogICAgIGB0cmFuc2Zvcm1SZXF1ZXN0YCB0byBhbiBlbXB0eSBhcnJheTogYHRyYW5zZm9ybVJlcXVlc3Q6IFtdYFxuICogICAtICoqYHRyYW5zZm9ybVJlc3BvbnNlYCoqIOKAk1xuICogICAgIGB7ZnVuY3Rpb24oZGF0YSwgaGVhZGVyc0dldHRlcil8QXJyYXkuPGZ1bmN0aW9uKGRhdGEsIGhlYWRlcnNHZXR0ZXIpPn1gIOKAk1xuICogICAgIHRyYW5zZm9ybSBmdW5jdGlvbiBvciBhbiBhcnJheSBvZiBzdWNoIGZ1bmN0aW9ucy4gVGhlIHRyYW5zZm9ybSBmdW5jdGlvbiB0YWtlcyB0aGUgaHR0cFxuICogICAgIHJlc3BvbnNlIGJvZHkgYW5kIGhlYWRlcnMgYW5kIHJldHVybnMgaXRzIHRyYW5zZm9ybWVkICh0eXBpY2FsbHkgZGVzZXJpYWxpemVkKSB2ZXJzaW9uLlxuICogICAgIEJ5IGRlZmF1bHQsIHRyYW5zZm9ybVJlc3BvbnNlIHdpbGwgY29udGFpbiBvbmUgZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgdGhlIHJlc3BvbnNlIGxvb2tzXG4gKiAgICAgbGlrZSBhIEpTT04gc3RyaW5nIGFuZCBkZXNlcmlhbGl6ZXMgaXQgdXNpbmcgYGFuZ3VsYXIuZnJvbUpzb25gLiBUbyBwcmV2ZW50IHRoaXMgYmVoYXZpb3IsXG4gKiAgICAgc2V0IGB0cmFuc2Zvcm1SZXNwb25zZWAgdG8gYW4gZW1wdHkgYXJyYXk6IGB0cmFuc2Zvcm1SZXNwb25zZTogW11gXG4gKiAgIC0gKipgY2FjaGVgKiog4oCTIGB7Ym9vbGVhbnxDYWNoZX1gIOKAkyBJZiB0cnVlLCBhIGRlZmF1bHQgJGh0dHAgY2FjaGUgd2lsbCBiZSB1c2VkIHRvIGNhY2hlIHRoZVxuICogICAgIEdFVCByZXF1ZXN0LCBvdGhlcndpc2UgaWYgYSBjYWNoZSBpbnN0YW5jZSBidWlsdCB3aXRoXG4gKiAgICAge0BsaW5rIG5nLiRjYWNoZUZhY3RvcnkgJGNhY2hlRmFjdG9yeX0sIHRoaXMgY2FjaGUgd2lsbCBiZSB1c2VkIGZvclxuICogICAgIGNhY2hpbmcuXG4gKiAgIC0gKipgdGltZW91dGAqKiDigJMgYHtudW1iZXJ9YCDigJMgdGltZW91dCBpbiBtaWxsaXNlY29uZHMuPGJyIC8+XG4gKiAgICAgKipOb3RlOioqIEluIGNvbnRyYXN0IHRvIHtAbGluayBuZy4kaHR0cCN1c2FnZSAkaHR0cC5jb25maWd9LCB7QGxpbmsgbmcuJHEgcHJvbWlzZXN9IGFyZVxuICogICAgICoqbm90Kiogc3VwcG9ydGVkIGluICRyZXNvdXJjZSwgYmVjYXVzZSB0aGUgc2FtZSB2YWx1ZSB3b3VsZCBiZSB1c2VkIGZvciBtdWx0aXBsZSByZXF1ZXN0cy5cbiAqICAgICBJZiB5b3UgYXJlIGxvb2tpbmcgZm9yIGEgd2F5IHRvIGNhbmNlbCByZXF1ZXN0cywgeW91IHNob3VsZCB1c2UgdGhlIGBjYW5jZWxsYWJsZWAgb3B0aW9uLlxuICogICAtICoqYGNhbmNlbGxhYmxlYCoqIOKAkyBge2Jvb2xlYW59YCDigJMgaWYgc2V0IHRvIHRydWUsIHRoZSByZXF1ZXN0IG1hZGUgYnkgYSBcIm5vbi1pbnN0YW5jZVwiIGNhbGxcbiAqICAgICB3aWxsIGJlIGNhbmNlbGxlZCAoaWYgbm90IGFscmVhZHkgY29tcGxldGVkKSBieSBjYWxsaW5nIGAkY2FuY2VsUmVxdWVzdCgpYCBvbiB0aGUgY2FsbCdzXG4gKiAgICAgcmV0dXJuIHZhbHVlLiBDYWxsaW5nIGAkY2FuY2VsUmVxdWVzdCgpYCBmb3IgYSBub24tY2FuY2VsbGFibGUgb3IgYW4gYWxyZWFkeVxuICogICAgIGNvbXBsZXRlZC9jYW5jZWxsZWQgcmVxdWVzdCB3aWxsIGhhdmUgbm8gZWZmZWN0LjxiciAvPlxuICogICAtICoqYHdpdGhDcmVkZW50aWFsc2AqKiAtIGB7Ym9vbGVhbn1gIC0gd2hldGhlciB0byBzZXQgdGhlIGB3aXRoQ3JlZGVudGlhbHNgIGZsYWcgb24gdGhlXG4gKiAgICAgWEhSIG9iamVjdC4gU2VlXG4gKiAgICAgW3JlcXVlc3RzIHdpdGggY3JlZGVudGlhbHNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2h0dHBfYWNjZXNzX2NvbnRyb2wjc2VjdGlvbl81KVxuICogICAgIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICogICAtICoqYHJlc3BvbnNlVHlwZWAqKiAtIGB7c3RyaW5nfWAgLSBzZWVcbiAqICAgICBbcmVxdWVzdFR5cGVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvRE9NL1hNTEh0dHBSZXF1ZXN0I3Jlc3BvbnNlVHlwZSkuXG4gKiAgIC0gKipgaW50ZXJjZXB0b3JgKiogLSBge09iamVjdD19YCAtIFRoZSBpbnRlcmNlcHRvciBvYmplY3QgaGFzIHR3byBvcHRpb25hbCBtZXRob2RzIC1cbiAqICAgICBgcmVzcG9uc2VgIGFuZCBgcmVzcG9uc2VFcnJvcmAuIEJvdGggYHJlc3BvbnNlYCBhbmQgYHJlc3BvbnNlRXJyb3JgIGludGVyY2VwdG9ycyBnZXQgY2FsbGVkXG4gKiAgICAgd2l0aCBgaHR0cCByZXNwb25zZWAgb2JqZWN0LiBTZWUge0BsaW5rIG5nLiRodHRwICRodHRwIGludGVyY2VwdG9yc30uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgSGFzaCB3aXRoIGN1c3RvbSBzZXR0aW5ncyB0aGF0IHNob3VsZCBleHRlbmQgdGhlXG4gKiAgIGRlZmF1bHQgYCRyZXNvdXJjZVByb3ZpZGVyYCBiZWhhdmlvci4gIFRoZSBzdXBwb3J0ZWQgb3B0aW9ucyBhcmU6XG4gKlxuICogICAtICoqYHN0cmlwVHJhaWxpbmdTbGFzaGVzYCoqIOKAkyB7Ym9vbGVhbn0g4oCTIElmIHRydWUgdGhlbiB0aGUgdHJhaWxpbmdcbiAqICAgc2xhc2hlcyBmcm9tIGFueSBjYWxjdWxhdGVkIFVSTCB3aWxsIGJlIHN0cmlwcGVkLiAoRGVmYXVsdHMgdG8gdHJ1ZS4pXG4gKiAgIC0gKipgY2FuY2VsbGFibGVgKiog4oCTIHtib29sZWFufSDigJMgSWYgdHJ1ZSwgdGhlIHJlcXVlc3QgbWFkZSBieSBhIFwibm9uLWluc3RhbmNlXCIgY2FsbCB3aWxsIGJlXG4gKiAgIGNhbmNlbGxlZCAoaWYgbm90IGFscmVhZHkgY29tcGxldGVkKSBieSBjYWxsaW5nIGAkY2FuY2VsUmVxdWVzdCgpYCBvbiB0aGUgY2FsbCdzIHJldHVybiB2YWx1ZS5cbiAqICAgVGhpcyBjYW4gYmUgb3ZlcndyaXR0ZW4gcGVyIGFjdGlvbi4gKERlZmF1bHRzIHRvIGZhbHNlLilcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBIHJlc291cmNlIFwiY2xhc3NcIiBvYmplY3Qgd2l0aCBtZXRob2RzIGZvciB0aGUgZGVmYXVsdCBzZXQgb2YgcmVzb3VyY2UgYWN0aW9uc1xuICogICBvcHRpb25hbGx5IGV4dGVuZGVkIHdpdGggY3VzdG9tIGBhY3Rpb25zYC4gVGhlIGRlZmF1bHQgc2V0IGNvbnRhaW5zIHRoZXNlIGFjdGlvbnM6XG4gKiAgIGBgYGpzXG4gKiAgIHsgJ2dldCc6ICAgIHttZXRob2Q6J0dFVCd9LFxuICogICAgICdzYXZlJzogICB7bWV0aG9kOidQT1NUJ30sXG4gKiAgICAgJ3F1ZXJ5JzogIHttZXRob2Q6J0dFVCcsIGlzQXJyYXk6dHJ1ZX0sXG4gKiAgICAgJ3JlbW92ZSc6IHttZXRob2Q6J0RFTEVURSd9LFxuICogICAgICdkZWxldGUnOiB7bWV0aG9kOidERUxFVEUnfSB9O1xuICogICBgYGBcbiAqXG4gKiAgIENhbGxpbmcgdGhlc2UgbWV0aG9kcyBpbnZva2UgYW4ge0BsaW5rIG5nLiRodHRwfSB3aXRoIHRoZSBzcGVjaWZpZWQgaHR0cCBtZXRob2QsXG4gKiAgIGRlc3RpbmF0aW9uIGFuZCBwYXJhbWV0ZXJzLiBXaGVuIHRoZSBkYXRhIGlzIHJldHVybmVkIGZyb20gdGhlIHNlcnZlciB0aGVuIHRoZSBvYmplY3QgaXMgYW5cbiAqICAgaW5zdGFuY2Ugb2YgdGhlIHJlc291cmNlIGNsYXNzLiBUaGUgYWN0aW9ucyBgc2F2ZWAsIGByZW1vdmVgIGFuZCBgZGVsZXRlYCBhcmUgYXZhaWxhYmxlIG9uIGl0XG4gKiAgIGFzICBtZXRob2RzIHdpdGggdGhlIGAkYCBwcmVmaXguIFRoaXMgYWxsb3dzIHlvdSB0byBlYXNpbHkgcGVyZm9ybSBDUlVEIG9wZXJhdGlvbnMgKGNyZWF0ZSxcbiAqICAgcmVhZCwgdXBkYXRlLCBkZWxldGUpIG9uIHNlcnZlci1zaWRlIGRhdGEgbGlrZSB0aGlzOlxuICogICBgYGBqc1xuICogICB2YXIgVXNlciA9ICRyZXNvdXJjZSgnL3VzZXIvOnVzZXJJZCcsIHt1c2VySWQ6J0BpZCd9KTtcbiAqICAgdmFyIHVzZXIgPSBVc2VyLmdldCh7dXNlcklkOjEyM30sIGZ1bmN0aW9uKCkge1xuICogICAgIHVzZXIuYWJjID0gdHJ1ZTtcbiAqICAgICB1c2VyLiRzYXZlKCk7XG4gKiAgIH0pO1xuICogICBgYGBcbiAqXG4gKiAgIEl0IGlzIGltcG9ydGFudCB0byByZWFsaXplIHRoYXQgaW52b2tpbmcgYSAkcmVzb3VyY2Ugb2JqZWN0IG1ldGhvZCBpbW1lZGlhdGVseSByZXR1cm5zIGFuXG4gKiAgIGVtcHR5IHJlZmVyZW5jZSAob2JqZWN0IG9yIGFycmF5IGRlcGVuZGluZyBvbiBgaXNBcnJheWApLiBPbmNlIHRoZSBkYXRhIGlzIHJldHVybmVkIGZyb20gdGhlXG4gKiAgIHNlcnZlciB0aGUgZXhpc3RpbmcgcmVmZXJlbmNlIGlzIHBvcHVsYXRlZCB3aXRoIHRoZSBhY3R1YWwgZGF0YS4gVGhpcyBpcyBhIHVzZWZ1bCB0cmljayBzaW5jZVxuICogICB1c3VhbGx5IHRoZSByZXNvdXJjZSBpcyBhc3NpZ25lZCB0byBhIG1vZGVsIHdoaWNoIGlzIHRoZW4gcmVuZGVyZWQgYnkgdGhlIHZpZXcuIEhhdmluZyBhbiBlbXB0eVxuICogICBvYmplY3QgcmVzdWx0cyBpbiBubyByZW5kZXJpbmcsIG9uY2UgdGhlIGRhdGEgYXJyaXZlcyBmcm9tIHRoZSBzZXJ2ZXIgdGhlbiB0aGUgb2JqZWN0IGlzXG4gKiAgIHBvcHVsYXRlZCB3aXRoIHRoZSBkYXRhIGFuZCB0aGUgdmlldyBhdXRvbWF0aWNhbGx5IHJlLXJlbmRlcnMgaXRzZWxmIHNob3dpbmcgdGhlIG5ldyBkYXRhLiBUaGlzXG4gKiAgIG1lYW5zIHRoYXQgaW4gbW9zdCBjYXNlcyBvbmUgbmV2ZXIgaGFzIHRvIHdyaXRlIGEgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIHRoZSBhY3Rpb24gbWV0aG9kcy5cbiAqXG4gKiAgIFRoZSBhY3Rpb24gbWV0aG9kcyBvbiB0aGUgY2xhc3Mgb2JqZWN0IG9yIGluc3RhbmNlIG9iamVjdCBjYW4gYmUgaW52b2tlZCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAqICAgcGFyYW1ldGVyczpcbiAqXG4gKiAgIC0gSFRUUCBHRVQgXCJjbGFzc1wiIGFjdGlvbnM6IGBSZXNvdXJjZS5hY3Rpb24oW3BhcmFtZXRlcnNdLCBbc3VjY2Vzc10sIFtlcnJvcl0pYFxuICogICAtIG5vbi1HRVQgXCJjbGFzc1wiIGFjdGlvbnM6IGBSZXNvdXJjZS5hY3Rpb24oW3BhcmFtZXRlcnNdLCBwb3N0RGF0YSwgW3N1Y2Nlc3NdLCBbZXJyb3JdKWBcbiAqICAgLSBub24tR0VUIGluc3RhbmNlIGFjdGlvbnM6ICBgaW5zdGFuY2UuJGFjdGlvbihbcGFyYW1ldGVyc10sIFtzdWNjZXNzXSwgW2Vycm9yXSlgXG4gKlxuICpcbiAqICAgU3VjY2VzcyBjYWxsYmFjayBpcyBjYWxsZWQgd2l0aCAodmFsdWUsIHJlc3BvbnNlSGVhZGVycykgYXJndW1lbnRzLCB3aGVyZSB0aGUgdmFsdWUgaXNcbiAqICAgdGhlIHBvcHVsYXRlZCByZXNvdXJjZSBpbnN0YW5jZSBvciBjb2xsZWN0aW9uIG9iamVjdC4gVGhlIGVycm9yIGNhbGxiYWNrIGlzIGNhbGxlZFxuICogICB3aXRoIChodHRwUmVzcG9uc2UpIGFyZ3VtZW50LlxuICpcbiAqICAgQ2xhc3MgYWN0aW9ucyByZXR1cm4gZW1wdHkgaW5zdGFuY2UgKHdpdGggYWRkaXRpb25hbCBwcm9wZXJ0aWVzIGJlbG93KS5cbiAqICAgSW5zdGFuY2UgYWN0aW9ucyByZXR1cm4gcHJvbWlzZSBvZiB0aGUgYWN0aW9uLlxuICpcbiAqICAgVGhlIFJlc291cmNlIGluc3RhbmNlcyBhbmQgY29sbGVjdGlvbnMgaGF2ZSB0aGVzZSBhZGRpdGlvbmFsIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGAkcHJvbWlzZWA6IHRoZSB7QGxpbmsgbmcuJHEgcHJvbWlzZX0gb2YgdGhlIG9yaWdpbmFsIHNlcnZlciBpbnRlcmFjdGlvbiB0aGF0IGNyZWF0ZWQgdGhpc1xuICogICAgIGluc3RhbmNlIG9yIGNvbGxlY3Rpb24uXG4gKlxuICogICAgIE9uIHN1Y2Nlc3MsIHRoZSBwcm9taXNlIGlzIHJlc29sdmVkIHdpdGggdGhlIHNhbWUgcmVzb3VyY2UgaW5zdGFuY2Ugb3IgY29sbGVjdGlvbiBvYmplY3QsXG4gKiAgICAgdXBkYXRlZCB3aXRoIGRhdGEgZnJvbSBzZXJ2ZXIuIFRoaXMgbWFrZXMgaXQgZWFzeSB0byB1c2UgaW5cbiAqICAgICB7QGxpbmsgbmdSb3V0ZS4kcm91dGVQcm92aWRlciByZXNvbHZlIHNlY3Rpb24gb2YgJHJvdXRlUHJvdmlkZXIud2hlbigpfSB0byBkZWZlciB2aWV3XG4gKiAgICAgcmVuZGVyaW5nIHVudGlsIHRoZSByZXNvdXJjZShzKSBhcmUgbG9hZGVkLlxuICpcbiAqICAgICBPbiBmYWlsdXJlLCB0aGUgcHJvbWlzZSBpcyByZWplY3RlZCB3aXRoIHRoZSB7QGxpbmsgbmcuJGh0dHAgaHR0cCByZXNwb25zZX0gb2JqZWN0LCB3aXRob3V0XG4gKiAgICAgdGhlIGByZXNvdXJjZWAgcHJvcGVydHkuXG4gKlxuICogICAgIElmIGFuIGludGVyY2VwdG9yIG9iamVjdCB3YXMgcHJvdmlkZWQsIHRoZSBwcm9taXNlIHdpbGwgaW5zdGVhZCBiZSByZXNvbHZlZCB3aXRoIHRoZSB2YWx1ZVxuICogICAgIHJldHVybmVkIGJ5IHRoZSBpbnRlcmNlcHRvci5cbiAqXG4gKiAgIC0gYCRyZXNvbHZlZGA6IGB0cnVlYCBhZnRlciBmaXJzdCBzZXJ2ZXIgaW50ZXJhY3Rpb24gaXMgY29tcGxldGVkIChlaXRoZXIgd2l0aCBzdWNjZXNzIG9yXG4gKiAgICAgIHJlamVjdGlvbiksIGBmYWxzZWAgYmVmb3JlIHRoYXQuIEtub3dpbmcgaWYgdGhlIFJlc291cmNlIGhhcyBiZWVuIHJlc29sdmVkIGlzIHVzZWZ1bCBpblxuICogICAgICBkYXRhLWJpbmRpbmcuXG4gKlxuICogICBUaGUgUmVzb3VyY2UgaW5zdGFuY2VzIGFuZCBjb2xsZWN0aW9ucyBoYXZlIHRoZXNlIGFkZGl0aW9uYWwgbWV0aG9kczpcbiAqXG4gKiAgIC0gYCRjYW5jZWxSZXF1ZXN0YDogSWYgdGhlcmUgaXMgYSBjYW5jZWxsYWJsZSwgcGVuZGluZyByZXF1ZXN0IHJlbGF0ZWQgdG8gdGhlIGluc3RhbmNlIG9yXG4gKiAgICAgIGNvbGxlY3Rpb24sIGNhbGxpbmcgdGhpcyBtZXRob2Qgd2lsbCBhYm9ydCB0aGUgcmVxdWVzdC5cbiAqXG4gKiAgIFRoZSBSZXNvdXJjZSBpbnN0YW5jZXMgaGF2ZSB0aGVzZSBhZGRpdGlvbmFsIG1ldGhvZHM6XG4gKlxuICogICAtIGB0b0pTT05gOiBJdCByZXR1cm5zIGEgc2ltcGxlIG9iamVjdCB3aXRob3V0IGFueSBvZiB0aGUgZXh0cmEgcHJvcGVydGllcyBhZGRlZCBhcyBwYXJ0IG9mXG4gKiAgICAgdGhlIFJlc291cmNlIEFQSS4gVGhpcyBvYmplY3QgY2FuIGJlIHNlcmlhbGl6ZWQgdGhyb3VnaCB7QGxpbmsgYW5ndWxhci50b0pzb259IHNhZmVseVxuICogICAgIHdpdGhvdXQgYXR0YWNoaW5nIEFuZ3VsYXItc3BlY2lmaWMgZmllbGRzLiBOb3RpY2UgdGhhdCBgSlNPTi5zdHJpbmdpZnlgIChhbmRcbiAqICAgICBgYW5ndWxhci50b0pzb25gKSBhdXRvbWF0aWNhbGx5IHVzZSB0aGlzIG1ldGhvZCB3aGVuIHNlcmlhbGl6aW5nIGEgUmVzb3VyY2UgaW5zdGFuY2VcbiAqICAgICAoc2VlIFtNRE5dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0pTT04vc3RyaW5naWZ5I3RvSlNPTigpX2JlaGF2aW9yKSkuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAjIENyZWRpdCBjYXJkIHJlc291cmNlXG4gKlxuICogYGBganNcbiAgICAgLy8gRGVmaW5lIENyZWRpdENhcmQgY2xhc3NcbiAgICAgdmFyIENyZWRpdENhcmQgPSAkcmVzb3VyY2UoJy91c2VyLzp1c2VySWQvY2FyZC86Y2FyZElkJyxcbiAgICAgIHt1c2VySWQ6MTIzLCBjYXJkSWQ6J0BpZCd9LCB7XG4gICAgICAgY2hhcmdlOiB7bWV0aG9kOidQT1NUJywgcGFyYW1zOntjaGFyZ2U6dHJ1ZX19XG4gICAgICB9KTtcblxuICAgICAvLyBXZSBjYW4gcmV0cmlldmUgYSBjb2xsZWN0aW9uIGZyb20gdGhlIHNlcnZlclxuICAgICB2YXIgY2FyZHMgPSBDcmVkaXRDYXJkLnF1ZXJ5KGZ1bmN0aW9uKCkge1xuICAgICAgIC8vIEdFVDogL3VzZXIvMTIzL2NhcmRcbiAgICAgICAvLyBzZXJ2ZXIgcmV0dXJuczogWyB7aWQ6NDU2LCBudW1iZXI6JzEyMzQnLCBuYW1lOidTbWl0aCd9IF07XG5cbiAgICAgICB2YXIgY2FyZCA9IGNhcmRzWzBdO1xuICAgICAgIC8vIGVhY2ggaXRlbSBpcyBhbiBpbnN0YW5jZSBvZiBDcmVkaXRDYXJkXG4gICAgICAgZXhwZWN0KGNhcmQgaW5zdGFuY2VvZiBDcmVkaXRDYXJkKS50b0VxdWFsKHRydWUpO1xuICAgICAgIGNhcmQubmFtZSA9IFwiSi4gU21pdGhcIjtcbiAgICAgICAvLyBub24gR0VUIG1ldGhvZHMgYXJlIG1hcHBlZCBvbnRvIHRoZSBpbnN0YW5jZXNcbiAgICAgICBjYXJkLiRzYXZlKCk7XG4gICAgICAgLy8gUE9TVDogL3VzZXIvMTIzL2NhcmQvNDU2IHtpZDo0NTYsIG51bWJlcjonMTIzNCcsIG5hbWU6J0ouIFNtaXRoJ31cbiAgICAgICAvLyBzZXJ2ZXIgcmV0dXJuczoge2lkOjQ1NiwgbnVtYmVyOicxMjM0JywgbmFtZTogJ0ouIFNtaXRoJ307XG5cbiAgICAgICAvLyBvdXIgY3VzdG9tIG1ldGhvZCBpcyBtYXBwZWQgYXMgd2VsbC5cbiAgICAgICBjYXJkLiRjaGFyZ2Uoe2Ftb3VudDo5Ljk5fSk7XG4gICAgICAgLy8gUE9TVDogL3VzZXIvMTIzL2NhcmQvNDU2P2Ftb3VudD05Ljk5JmNoYXJnZT10cnVlIHtpZDo0NTYsIG51bWJlcjonMTIzNCcsIG5hbWU6J0ouIFNtaXRoJ31cbiAgICAgfSk7XG5cbiAgICAgLy8gd2UgY2FuIGNyZWF0ZSBhbiBpbnN0YW5jZSBhcyB3ZWxsXG4gICAgIHZhciBuZXdDYXJkID0gbmV3IENyZWRpdENhcmQoe251bWJlcjonMDEyMyd9KTtcbiAgICAgbmV3Q2FyZC5uYW1lID0gXCJNaWtlIFNtaXRoXCI7XG4gICAgIG5ld0NhcmQuJHNhdmUoKTtcbiAgICAgLy8gUE9TVDogL3VzZXIvMTIzL2NhcmQge251bWJlcjonMDEyMycsIG5hbWU6J01pa2UgU21pdGgnfVxuICAgICAvLyBzZXJ2ZXIgcmV0dXJuczoge2lkOjc4OSwgbnVtYmVyOicwMTIzJywgbmFtZTogJ01pa2UgU21pdGgnfTtcbiAgICAgZXhwZWN0KG5ld0NhcmQuaWQpLnRvRXF1YWwoNzg5KTtcbiAqIGBgYFxuICpcbiAqIFRoZSBvYmplY3QgcmV0dXJuZWQgZnJvbSB0aGlzIGZ1bmN0aW9uIGV4ZWN1dGlvbiBpcyBhIHJlc291cmNlIFwiY2xhc3NcIiB3aGljaCBoYXMgXCJzdGF0aWNcIiBtZXRob2RcbiAqIGZvciBlYWNoIGFjdGlvbiBpbiB0aGUgZGVmaW5pdGlvbi5cbiAqXG4gKiBDYWxsaW5nIHRoZXNlIG1ldGhvZHMgaW52b2tlIGAkaHR0cGAgb24gdGhlIGB1cmxgIHRlbXBsYXRlIHdpdGggdGhlIGdpdmVuIGBtZXRob2RgLCBgcGFyYW1zYCBhbmRcbiAqIGBoZWFkZXJzYC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqICMgVXNlciByZXNvdXJjZVxuICpcbiAqIFdoZW4gdGhlIGRhdGEgaXMgcmV0dXJuZWQgZnJvbSB0aGUgc2VydmVyIHRoZW4gdGhlIG9iamVjdCBpcyBhbiBpbnN0YW5jZSBvZiB0aGUgcmVzb3VyY2UgdHlwZSBhbmRcbiAqIGFsbCBvZiB0aGUgbm9uLUdFVCBtZXRob2RzIGFyZSBhdmFpbGFibGUgd2l0aCBgJGAgcHJlZml4LiBUaGlzIGFsbG93cyB5b3UgdG8gZWFzaWx5IHN1cHBvcnQgQ1JVRFxuICogb3BlcmF0aW9ucyAoY3JlYXRlLCByZWFkLCB1cGRhdGUsIGRlbGV0ZSkgb24gc2VydmVyLXNpZGUgZGF0YS5cblxuICAgYGBganNcbiAgICAgdmFyIFVzZXIgPSAkcmVzb3VyY2UoJy91c2VyLzp1c2VySWQnLCB7dXNlcklkOidAaWQnfSk7XG4gICAgIFVzZXIuZ2V0KHt1c2VySWQ6MTIzfSwgZnVuY3Rpb24odXNlcikge1xuICAgICAgIHVzZXIuYWJjID0gdHJ1ZTtcbiAgICAgICB1c2VyLiRzYXZlKCk7XG4gICAgIH0pO1xuICAgYGBgXG4gKlxuICogSXQncyB3b3J0aCBub3RpbmcgdGhhdCB0aGUgc3VjY2VzcyBjYWxsYmFjayBmb3IgYGdldGAsIGBxdWVyeWAgYW5kIG90aGVyIG1ldGhvZHMgZ2V0cyBwYXNzZWRcbiAqIGluIHRoZSByZXNwb25zZSB0aGF0IGNhbWUgZnJvbSB0aGUgc2VydmVyIGFzIHdlbGwgYXMgJGh0dHAgaGVhZGVyIGdldHRlciBmdW5jdGlvbiwgc28gb25lXG4gKiBjb3VsZCByZXdyaXRlIHRoZSBhYm92ZSBleGFtcGxlIGFuZCBnZXQgYWNjZXNzIHRvIGh0dHAgaGVhZGVycyBhczpcbiAqXG4gICBgYGBqc1xuICAgICB2YXIgVXNlciA9ICRyZXNvdXJjZSgnL3VzZXIvOnVzZXJJZCcsIHt1c2VySWQ6J0BpZCd9KTtcbiAgICAgVXNlci5nZXQoe3VzZXJJZDoxMjN9LCBmdW5jdGlvbih1c2VyLCBnZXRSZXNwb25zZUhlYWRlcnMpe1xuICAgICAgIHVzZXIuYWJjID0gdHJ1ZTtcbiAgICAgICB1c2VyLiRzYXZlKGZ1bmN0aW9uKHVzZXIsIHB1dFJlc3BvbnNlSGVhZGVycykge1xuICAgICAgICAgLy91c2VyID0+IHNhdmVkIHVzZXIgb2JqZWN0XG4gICAgICAgICAvL3B1dFJlc3BvbnNlSGVhZGVycyA9PiAkaHR0cCBoZWFkZXIgZ2V0dGVyXG4gICAgICAgfSk7XG4gICAgIH0pO1xuICAgYGBgXG4gKlxuICogWW91IGNhbiBhbHNvIGFjY2VzcyB0aGUgcmF3IGAkaHR0cGAgcHJvbWlzZSB2aWEgdGhlIGAkcHJvbWlzZWAgcHJvcGVydHkgb24gdGhlIG9iamVjdCByZXR1cm5lZFxuICpcbiAgIGBgYFxuICAgICB2YXIgVXNlciA9ICRyZXNvdXJjZSgnL3VzZXIvOnVzZXJJZCcsIHt1c2VySWQ6J0BpZCd9KTtcbiAgICAgVXNlci5nZXQoe3VzZXJJZDoxMjN9KVxuICAgICAgICAgLiRwcm9taXNlLnRoZW4oZnVuY3Rpb24odXNlcikge1xuICAgICAgICAgICAkc2NvcGUudXNlciA9IHVzZXI7XG4gICAgICAgICB9KTtcbiAgIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogIyBDcmVhdGluZyBhIGN1c3RvbSAnUFVUJyByZXF1ZXN0XG4gKlxuICogSW4gdGhpcyBleGFtcGxlIHdlIGNyZWF0ZSBhIGN1c3RvbSBtZXRob2Qgb24gb3VyIHJlc291cmNlIHRvIG1ha2UgYSBQVVQgcmVxdWVzdFxuICogYGBganNcbiAqICAgIHZhciBhcHAgPSBhbmd1bGFyLm1vZHVsZSgnYXBwJywgWyduZ1Jlc291cmNlJywgJ25nUm91dGUnXSk7XG4gKlxuICogICAgLy8gU29tZSBBUElzIGV4cGVjdCBhIFBVVCByZXF1ZXN0IGluIHRoZSBmb3JtYXQgVVJML29iamVjdC9JRFxuICogICAgLy8gSGVyZSB3ZSBhcmUgY3JlYXRpbmcgYW4gJ3VwZGF0ZScgbWV0aG9kXG4gKiAgICBhcHAuZmFjdG9yeSgnTm90ZXMnLCBbJyRyZXNvdXJjZScsIGZ1bmN0aW9uKCRyZXNvdXJjZSkge1xuICogICAgcmV0dXJuICRyZXNvdXJjZSgnL25vdGVzLzppZCcsIG51bGwsXG4gKiAgICAgICAge1xuICogICAgICAgICAgICAndXBkYXRlJzogeyBtZXRob2Q6J1BVVCcgfVxuICogICAgICAgIH0pO1xuICogICAgfV0pO1xuICpcbiAqICAgIC8vIEluIG91ciBjb250cm9sbGVyIHdlIGdldCB0aGUgSUQgZnJvbSB0aGUgVVJMIHVzaW5nIG5nUm91dGUgYW5kICRyb3V0ZVBhcmFtc1xuICogICAgLy8gV2UgcGFzcyBpbiAkcm91dGVQYXJhbXMgYW5kIG91ciBOb3RlcyBmYWN0b3J5IGFsb25nIHdpdGggJHNjb3BlXG4gKiAgICBhcHAuY29udHJvbGxlcignTm90ZXNDdHJsJywgWyckc2NvcGUnLCAnJHJvdXRlUGFyYW1zJywgJ05vdGVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oJHNjb3BlLCAkcm91dGVQYXJhbXMsIE5vdGVzKSB7XG4gKiAgICAvLyBGaXJzdCBnZXQgYSBub3RlIG9iamVjdCBmcm9tIHRoZSBmYWN0b3J5XG4gKiAgICB2YXIgbm90ZSA9IE5vdGVzLmdldCh7IGlkOiRyb3V0ZVBhcmFtcy5pZCB9KTtcbiAqICAgICRpZCA9IG5vdGUuaWQ7XG4gKlxuICogICAgLy8gTm93IGNhbGwgdXBkYXRlIHBhc3NpbmcgaW4gdGhlIElEIGZpcnN0IHRoZW4gdGhlIG9iamVjdCB5b3UgYXJlIHVwZGF0aW5nXG4gKiAgICBOb3Rlcy51cGRhdGUoeyBpZDokaWQgfSwgbm90ZSk7XG4gKlxuICogICAgLy8gVGhpcyB3aWxsIFBVVCAvbm90ZXMvSUQgd2l0aCB0aGUgbm90ZSBvYmplY3QgaW4gdGhlIHJlcXVlc3QgcGF5bG9hZFxuICogICAgfV0pO1xuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAjIENhbmNlbGxpbmcgcmVxdWVzdHNcbiAqXG4gKiBJZiBhbiBhY3Rpb24ncyBjb25maWd1cmF0aW9uIHNwZWNpZmllcyB0aGF0IGl0IGlzIGNhbmNlbGxhYmxlLCB5b3UgY2FuIGNhbmNlbCB0aGUgcmVxdWVzdCByZWxhdGVkXG4gKiB0byBhbiBpbnN0YW5jZSBvciBjb2xsZWN0aW9uIChhcyBsb25nIGFzIGl0IGlzIGEgcmVzdWx0IG9mIGEgXCJub24taW5zdGFuY2VcIiBjYWxsKTpcbiAqXG4gICBgYGBqc1xuICAgICAvLyAuLi5kZWZpbmluZyB0aGUgYEhvdGVsYCByZXNvdXJjZS4uLlxuICAgICB2YXIgSG90ZWwgPSAkcmVzb3VyY2UoJy9hcGkvaG90ZWwvOmlkJywge2lkOiAnQGlkJ30sIHtcbiAgICAgICAvLyBMZXQncyBtYWtlIHRoZSBgcXVlcnkoKWAgbWV0aG9kIGNhbmNlbGxhYmxlXG4gICAgICAgcXVlcnk6IHttZXRob2Q6ICdnZXQnLCBpc0FycmF5OiB0cnVlLCBjYW5jZWxsYWJsZTogdHJ1ZX1cbiAgICAgfSk7XG5cbiAgICAgLy8gLi4uc29tZXdoZXJlIGluIHRoZSBQbGFuVmFjYXRpb25Db250cm9sbGVyLi4uXG4gICAgIC4uLlxuICAgICB0aGlzLm9uRGVzdGluYXRpb25DaGFuZ2VkID0gZnVuY3Rpb24gb25EZXN0aW5hdGlvbkNoYW5nZWQoZGVzdGluYXRpb24pIHtcbiAgICAgICAvLyBXZSBkb24ndCBjYXJlIGFib3V0IGFueSBwZW5kaW5nIHJlcXVlc3QgZm9yIGhvdGVsc1xuICAgICAgIC8vIGluIGEgZGlmZmVyZW50IGRlc3RpbmF0aW9uIGFueSBtb3JlXG4gICAgICAgdGhpcy5hdmFpbGFibGVIb3RlbHMuJGNhbmNlbFJlcXVlc3QoKTtcblxuICAgICAgIC8vIExldCdzIHF1ZXJ5IGZvciBob3RlbHMgaW4gJzxkZXN0aW5hdGlvbj4nXG4gICAgICAgLy8gKGNhbGxzOiAvYXBpL2hvdGVsP2xvY2F0aW9uPTxkZXN0aW5hdGlvbj4pXG4gICAgICAgdGhpcy5hdmFpbGFibGVIb3RlbHMgPSBIb3RlbC5xdWVyeSh7bG9jYXRpb246IGRlc3RpbmF0aW9ufSk7XG4gICAgIH07XG4gICBgYGBcbiAqXG4gKi9cbmFuZ3VsYXIubW9kdWxlKCduZ1Jlc291cmNlJywgWyduZyddKS5cbiAgcHJvdmlkZXIoJyRyZXNvdXJjZScsIGZ1bmN0aW9uIFJlc291cmNlUHJvdmlkZXIoKSB7XG4gICAgdmFyIFBST1RPQ09MX0FORF9ET01BSU5fUkVHRVggPSAvXmh0dHBzPzpcXC9cXC9bXlxcL10qLztcblxuICAgIHZhciBwcm92aWRlciA9IHRoaXM7XG5cbiAgICAvKipcbiAgICAgKiBAbmdkb2MgcHJvcGVydHlcbiAgICAgKiBAbmFtZSAkcmVzb3VyY2VQcm92aWRlciNkZWZhdWx0c1xuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIE9iamVjdCBjb250YWluaW5nIGRlZmF1bHQgb3B0aW9ucyB1c2VkIHdoZW4gY3JlYXRpbmcgYCRyZXNvdXJjZWAgaW5zdGFuY2VzLlxuICAgICAqXG4gICAgICogVGhlIGRlZmF1bHQgdmFsdWVzIHNhdGlzZnkgYSB3aWRlIHJhbmdlIG9mIHVzZWNhc2VzLCBidXQgeW91IG1heSBjaG9vc2UgdG8gb3ZlcndyaXRlIGFueSBvZlxuICAgICAqIHRoZW0gdG8gZnVydGhlciBjdXN0b21pemUgeW91ciBpbnN0YW5jZXMuIFRoZSBhdmFpbGFibGUgcHJvcGVydGllcyBhcmU6XG4gICAgICpcbiAgICAgKiAtICoqc3RyaXBUcmFpbGluZ1NsYXNoZXMqKiDigJMgYHtib29sZWFufWAg4oCTIElmIHRydWUsIHRoZW4gdGhlIHRyYWlsaW5nIHNsYXNoZXMgZnJvbSBhbnlcbiAgICAgKiAgIGNhbGN1bGF0ZWQgVVJMIHdpbGwgYmUgc3RyaXBwZWQuPGJyIC8+XG4gICAgICogICAoRGVmYXVsdHMgdG8gdHJ1ZS4pXG4gICAgICogLSAqKmNhbmNlbGxhYmxlKiog4oCTIGB7Ym9vbGVhbn1gIOKAkyBJZiB0cnVlLCB0aGUgcmVxdWVzdCBtYWRlIGJ5IGEgXCJub24taW5zdGFuY2VcIiBjYWxsIHdpbGwgYmVcbiAgICAgKiAgIGNhbmNlbGxlZCAoaWYgbm90IGFscmVhZHkgY29tcGxldGVkKSBieSBjYWxsaW5nIGAkY2FuY2VsUmVxdWVzdCgpYCBvbiB0aGUgY2FsbCdzIHJldHVyblxuICAgICAqICAgdmFsdWUuIEZvciBtb3JlIGRldGFpbHMsIHNlZSB7QGxpbmsgbmdSZXNvdXJjZS4kcmVzb3VyY2V9LiBUaGlzIGNhbiBiZSBvdmVyd3JpdHRlbiBwZXJcbiAgICAgKiAgIHJlc291cmNlIGNsYXNzIG9yIGFjdGlvbi48YnIgLz5cbiAgICAgKiAgIChEZWZhdWx0cyB0byBmYWxzZS4pXG4gICAgICogLSAqKmFjdGlvbnMqKiAtIGB7T2JqZWN0LjxPYmplY3Q+fWAgLSBBIGhhc2ggd2l0aCBkZWZhdWx0IGFjdGlvbnMgZGVjbGFyYXRpb25zLiBBY3Rpb25zIGFyZVxuICAgICAqICAgaGlnaC1sZXZlbCBtZXRob2RzIGNvcnJlc3BvbmRpbmcgdG8gUkVTVGZ1bCBhY3Rpb25zL21ldGhvZHMgb24gcmVzb3VyY2VzLiBBbiBhY3Rpb24gbWF5XG4gICAgICogICBzcGVjaWZ5IHdoYXQgSFRUUCBtZXRob2QgdG8gdXNlLCB3aGF0IFVSTCB0byBoaXQsIGlmIHRoZSByZXR1cm4gdmFsdWUgd2lsbCBiZSBhIHNpbmdsZVxuICAgICAqICAgb2JqZWN0IG9yIGEgY29sbGVjdGlvbiAoYXJyYXkpIG9mIG9iamVjdHMgZXRjLiBGb3IgbW9yZSBkZXRhaWxzLCBzZWVcbiAgICAgKiAgIHtAbGluayBuZ1Jlc291cmNlLiRyZXNvdXJjZX0uIFRoZSBhY3Rpb25zIGNhbiBhbHNvIGJlIGVuaGFuY2VkIG9yIG92ZXJ3cml0dGVuIHBlciByZXNvdXJjZVxuICAgICAqICAgY2xhc3MuPGJyIC8+XG4gICAgICogICBUaGUgZGVmYXVsdCBhY3Rpb25zIGFyZTpcbiAgICAgKiAgIGBgYGpzXG4gICAgICogICB7XG4gICAgICogICAgIGdldDoge21ldGhvZDogJ0dFVCd9LFxuICAgICAqICAgICBzYXZlOiB7bWV0aG9kOiAnUE9TVCd9LFxuICAgICAqICAgICBxdWVyeToge21ldGhvZDogJ0dFVCcsIGlzQXJyYXk6IHRydWV9LFxuICAgICAqICAgICByZW1vdmU6IHttZXRob2Q6ICdERUxFVEUnfSxcbiAgICAgKiAgICAgZGVsZXRlOiB7bWV0aG9kOiAnREVMRVRFJ31cbiAgICAgKiAgIH1cbiAgICAgKiAgIGBgYFxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBGb3IgZXhhbXBsZSwgeW91IGNhbiBzcGVjaWZ5IGEgbmV3IGB1cGRhdGVgIGFjdGlvbiB0aGF0IHVzZXMgdGhlIGBQVVRgIEhUVFAgdmVyYjpcbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogICBhbmd1bGFyLlxuICAgICAqICAgICBtb2R1bGUoJ215QXBwJykuXG4gICAgICogICAgIGNvbmZpZyhbJ3Jlc291cmNlUHJvdmlkZXInLCBmdW5jdGlvbiAoJHJlc291cmNlUHJvdmlkZXIpIHtcbiAgICAgKiAgICAgICAkcmVzb3VyY2VQcm92aWRlci5kZWZhdWx0cy5hY3Rpb25zLnVwZGF0ZSA9IHtcbiAgICAgKiAgICAgICAgIG1ldGhvZDogJ1BVVCdcbiAgICAgKiAgICAgICB9O1xuICAgICAqICAgICB9KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIE9yIHlvdSBjYW4gZXZlbiBvdmVyd3JpdGUgdGhlIHdob2xlIGBhY3Rpb25zYCBsaXN0IGFuZCBzcGVjaWZ5IHlvdXIgb3duOlxuICAgICAqXG4gICAgICogYGBganNcbiAgICAgKiAgIGFuZ3VsYXIuXG4gICAgICogICAgIG1vZHVsZSgnbXlBcHAnKS5cbiAgICAgKiAgICAgY29uZmlnKFsncmVzb3VyY2VQcm92aWRlcicsIGZ1bmN0aW9uICgkcmVzb3VyY2VQcm92aWRlcikge1xuICAgICAqICAgICAgICRyZXNvdXJjZVByb3ZpZGVyLmRlZmF1bHRzLmFjdGlvbnMgPSB7XG4gICAgICogICAgICAgICBjcmVhdGU6IHttZXRob2Q6ICdQT1NUJ31cbiAgICAgKiAgICAgICAgIGdldDogICAge21ldGhvZDogJ0dFVCd9LFxuICAgICAqICAgICAgICAgZ2V0QWxsOiB7bWV0aG9kOiAnR0VUJywgaXNBcnJheTp0cnVlfSxcbiAgICAgKiAgICAgICAgIHVwZGF0ZToge21ldGhvZDogJ1BVVCd9LFxuICAgICAqICAgICAgICAgZGVsZXRlOiB7bWV0aG9kOiAnREVMRVRFJ31cbiAgICAgKiAgICAgICB9O1xuICAgICAqICAgICB9KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqL1xuICAgIHRoaXMuZGVmYXVsdHMgPSB7XG4gICAgICAvLyBTdHJpcCBzbGFzaGVzIGJ5IGRlZmF1bHRcbiAgICAgIHN0cmlwVHJhaWxpbmdTbGFzaGVzOiB0cnVlLFxuXG4gICAgICAvLyBNYWtlIG5vbi1pbnN0YW5jZSByZXF1ZXN0cyBjYW5jZWxsYWJsZSAodmlhIGAkY2FuY2VsUmVxdWVzdCgpYClcbiAgICAgIGNhbmNlbGxhYmxlOiBmYWxzZSxcblxuICAgICAgLy8gRGVmYXVsdCBhY3Rpb25zIGNvbmZpZ3VyYXRpb25cbiAgICAgIGFjdGlvbnM6IHtcbiAgICAgICAgJ2dldCc6IHttZXRob2Q6ICdHRVQnfSxcbiAgICAgICAgJ3NhdmUnOiB7bWV0aG9kOiAnUE9TVCd9LFxuICAgICAgICAncXVlcnknOiB7bWV0aG9kOiAnR0VUJywgaXNBcnJheTogdHJ1ZX0sXG4gICAgICAgICdyZW1vdmUnOiB7bWV0aG9kOiAnREVMRVRFJ30sXG4gICAgICAgICdkZWxldGUnOiB7bWV0aG9kOiAnREVMRVRFJ31cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy4kZ2V0ID0gWyckaHR0cCcsICckbG9nJywgJyRxJywgJyR0aW1lb3V0JywgZnVuY3Rpb24oJGh0dHAsICRsb2csICRxLCAkdGltZW91dCkge1xuXG4gICAgICB2YXIgbm9vcCA9IGFuZ3VsYXIubm9vcCxcbiAgICAgICAgZm9yRWFjaCA9IGFuZ3VsYXIuZm9yRWFjaCxcbiAgICAgICAgZXh0ZW5kID0gYW5ndWxhci5leHRlbmQsXG4gICAgICAgIGNvcHkgPSBhbmd1bGFyLmNvcHksXG4gICAgICAgIGlzRnVuY3Rpb24gPSBhbmd1bGFyLmlzRnVuY3Rpb247XG5cbiAgICAgIC8qKlxuICAgICAgICogV2UgbmVlZCBvdXIgY3VzdG9tIG1ldGhvZCBiZWNhdXNlIGVuY29kZVVSSUNvbXBvbmVudCBpcyB0b28gYWdncmVzc2l2ZSBhbmQgZG9lc24ndCBmb2xsb3dcbiAgICAgICAqIGh0dHA6Ly93d3cuaWV0Zi5vcmcvcmZjL3JmYzM5ODYudHh0IHdpdGggcmVnYXJkcyB0byB0aGUgY2hhcmFjdGVyIHNldFxuICAgICAgICogKHBjaGFyKSBhbGxvd2VkIGluIHBhdGggc2VnbWVudHM6XG4gICAgICAgKiAgICBzZWdtZW50ICAgICAgID0gKnBjaGFyXG4gICAgICAgKiAgICBwY2hhciAgICAgICAgID0gdW5yZXNlcnZlZCAvIHBjdC1lbmNvZGVkIC8gc3ViLWRlbGltcyAvIFwiOlwiIC8gXCJAXCJcbiAgICAgICAqICAgIHBjdC1lbmNvZGVkICAgPSBcIiVcIiBIRVhESUcgSEVYRElHXG4gICAgICAgKiAgICB1bnJlc2VydmVkICAgID0gQUxQSEEgLyBESUdJVCAvIFwiLVwiIC8gXCIuXCIgLyBcIl9cIiAvIFwiflwiXG4gICAgICAgKiAgICBzdWItZGVsaW1zICAgID0gXCIhXCIgLyBcIiRcIiAvIFwiJlwiIC8gXCInXCIgLyBcIihcIiAvIFwiKVwiXG4gICAgICAgKiAgICAgICAgICAgICAgICAgICAgIC8gXCIqXCIgLyBcIitcIiAvIFwiLFwiIC8gXCI7XCIgLyBcIj1cIlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBlbmNvZGVVcmlTZWdtZW50KHZhbCkge1xuICAgICAgICByZXR1cm4gZW5jb2RlVXJpUXVlcnkodmFsLCB0cnVlKS5cbiAgICAgICAgICByZXBsYWNlKC8lMjYvZ2ksICcmJykuXG4gICAgICAgICAgcmVwbGFjZSgvJTNEL2dpLCAnPScpLlxuICAgICAgICAgIHJlcGxhY2UoLyUyQi9naSwgJysnKTtcbiAgICAgIH1cblxuXG4gICAgICAvKipcbiAgICAgICAqIFRoaXMgbWV0aG9kIGlzIGludGVuZGVkIGZvciBlbmNvZGluZyAqa2V5KiBvciAqdmFsdWUqIHBhcnRzIG9mIHF1ZXJ5IGNvbXBvbmVudC4gV2UgbmVlZCBhXG4gICAgICAgKiBjdXN0b20gbWV0aG9kIGJlY2F1c2UgZW5jb2RlVVJJQ29tcG9uZW50IGlzIHRvbyBhZ2dyZXNzaXZlIGFuZCBlbmNvZGVzIHN0dWZmIHRoYXQgZG9lc24ndFxuICAgICAgICogaGF2ZSB0byBiZSBlbmNvZGVkIHBlciBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2OlxuICAgICAgICogICAgcXVlcnkgICAgICAgPSAqKCBwY2hhciAvIFwiL1wiIC8gXCI/XCIgKVxuICAgICAgICogICAgcGNoYXIgICAgICAgICA9IHVucmVzZXJ2ZWQgLyBwY3QtZW5jb2RlZCAvIHN1Yi1kZWxpbXMgLyBcIjpcIiAvIFwiQFwiXG4gICAgICAgKiAgICB1bnJlc2VydmVkICAgID0gQUxQSEEgLyBESUdJVCAvIFwiLVwiIC8gXCIuXCIgLyBcIl9cIiAvIFwiflwiXG4gICAgICAgKiAgICBwY3QtZW5jb2RlZCAgID0gXCIlXCIgSEVYRElHIEhFWERJR1xuICAgICAgICogICAgc3ViLWRlbGltcyAgICA9IFwiIVwiIC8gXCIkXCIgLyBcIiZcIiAvIFwiJ1wiIC8gXCIoXCIgLyBcIilcIlxuICAgICAgICogICAgICAgICAgICAgICAgICAgICAvIFwiKlwiIC8gXCIrXCIgLyBcIixcIiAvIFwiO1wiIC8gXCI9XCJcbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gZW5jb2RlVXJpUXVlcnkodmFsLCBwY3RFbmNvZGVTcGFjZXMpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh2YWwpLlxuICAgICAgICAgIHJlcGxhY2UoLyU0MC9naSwgJ0AnKS5cbiAgICAgICAgICByZXBsYWNlKC8lM0EvZ2ksICc6JykuXG4gICAgICAgICAgcmVwbGFjZSgvJTI0L2csICckJykuXG4gICAgICAgICAgcmVwbGFjZSgvJTJDL2dpLCAnLCcpLlxuICAgICAgICAgIHJlcGxhY2UoLyUyMC9nLCAocGN0RW5jb2RlU3BhY2VzID8gJyUyMCcgOiAnKycpKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gUm91dGUodGVtcGxhdGUsIGRlZmF1bHRzKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICAgICAgdGhpcy5kZWZhdWx0cyA9IGV4dGVuZCh7fSwgcHJvdmlkZXIuZGVmYXVsdHMsIGRlZmF1bHRzKTtcbiAgICAgICAgdGhpcy51cmxQYXJhbXMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgUm91dGUucHJvdG90eXBlID0ge1xuICAgICAgICBzZXRVcmxQYXJhbXM6IGZ1bmN0aW9uKGNvbmZpZywgcGFyYW1zLCBhY3Rpb25VcmwpIHtcbiAgICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICB1cmwgPSBhY3Rpb25VcmwgfHwgc2VsZi50ZW1wbGF0ZSxcbiAgICAgICAgICAgIHZhbCxcbiAgICAgICAgICAgIGVuY29kZWRWYWwsXG4gICAgICAgICAgICBwcm90b2NvbEFuZERvbWFpbiA9ICcnO1xuXG4gICAgICAgICAgdmFyIHVybFBhcmFtcyA9IHNlbGYudXJsUGFyYW1zID0ge307XG4gICAgICAgICAgZm9yRWFjaCh1cmwuc3BsaXQoL1xcVy8pLCBmdW5jdGlvbihwYXJhbSkge1xuICAgICAgICAgICAgaWYgKHBhcmFtID09PSAnaGFzT3duUHJvcGVydHknKSB7XG4gICAgICAgICAgICAgIHRocm93ICRyZXNvdXJjZU1pbkVycignYmFkbmFtZScsICdoYXNPd25Qcm9wZXJ0eSBpcyBub3QgYSB2YWxpZCBwYXJhbWV0ZXIgbmFtZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKG5ldyBSZWdFeHAoJ15cXFxcZCskJykudGVzdChwYXJhbSkpICYmIHBhcmFtICYmXG4gICAgICAgICAgICAgIChuZXcgUmVnRXhwKCcoXnxbXlxcXFxcXFxcXSk6JyArIHBhcmFtICsgJyhcXFxcV3wkKScpLnRlc3QodXJsKSkpIHtcbiAgICAgICAgICAgICAgdXJsUGFyYW1zW3BhcmFtXSA9IHtcbiAgICAgICAgICAgICAgICBpc1F1ZXJ5UGFyYW1WYWx1ZTogKG5ldyBSZWdFeHAoJ1xcXFw/Lio9OicgKyBwYXJhbSArICcoPzpcXFxcV3wkKScpKS50ZXN0KHVybClcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICB1cmwgPSB1cmwucmVwbGFjZSgvXFxcXDovZywgJzonKTtcbiAgICAgICAgICB1cmwgPSB1cmwucmVwbGFjZShQUk9UT0NPTF9BTkRfRE9NQUlOX1JFR0VYLCBmdW5jdGlvbihtYXRjaCkge1xuICAgICAgICAgICAgcHJvdG9jb2xBbmREb21haW4gPSBtYXRjaDtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICAgICAgICBmb3JFYWNoKHNlbGYudXJsUGFyYW1zLCBmdW5jdGlvbihwYXJhbUluZm8sIHVybFBhcmFtKSB7XG4gICAgICAgICAgICB2YWwgPSBwYXJhbXMuaGFzT3duUHJvcGVydHkodXJsUGFyYW0pID8gcGFyYW1zW3VybFBhcmFtXSA6IHNlbGYuZGVmYXVsdHNbdXJsUGFyYW1dO1xuICAgICAgICAgICAgaWYgKGFuZ3VsYXIuaXNEZWZpbmVkKHZhbCkgJiYgdmFsICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGlmIChwYXJhbUluZm8uaXNRdWVyeVBhcmFtVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBlbmNvZGVkVmFsID0gZW5jb2RlVXJpUXVlcnkodmFsLCB0cnVlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbmNvZGVkVmFsID0gZW5jb2RlVXJpU2VnbWVudCh2YWwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHVybCA9IHVybC5yZXBsYWNlKG5ldyBSZWdFeHAoJzonICsgdXJsUGFyYW0gKyAnKFxcXFxXfCQpJywgJ2cnKSwgZnVuY3Rpb24obWF0Y2gsIHAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuY29kZWRWYWwgKyBwMTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB1cmwgPSB1cmwucmVwbGFjZShuZXcgUmVnRXhwKCcoLz8pOicgKyB1cmxQYXJhbSArICcoXFxcXFd8JCknLCAnZycpLCBmdW5jdGlvbihtYXRjaCxcbiAgICAgICAgICAgICAgICAgIGxlYWRpbmdTbGFzaGVzLCB0YWlsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhaWwuY2hhckF0KDApID09PSAnLycpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0YWlsO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbGVhZGluZ1NsYXNoZXMgKyB0YWlsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBzdHJpcCB0cmFpbGluZyBzbGFzaGVzIGFuZCBzZXQgdGhlIHVybCAodW5sZXNzIHRoaXMgYmVoYXZpb3IgaXMgc3BlY2lmaWNhbGx5IGRpc2FibGVkKVxuICAgICAgICAgIGlmIChzZWxmLmRlZmF1bHRzLnN0cmlwVHJhaWxpbmdTbGFzaGVzKSB7XG4gICAgICAgICAgICB1cmwgPSB1cmwucmVwbGFjZSgvXFwvKyQvLCAnJykgfHwgJy8nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHRoZW4gcmVwbGFjZSBjb2xsYXBzZSBgLy5gIGlmIGZvdW5kIGluIHRoZSBsYXN0IFVSTCBwYXRoIHNlZ21lbnQgYmVmb3JlIHRoZSBxdWVyeVxuICAgICAgICAgIC8vIEUuZy4gYGh0dHA6Ly91cmwuY29tL2lkLi9mb3JtYXQ/cT14YCBiZWNvbWVzIGBodHRwOi8vdXJsLmNvbS9pZC5mb3JtYXQ/cT14YFxuICAgICAgICAgIHVybCA9IHVybC5yZXBsYWNlKC9cXC9cXC4oPz1cXHcrKCR8XFw/KSkvLCAnLicpO1xuICAgICAgICAgIC8vIHJlcGxhY2UgZXNjYXBlZCBgL1xcLmAgd2l0aCBgLy5gXG4gICAgICAgICAgY29uZmlnLnVybCA9IHByb3RvY29sQW5kRG9tYWluICsgdXJsLnJlcGxhY2UoL1xcL1xcXFxcXC4vLCAnLy4nKTtcblxuXG4gICAgICAgICAgLy8gc2V0IHBhcmFtcyAtIGRlbGVnYXRlIHBhcmFtIGVuY29kaW5nIHRvICRodHRwXG4gICAgICAgICAgZm9yRWFjaChwYXJhbXMsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgIGlmICghc2VsZi51cmxQYXJhbXNba2V5XSkge1xuICAgICAgICAgICAgICBjb25maWcucGFyYW1zID0gY29uZmlnLnBhcmFtcyB8fCB7fTtcbiAgICAgICAgICAgICAgY29uZmlnLnBhcmFtc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cblxuICAgICAgZnVuY3Rpb24gcmVzb3VyY2VGYWN0b3J5KHVybCwgcGFyYW1EZWZhdWx0cywgYWN0aW9ucywgb3B0aW9ucykge1xuICAgICAgICB2YXIgcm91dGUgPSBuZXcgUm91dGUodXJsLCBvcHRpb25zKTtcblxuICAgICAgICBhY3Rpb25zID0gZXh0ZW5kKHt9LCBwcm92aWRlci5kZWZhdWx0cy5hY3Rpb25zLCBhY3Rpb25zKTtcblxuICAgICAgICBmdW5jdGlvbiBleHRyYWN0UGFyYW1zKGRhdGEsIGFjdGlvblBhcmFtcykge1xuICAgICAgICAgIHZhciBpZHMgPSB7fTtcbiAgICAgICAgICBhY3Rpb25QYXJhbXMgPSBleHRlbmQoe30sIHBhcmFtRGVmYXVsdHMsIGFjdGlvblBhcmFtcyk7XG4gICAgICAgICAgZm9yRWFjaChhY3Rpb25QYXJhbXMsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkgeyB2YWx1ZSA9IHZhbHVlKGRhdGEpOyB9XG4gICAgICAgICAgICBpZHNba2V5XSA9IHZhbHVlICYmIHZhbHVlLmNoYXJBdCAmJiB2YWx1ZS5jaGFyQXQoMCkgPT09ICdAJyA/XG4gICAgICAgICAgICAgIGxvb2t1cERvdHRlZFBhdGgoZGF0YSwgdmFsdWUuc3Vic3RyKDEpKSA6IHZhbHVlO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBpZHM7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBkZWZhdWx0UmVzcG9uc2VJbnRlcmNlcHRvcihyZXNwb25zZSkge1xuICAgICAgICAgIHJldHVybiByZXNwb25zZS5yZXNvdXJjZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIFJlc291cmNlKHZhbHVlKSB7XG4gICAgICAgICAgc2hhbGxvd0NsZWFyQW5kQ29weSh2YWx1ZSB8fCB7fSwgdGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICBSZXNvdXJjZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSBleHRlbmQoe30sIHRoaXMpO1xuICAgICAgICAgIGRlbGV0ZSBkYXRhLiRwcm9taXNlO1xuICAgICAgICAgIGRlbGV0ZSBkYXRhLiRyZXNvbHZlZDtcbiAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfTtcblxuICAgICAgICBmb3JFYWNoKGFjdGlvbnMsIGZ1bmN0aW9uKGFjdGlvbiwgbmFtZSkge1xuICAgICAgICAgIHZhciBoYXNCb2R5ID0gL14oUE9TVHxQVVR8UEFUQ0gpJC9pLnRlc3QoYWN0aW9uLm1ldGhvZCk7XG4gICAgICAgICAgdmFyIG51bWVyaWNUaW1lb3V0ID0gYWN0aW9uLnRpbWVvdXQ7XG4gICAgICAgICAgdmFyIGNhbmNlbGxhYmxlID0gYW5ndWxhci5pc0RlZmluZWQoYWN0aW9uLmNhbmNlbGxhYmxlKSA/IGFjdGlvbi5jYW5jZWxsYWJsZSA6XG4gICAgICAgICAgICAgIChvcHRpb25zICYmIGFuZ3VsYXIuaXNEZWZpbmVkKG9wdGlvbnMuY2FuY2VsbGFibGUpKSA/IG9wdGlvbnMuY2FuY2VsbGFibGUgOlxuICAgICAgICAgICAgICBwcm92aWRlci5kZWZhdWx0cy5jYW5jZWxsYWJsZTtcblxuICAgICAgICAgIGlmIChudW1lcmljVGltZW91dCAmJiAhYW5ndWxhci5pc051bWJlcihudW1lcmljVGltZW91dCkpIHtcbiAgICAgICAgICAgICRsb2cuZGVidWcoJ25nUmVzb3VyY2U6XFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICcgIE9ubHkgbnVtZXJpYyB2YWx1ZXMgYXJlIGFsbG93ZWQgYXMgYHRpbWVvdXRgLlxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAnICBQcm9taXNlcyBhcmUgbm90IHN1cHBvcnRlZCBpbiAkcmVzb3VyY2UsIGJlY2F1c2UgdGhlIHNhbWUgdmFsdWUgd291bGQgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICdiZSB1c2VkIGZvciBtdWx0aXBsZSByZXF1ZXN0cy4gSWYgeW91IGFyZSBsb29raW5nIGZvciBhIHdheSB0byBjYW5jZWwgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICdyZXF1ZXN0cywgeW91IHNob3VsZCB1c2UgdGhlIGBjYW5jZWxsYWJsZWAgb3B0aW9uLicpO1xuICAgICAgICAgICAgZGVsZXRlIGFjdGlvbi50aW1lb3V0O1xuICAgICAgICAgICAgbnVtZXJpY1RpbWVvdXQgPSBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIFJlc291cmNlW25hbWVdID0gZnVuY3Rpb24oYTEsIGEyLCBhMywgYTQpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7fSwgZGF0YSwgc3VjY2VzcywgZXJyb3I7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBhNDtcbiAgICAgICAgICAgICAgICBzdWNjZXNzID0gYTM7XG4gICAgICAgICAgICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihhMikpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGExKSkge1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzID0gYTE7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gYTI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBzdWNjZXNzID0gYTI7XG4gICAgICAgICAgICAgICAgICBlcnJvciA9IGEzO1xuICAgICAgICAgICAgICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBwYXJhbXMgPSBhMTtcbiAgICAgICAgICAgICAgICAgIGRhdGEgPSBhMjtcbiAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MgPSBhMztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihhMSkpIHN1Y2Nlc3MgPSBhMTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChoYXNCb2R5KSBkYXRhID0gYTE7XG4gICAgICAgICAgICAgICAgZWxzZSBwYXJhbXMgPSBhMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAwOiBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyAkcmVzb3VyY2VNaW5FcnIoJ2JhZGFyZ3MnLFxuICAgICAgICAgICAgICAgICAgJ0V4cGVjdGVkIHVwIHRvIDQgYXJndW1lbnRzIFtwYXJhbXMsIGRhdGEsIHN1Y2Nlc3MsIGVycm9yXSwgZ290IHswfSBhcmd1bWVudHMnLFxuICAgICAgICAgICAgICAgICAgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpc0luc3RhbmNlQ2FsbCA9IHRoaXMgaW5zdGFuY2VvZiBSZXNvdXJjZTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGlzSW5zdGFuY2VDYWxsID8gZGF0YSA6IChhY3Rpb24uaXNBcnJheSA/IFtdIDogbmV3IFJlc291cmNlKGRhdGEpKTtcbiAgICAgICAgICAgIHZhciBodHRwQ29uZmlnID0ge307XG4gICAgICAgICAgICB2YXIgcmVzcG9uc2VJbnRlcmNlcHRvciA9IGFjdGlvbi5pbnRlcmNlcHRvciAmJiBhY3Rpb24uaW50ZXJjZXB0b3IucmVzcG9uc2UgfHxcbiAgICAgICAgICAgICAgZGVmYXVsdFJlc3BvbnNlSW50ZXJjZXB0b3I7XG4gICAgICAgICAgICB2YXIgcmVzcG9uc2VFcnJvckludGVyY2VwdG9yID0gYWN0aW9uLmludGVyY2VwdG9yICYmIGFjdGlvbi5pbnRlcmNlcHRvci5yZXNwb25zZUVycm9yIHx8XG4gICAgICAgICAgICAgIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHZhciB0aW1lb3V0RGVmZXJyZWQ7XG4gICAgICAgICAgICB2YXIgbnVtZXJpY1RpbWVvdXRQcm9taXNlO1xuXG4gICAgICAgICAgICBmb3JFYWNoKGFjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICBodHRwQ29uZmlnW2tleV0gPSBjb3B5KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3BhcmFtcyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnaXNBcnJheSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnaW50ZXJjZXB0b3InOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2NhbmNlbGxhYmxlJzpcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKCFpc0luc3RhbmNlQ2FsbCAmJiBjYW5jZWxsYWJsZSkge1xuICAgICAgICAgICAgICB0aW1lb3V0RGVmZXJyZWQgPSAkcS5kZWZlcigpO1xuICAgICAgICAgICAgICBodHRwQ29uZmlnLnRpbWVvdXQgPSB0aW1lb3V0RGVmZXJyZWQucHJvbWlzZTtcblxuICAgICAgICAgICAgICBpZiAobnVtZXJpY1RpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICBudW1lcmljVGltZW91dFByb21pc2UgPSAkdGltZW91dCh0aW1lb3V0RGVmZXJyZWQucmVzb2x2ZSwgbnVtZXJpY1RpbWVvdXQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChoYXNCb2R5KSBodHRwQ29uZmlnLmRhdGEgPSBkYXRhO1xuICAgICAgICAgICAgcm91dGUuc2V0VXJsUGFyYW1zKGh0dHBDb25maWcsXG4gICAgICAgICAgICAgIGV4dGVuZCh7fSwgZXh0cmFjdFBhcmFtcyhkYXRhLCBhY3Rpb24ucGFyYW1zIHx8IHt9KSwgcGFyYW1zKSxcbiAgICAgICAgICAgICAgYWN0aW9uLnVybCk7XG5cbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gJGh0dHAoaHR0cENvbmZpZykudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgICB2YXIgZGF0YSA9IHJlc3BvbnNlLmRhdGE7XG5cbiAgICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIGNvbnZlcnQgYWN0aW9uLmlzQXJyYXkgdG8gYm9vbGVhbiBpbiBjYXNlIGl0IGlzIHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIGlmIChhbmd1bGFyLmlzQXJyYXkoZGF0YSkgIT09ICghIWFjdGlvbi5pc0FycmF5KSkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgJHJlc291cmNlTWluRXJyKCdiYWRjZmcnLFxuICAgICAgICAgICAgICAgICAgICAgICdFcnJvciBpbiByZXNvdXJjZSBjb25maWd1cmF0aW9uIGZvciBhY3Rpb24gYHswfWAuIEV4cGVjdGVkIHJlc3BvbnNlIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAgICdjb250YWluIGFuIHsxfSBidXQgZ290IGFuIHsyfSAoUmVxdWVzdDogezN9IHs0fSknLCBuYW1lLCBhY3Rpb24uaXNBcnJheSA/ICdhcnJheScgOiAnb2JqZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgYW5ndWxhci5pc0FycmF5KGRhdGEpID8gJ2FycmF5JyA6ICdvYmplY3QnLCBodHRwQ29uZmlnLm1ldGhvZCwgaHR0cENvbmZpZy51cmwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYWN0aW9uLmlzQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgICBmb3JFYWNoKGRhdGEsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnB1c2gobmV3IFJlc291cmNlKGl0ZW0pKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBWYWxpZCBKU09OIHZhbHVlcyBtYXkgYmUgc3RyaW5nIGxpdGVyYWxzLCBhbmQgdGhlc2Ugc2hvdWxkIG5vdCBiZSBjb252ZXJ0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAvLyBpbnRvIG9iamVjdHMuIFRoZXNlIGl0ZW1zIHdpbGwgbm90IGhhdmUgYWNjZXNzIHRvIHRoZSBSZXNvdXJjZSBwcm90b3R5cGVcbiAgICAgICAgICAgICAgICAgICAgICAvLyBtZXRob2RzLCBidXQgdW5mb3J0dW5hdGVseSB0aGVyZVxuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IHZhbHVlLiRwcm9taXNlOyAgICAgLy8gU2F2ZSB0aGUgcHJvbWlzZVxuICAgICAgICAgICAgICAgICAgc2hhbGxvd0NsZWFyQW5kQ29weShkYXRhLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICB2YWx1ZS4kcHJvbWlzZSA9IHByb21pc2U7ICAgICAgICAgLy8gUmVzdG9yZSB0aGUgcHJvbWlzZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXNwb25zZS5yZXNvdXJjZSA9IHZhbHVlO1xuXG4gICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgIChlcnJvciB8fCBub29wKShyZXNwb25zZSk7XG4gICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QocmVzcG9uc2UpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHByb21pc2VbJ2ZpbmFsbHknXShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFsdWUuJHJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgaWYgKCFpc0luc3RhbmNlQ2FsbCAmJiBjYW5jZWxsYWJsZSkge1xuICAgICAgICAgICAgICAgIHZhbHVlLiRjYW5jZWxSZXF1ZXN0ID0gYW5ndWxhci5ub29wO1xuICAgICAgICAgICAgICAgICR0aW1lb3V0LmNhbmNlbChudW1lcmljVGltZW91dFByb21pc2UpO1xuICAgICAgICAgICAgICAgIHRpbWVvdXREZWZlcnJlZCA9IG51bWVyaWNUaW1lb3V0UHJvbWlzZSA9IGh0dHBDb25maWcudGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKFxuICAgICAgICAgICAgICBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHJlc3BvbnNlSW50ZXJjZXB0b3IocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIChzdWNjZXNzIHx8IG5vb3ApKHZhbHVlLCByZXNwb25zZS5oZWFkZXJzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHJlc3BvbnNlRXJyb3JJbnRlcmNlcHRvcik7XG5cbiAgICAgICAgICAgIGlmICghaXNJbnN0YW5jZUNhbGwpIHtcbiAgICAgICAgICAgICAgLy8gd2UgYXJlIGNyZWF0aW5nIGluc3RhbmNlIC8gY29sbGVjdGlvblxuICAgICAgICAgICAgICAvLyAtIHNldCB0aGUgaW5pdGlhbCBwcm9taXNlXG4gICAgICAgICAgICAgIC8vIC0gcmV0dXJuIHRoZSBpbnN0YW5jZSAvIGNvbGxlY3Rpb25cbiAgICAgICAgICAgICAgdmFsdWUuJHByb21pc2UgPSBwcm9taXNlO1xuICAgICAgICAgICAgICB2YWx1ZS4kcmVzb2x2ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgaWYgKGNhbmNlbGxhYmxlKSB2YWx1ZS4kY2FuY2VsUmVxdWVzdCA9IHRpbWVvdXREZWZlcnJlZC5yZXNvbHZlO1xuXG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaW5zdGFuY2UgY2FsbFxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgICAgfTtcblxuXG4gICAgICAgICAgUmVzb3VyY2UucHJvdG90eXBlWyckJyArIG5hbWVdID0gZnVuY3Rpb24ocGFyYW1zLCBzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24ocGFyYW1zKSkge1xuICAgICAgICAgICAgICBlcnJvciA9IHN1Y2Nlc3M7IHN1Y2Nlc3MgPSBwYXJhbXM7IHBhcmFtcyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFJlc291cmNlW25hbWVdLmNhbGwodGhpcywgcGFyYW1zLCB0aGlzLCBzdWNjZXNzLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LiRwcm9taXNlIHx8IHJlc3VsdDtcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcblxuICAgICAgICBSZXNvdXJjZS5iaW5kID0gZnVuY3Rpb24oYWRkaXRpb25hbFBhcmFtRGVmYXVsdHMpIHtcbiAgICAgICAgICByZXR1cm4gcmVzb3VyY2VGYWN0b3J5KHVybCwgZXh0ZW5kKHt9LCBwYXJhbURlZmF1bHRzLCBhZGRpdGlvbmFsUGFyYW1EZWZhdWx0cyksIGFjdGlvbnMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBSZXNvdXJjZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc291cmNlRmFjdG9yeTtcbiAgICB9XTtcbiAgfSk7XG5cblxufSkod2luZG93LCB3aW5kb3cuYW5ndWxhcik7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYW5ndWxhci1yZXNvdXJjZS9hbmd1bGFyLXJlc291cmNlLmpzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 4 */
/***/ function(module, exports) {

	eval("/* ng-infinite-scroll - v1.3.0 - 2016-06-30 */\nangular.module('infinite-scroll', []).value('THROTTLE_MILLISECONDS', null).directive('infiniteScroll', [\n  '$rootScope', '$window', '$interval', 'THROTTLE_MILLISECONDS', function($rootScope, $window, $interval, THROTTLE_MILLISECONDS) {\n    return {\n      scope: {\n        infiniteScroll: '&',\n        infiniteScrollContainer: '=',\n        infiniteScrollDistance: '=',\n        infiniteScrollDisabled: '=',\n        infiniteScrollUseDocumentBottom: '=',\n        infiniteScrollListenForEvent: '@'\n      },\n      link: function(scope, elem, attrs) {\n        var changeContainer, checkInterval, checkWhenEnabled, container, handleInfiniteScrollContainer, handleInfiniteScrollDisabled, handleInfiniteScrollDistance, handleInfiniteScrollUseDocumentBottom, handler, height, immediateCheck, offsetTop, pageYOffset, scrollDistance, scrollEnabled, throttle, unregisterEventListener, useDocumentBottom, windowElement;\n        windowElement = angular.element($window);\n        scrollDistance = null;\n        scrollEnabled = null;\n        checkWhenEnabled = null;\n        container = null;\n        immediateCheck = true;\n        useDocumentBottom = false;\n        unregisterEventListener = null;\n        checkInterval = false;\n        height = function(elem) {\n          elem = elem[0] || elem;\n          if (isNaN(elem.offsetHeight)) {\n            return elem.document.documentElement.clientHeight;\n          } else {\n            return elem.offsetHeight;\n          }\n        };\n        offsetTop = function(elem) {\n          if (!elem[0].getBoundingClientRect || elem.css('none')) {\n            return;\n          }\n          return elem[0].getBoundingClientRect().top + pageYOffset(elem);\n        };\n        pageYOffset = function(elem) {\n          elem = elem[0] || elem;\n          if (isNaN(window.pageYOffset)) {\n            return elem.document.documentElement.scrollTop;\n          } else {\n            return elem.ownerDocument.defaultView.pageYOffset;\n          }\n        };\n        handler = function() {\n          var containerBottom, containerTopOffset, elementBottom, remaining, shouldScroll;\n          if (container === windowElement) {\n            containerBottom = height(container) + pageYOffset(container[0].document.documentElement);\n            elementBottom = offsetTop(elem) + height(elem);\n          } else {\n            containerBottom = height(container);\n            containerTopOffset = 0;\n            if (offsetTop(container) !== void 0) {\n              containerTopOffset = offsetTop(container);\n            }\n            elementBottom = offsetTop(elem) - containerTopOffset + height(elem);\n          }\n          if (useDocumentBottom) {\n            elementBottom = height((elem[0].ownerDocument || elem[0].document).documentElement);\n          }\n          remaining = elementBottom - containerBottom;\n          shouldScroll = remaining <= height(container) * scrollDistance + 1;\n          if (shouldScroll) {\n            checkWhenEnabled = true;\n            if (scrollEnabled) {\n              if (scope.$$phase || $rootScope.$$phase) {\n                return scope.infiniteScroll();\n              } else {\n                return scope.$apply(scope.infiniteScroll);\n              }\n            }\n          } else {\n            if (checkInterval) {\n              $interval.cancel(checkInterval);\n            }\n            return checkWhenEnabled = false;\n          }\n        };\n        throttle = function(func, wait) {\n          var later, previous, timeout;\n          timeout = null;\n          previous = 0;\n          later = function() {\n            previous = new Date().getTime();\n            $interval.cancel(timeout);\n            timeout = null;\n            return func.call();\n          };\n          return function() {\n            var now, remaining;\n            now = new Date().getTime();\n            remaining = wait - (now - previous);\n            if (remaining <= 0) {\n              $interval.cancel(timeout);\n              timeout = null;\n              previous = now;\n              return func.call();\n            } else {\n              if (!timeout) {\n                return timeout = $interval(later, remaining, 1);\n              }\n            }\n          };\n        };\n        if (THROTTLE_MILLISECONDS != null) {\n          handler = throttle(handler, THROTTLE_MILLISECONDS);\n        }\n        scope.$on('$destroy', function() {\n          container.unbind('scroll', handler);\n          if (unregisterEventListener != null) {\n            unregisterEventListener();\n            unregisterEventListener = null;\n          }\n          if (checkInterval) {\n            return $interval.cancel(checkInterval);\n          }\n        });\n        handleInfiniteScrollDistance = function(v) {\n          return scrollDistance = parseFloat(v) || 0;\n        };\n        scope.$watch('infiniteScrollDistance', handleInfiniteScrollDistance);\n        handleInfiniteScrollDistance(scope.infiniteScrollDistance);\n        handleInfiniteScrollDisabled = function(v) {\n          scrollEnabled = !v;\n          if (scrollEnabled && checkWhenEnabled) {\n            checkWhenEnabled = false;\n            return handler();\n          }\n        };\n        scope.$watch('infiniteScrollDisabled', handleInfiniteScrollDisabled);\n        handleInfiniteScrollDisabled(scope.infiniteScrollDisabled);\n        handleInfiniteScrollUseDocumentBottom = function(v) {\n          return useDocumentBottom = v;\n        };\n        scope.$watch('infiniteScrollUseDocumentBottom', handleInfiniteScrollUseDocumentBottom);\n        handleInfiniteScrollUseDocumentBottom(scope.infiniteScrollUseDocumentBottom);\n        changeContainer = function(newContainer) {\n          if (container != null) {\n            container.unbind('scroll', handler);\n          }\n          container = newContainer;\n          if (newContainer != null) {\n            return container.bind('scroll', handler);\n          }\n        };\n        changeContainer(windowElement);\n        if (scope.infiniteScrollListenForEvent) {\n          unregisterEventListener = $rootScope.$on(scope.infiniteScrollListenForEvent, handler);\n        }\n        handleInfiniteScrollContainer = function(newContainer) {\n          if ((newContainer == null) || newContainer.length === 0) {\n            return;\n          }\n          if (newContainer.nodeType && newContainer.nodeType === 1) {\n            newContainer = angular.element(newContainer);\n          } else if (typeof newContainer.append === 'function') {\n            newContainer = angular.element(newContainer[newContainer.length - 1]);\n          } else if (typeof newContainer === 'string') {\n            newContainer = angular.element(document.querySelector(newContainer));\n          }\n          if (newContainer != null) {\n            return changeContainer(newContainer);\n          } else {\n            throw new Error(\"invalid infinite-scroll-container attribute.\");\n          }\n        };\n        scope.$watch('infiniteScrollContainer', handleInfiniteScrollContainer);\n        handleInfiniteScrollContainer(scope.infiniteScrollContainer || []);\n        if (attrs.infiniteScrollParent != null) {\n          changeContainer(angular.element(elem.parent()));\n        }\n        if (attrs.infiniteScrollImmediateCheck != null) {\n          immediateCheck = scope.$eval(attrs.infiniteScrollImmediateCheck);\n        }\n        return checkInterval = $interval((function() {\n          if (immediateCheck) {\n            handler();\n          }\n          return $interval.cancel(checkInterval);\n        }));\n      }\n    };\n  }\n]);\n\nif (typeof module !== \"undefined\" && typeof exports !== \"undefined\" && module.exports === exports) {\n  module.exports = 'infinite-scroll';\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L25nLWluZmluaXRlLXNjcm9sbC9idWlsZC9uZy1pbmZpbml0ZS1zY3JvbGwuanM/NjQxOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiI0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogbmctaW5maW5pdGUtc2Nyb2xsIC0gdjEuMy4wIC0gMjAxNi0wNi0zMCAqL1xuYW5ndWxhci5tb2R1bGUoJ2luZmluaXRlLXNjcm9sbCcsIFtdKS52YWx1ZSgnVEhST1RUTEVfTUlMTElTRUNPTkRTJywgbnVsbCkuZGlyZWN0aXZlKCdpbmZpbml0ZVNjcm9sbCcsIFtcbiAgJyRyb290U2NvcGUnLCAnJHdpbmRvdycsICckaW50ZXJ2YWwnLCAnVEhST1RUTEVfTUlMTElTRUNPTkRTJywgZnVuY3Rpb24oJHJvb3RTY29wZSwgJHdpbmRvdywgJGludGVydmFsLCBUSFJPVFRMRV9NSUxMSVNFQ09ORFMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2NvcGU6IHtcbiAgICAgICAgaW5maW5pdGVTY3JvbGw6ICcmJyxcbiAgICAgICAgaW5maW5pdGVTY3JvbGxDb250YWluZXI6ICc9JyxcbiAgICAgICAgaW5maW5pdGVTY3JvbGxEaXN0YW5jZTogJz0nLFxuICAgICAgICBpbmZpbml0ZVNjcm9sbERpc2FibGVkOiAnPScsXG4gICAgICAgIGluZmluaXRlU2Nyb2xsVXNlRG9jdW1lbnRCb3R0b206ICc9JyxcbiAgICAgICAgaW5maW5pdGVTY3JvbGxMaXN0ZW5Gb3JFdmVudDogJ0AnXG4gICAgICB9LFxuICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW0sIGF0dHJzKSB7XG4gICAgICAgIHZhciBjaGFuZ2VDb250YWluZXIsIGNoZWNrSW50ZXJ2YWwsIGNoZWNrV2hlbkVuYWJsZWQsIGNvbnRhaW5lciwgaGFuZGxlSW5maW5pdGVTY3JvbGxDb250YWluZXIsIGhhbmRsZUluZmluaXRlU2Nyb2xsRGlzYWJsZWQsIGhhbmRsZUluZmluaXRlU2Nyb2xsRGlzdGFuY2UsIGhhbmRsZUluZmluaXRlU2Nyb2xsVXNlRG9jdW1lbnRCb3R0b20sIGhhbmRsZXIsIGhlaWdodCwgaW1tZWRpYXRlQ2hlY2ssIG9mZnNldFRvcCwgcGFnZVlPZmZzZXQsIHNjcm9sbERpc3RhbmNlLCBzY3JvbGxFbmFibGVkLCB0aHJvdHRsZSwgdW5yZWdpc3RlckV2ZW50TGlzdGVuZXIsIHVzZURvY3VtZW50Qm90dG9tLCB3aW5kb3dFbGVtZW50O1xuICAgICAgICB3aW5kb3dFbGVtZW50ID0gYW5ndWxhci5lbGVtZW50KCR3aW5kb3cpO1xuICAgICAgICBzY3JvbGxEaXN0YW5jZSA9IG51bGw7XG4gICAgICAgIHNjcm9sbEVuYWJsZWQgPSBudWxsO1xuICAgICAgICBjaGVja1doZW5FbmFibGVkID0gbnVsbDtcbiAgICAgICAgY29udGFpbmVyID0gbnVsbDtcbiAgICAgICAgaW1tZWRpYXRlQ2hlY2sgPSB0cnVlO1xuICAgICAgICB1c2VEb2N1bWVudEJvdHRvbSA9IGZhbHNlO1xuICAgICAgICB1bnJlZ2lzdGVyRXZlbnRMaXN0ZW5lciA9IG51bGw7XG4gICAgICAgIGNoZWNrSW50ZXJ2YWwgPSBmYWxzZTtcbiAgICAgICAgaGVpZ2h0ID0gZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICAgIGVsZW0gPSBlbGVtWzBdIHx8IGVsZW07XG4gICAgICAgICAgaWYgKGlzTmFOKGVsZW0ub2Zmc2V0SGVpZ2h0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW0uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW0ub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgb2Zmc2V0VG9wID0gZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICAgIGlmICghZWxlbVswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QgfHwgZWxlbS5jc3MoJ25vbmUnKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZWxlbVswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgKyBwYWdlWU9mZnNldChlbGVtKTtcbiAgICAgICAgfTtcbiAgICAgICAgcGFnZVlPZmZzZXQgPSBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgICAgZWxlbSA9IGVsZW1bMF0gfHwgZWxlbTtcbiAgICAgICAgICBpZiAoaXNOYU4od2luZG93LnBhZ2VZT2Zmc2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW0uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5wYWdlWU9mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGhhbmRsZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgY29udGFpbmVyQm90dG9tLCBjb250YWluZXJUb3BPZmZzZXQsIGVsZW1lbnRCb3R0b20sIHJlbWFpbmluZywgc2hvdWxkU2Nyb2xsO1xuICAgICAgICAgIGlmIChjb250YWluZXIgPT09IHdpbmRvd0VsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lckJvdHRvbSA9IGhlaWdodChjb250YWluZXIpICsgcGFnZVlPZmZzZXQoY29udGFpbmVyWzBdLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCk7XG4gICAgICAgICAgICBlbGVtZW50Qm90dG9tID0gb2Zmc2V0VG9wKGVsZW0pICsgaGVpZ2h0KGVsZW0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250YWluZXJCb3R0b20gPSBoZWlnaHQoY29udGFpbmVyKTtcbiAgICAgICAgICAgIGNvbnRhaW5lclRvcE9mZnNldCA9IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0VG9wKGNvbnRhaW5lcikgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBjb250YWluZXJUb3BPZmZzZXQgPSBvZmZzZXRUb3AoY29udGFpbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsZW1lbnRCb3R0b20gPSBvZmZzZXRUb3AoZWxlbSkgLSBjb250YWluZXJUb3BPZmZzZXQgKyBoZWlnaHQoZWxlbSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh1c2VEb2N1bWVudEJvdHRvbSkge1xuICAgICAgICAgICAgZWxlbWVudEJvdHRvbSA9IGhlaWdodCgoZWxlbVswXS5vd25lckRvY3VtZW50IHx8IGVsZW1bMF0uZG9jdW1lbnQpLmRvY3VtZW50RWxlbWVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlbWFpbmluZyA9IGVsZW1lbnRCb3R0b20gLSBjb250YWluZXJCb3R0b207XG4gICAgICAgICAgc2hvdWxkU2Nyb2xsID0gcmVtYWluaW5nIDw9IGhlaWdodChjb250YWluZXIpICogc2Nyb2xsRGlzdGFuY2UgKyAxO1xuICAgICAgICAgIGlmIChzaG91bGRTY3JvbGwpIHtcbiAgICAgICAgICAgIGNoZWNrV2hlbkVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHNjcm9sbEVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgaWYgKHNjb3BlLiQkcGhhc2UgfHwgJHJvb3RTY29wZS4kJHBoYXNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjb3BlLmluZmluaXRlU2Nyb2xsKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjb3BlLiRhcHBseShzY29wZS5pbmZpbml0ZVNjcm9sbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNoZWNrSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgICAgJGludGVydmFsLmNhbmNlbChjaGVja0ludGVydmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjaGVja1doZW5FbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aHJvdHRsZSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQpIHtcbiAgICAgICAgICB2YXIgbGF0ZXIsIHByZXZpb3VzLCB0aW1lb3V0O1xuICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgIHByZXZpb3VzID0gMDtcbiAgICAgICAgICBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcHJldmlvdXMgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgICRpbnRlcnZhbC5jYW5jZWwodGltZW91dCk7XG4gICAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBmdW5jLmNhbGwoKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBub3csIHJlbWFpbmluZztcbiAgICAgICAgICAgIG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XG4gICAgICAgICAgICBpZiAocmVtYWluaW5nIDw9IDApIHtcbiAgICAgICAgICAgICAgJGludGVydmFsLmNhbmNlbCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICAgIHByZXZpb3VzID0gbm93O1xuICAgICAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoIXRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGltZW91dCA9ICRpbnRlcnZhbChsYXRlciwgcmVtYWluaW5nLCAxKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIGlmIChUSFJPVFRMRV9NSUxMSVNFQ09ORFMgIT0gbnVsbCkge1xuICAgICAgICAgIGhhbmRsZXIgPSB0aHJvdHRsZShoYW5kbGVyLCBUSFJPVFRMRV9NSUxMSVNFQ09ORFMpO1xuICAgICAgICB9XG4gICAgICAgIHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBjb250YWluZXIudW5iaW5kKCdzY3JvbGwnLCBoYW5kbGVyKTtcbiAgICAgICAgICBpZiAodW5yZWdpc3RlckV2ZW50TGlzdGVuZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgdW5yZWdpc3RlckV2ZW50TGlzdGVuZXIoKTtcbiAgICAgICAgICAgIHVucmVnaXN0ZXJFdmVudExpc3RlbmVyID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNoZWNrSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiAkaW50ZXJ2YWwuY2FuY2VsKGNoZWNrSW50ZXJ2YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGhhbmRsZUluZmluaXRlU2Nyb2xsRGlzdGFuY2UgPSBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIHNjcm9sbERpc3RhbmNlID0gcGFyc2VGbG9hdCh2KSB8fCAwO1xuICAgICAgICB9O1xuICAgICAgICBzY29wZS4kd2F0Y2goJ2luZmluaXRlU2Nyb2xsRGlzdGFuY2UnLCBoYW5kbGVJbmZpbml0ZVNjcm9sbERpc3RhbmNlKTtcbiAgICAgICAgaGFuZGxlSW5maW5pdGVTY3JvbGxEaXN0YW5jZShzY29wZS5pbmZpbml0ZVNjcm9sbERpc3RhbmNlKTtcbiAgICAgICAgaGFuZGxlSW5maW5pdGVTY3JvbGxEaXNhYmxlZCA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICBzY3JvbGxFbmFibGVkID0gIXY7XG4gICAgICAgICAgaWYgKHNjcm9sbEVuYWJsZWQgJiYgY2hlY2tXaGVuRW5hYmxlZCkge1xuICAgICAgICAgICAgY2hlY2tXaGVuRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHNjb3BlLiR3YXRjaCgnaW5maW5pdGVTY3JvbGxEaXNhYmxlZCcsIGhhbmRsZUluZmluaXRlU2Nyb2xsRGlzYWJsZWQpO1xuICAgICAgICBoYW5kbGVJbmZpbml0ZVNjcm9sbERpc2FibGVkKHNjb3BlLmluZmluaXRlU2Nyb2xsRGlzYWJsZWQpO1xuICAgICAgICBoYW5kbGVJbmZpbml0ZVNjcm9sbFVzZURvY3VtZW50Qm90dG9tID0gZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiB1c2VEb2N1bWVudEJvdHRvbSA9IHY7XG4gICAgICAgIH07XG4gICAgICAgIHNjb3BlLiR3YXRjaCgnaW5maW5pdGVTY3JvbGxVc2VEb2N1bWVudEJvdHRvbScsIGhhbmRsZUluZmluaXRlU2Nyb2xsVXNlRG9jdW1lbnRCb3R0b20pO1xuICAgICAgICBoYW5kbGVJbmZpbml0ZVNjcm9sbFVzZURvY3VtZW50Qm90dG9tKHNjb3BlLmluZmluaXRlU2Nyb2xsVXNlRG9jdW1lbnRCb3R0b20pO1xuICAgICAgICBjaGFuZ2VDb250YWluZXIgPSBmdW5jdGlvbihuZXdDb250YWluZXIpIHtcbiAgICAgICAgICBpZiAoY29udGFpbmVyICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci51bmJpbmQoJ3Njcm9sbCcsIGhhbmRsZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250YWluZXIgPSBuZXdDb250YWluZXI7XG4gICAgICAgICAgaWYgKG5ld0NvbnRhaW5lciAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGFpbmVyLmJpbmQoJ3Njcm9sbCcsIGhhbmRsZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY2hhbmdlQ29udGFpbmVyKHdpbmRvd0VsZW1lbnQpO1xuICAgICAgICBpZiAoc2NvcGUuaW5maW5pdGVTY3JvbGxMaXN0ZW5Gb3JFdmVudCkge1xuICAgICAgICAgIHVucmVnaXN0ZXJFdmVudExpc3RlbmVyID0gJHJvb3RTY29wZS4kb24oc2NvcGUuaW5maW5pdGVTY3JvbGxMaXN0ZW5Gb3JFdmVudCwgaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlSW5maW5pdGVTY3JvbGxDb250YWluZXIgPSBmdW5jdGlvbihuZXdDb250YWluZXIpIHtcbiAgICAgICAgICBpZiAoKG5ld0NvbnRhaW5lciA9PSBudWxsKSB8fCBuZXdDb250YWluZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChuZXdDb250YWluZXIubm9kZVR5cGUgJiYgbmV3Q29udGFpbmVyLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICBuZXdDb250YWluZXIgPSBhbmd1bGFyLmVsZW1lbnQobmV3Q29udGFpbmVyKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBuZXdDb250YWluZXIuYXBwZW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBuZXdDb250YWluZXIgPSBhbmd1bGFyLmVsZW1lbnQobmV3Q29udGFpbmVyW25ld0NvbnRhaW5lci5sZW5ndGggLSAxXSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbmV3Q29udGFpbmVyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgbmV3Q29udGFpbmVyID0gYW5ndWxhci5lbGVtZW50KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IobmV3Q29udGFpbmVyKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChuZXdDb250YWluZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGNoYW5nZUNvbnRhaW5lcihuZXdDb250YWluZXIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGluZmluaXRlLXNjcm9sbC1jb250YWluZXIgYXR0cmlidXRlLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHNjb3BlLiR3YXRjaCgnaW5maW5pdGVTY3JvbGxDb250YWluZXInLCBoYW5kbGVJbmZpbml0ZVNjcm9sbENvbnRhaW5lcik7XG4gICAgICAgIGhhbmRsZUluZmluaXRlU2Nyb2xsQ29udGFpbmVyKHNjb3BlLmluZmluaXRlU2Nyb2xsQ29udGFpbmVyIHx8IFtdKTtcbiAgICAgICAgaWYgKGF0dHJzLmluZmluaXRlU2Nyb2xsUGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICBjaGFuZ2VDb250YWluZXIoYW5ndWxhci5lbGVtZW50KGVsZW0ucGFyZW50KCkpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0cnMuaW5maW5pdGVTY3JvbGxJbW1lZGlhdGVDaGVjayAhPSBudWxsKSB7XG4gICAgICAgICAgaW1tZWRpYXRlQ2hlY2sgPSBzY29wZS4kZXZhbChhdHRycy5pbmZpbml0ZVNjcm9sbEltbWVkaWF0ZUNoZWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hlY2tJbnRlcnZhbCA9ICRpbnRlcnZhbCgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKGltbWVkaWF0ZUNoZWNrKSB7XG4gICAgICAgICAgICBoYW5kbGVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAkaW50ZXJ2YWwuY2FuY2VsKGNoZWNrSW50ZXJ2YWwpO1xuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXSk7XG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBleHBvcnRzICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzID09PSBleHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gJ2luZmluaXRlLXNjcm9sbCc7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbmctaW5maW5pdGUtc2Nyb2xsL2J1aWxkL25nLWluZmluaXRlLXNjcm9sbC5qc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Copyright (c) 2011-2014 Felix Gnass\n * Licensed under the MIT license\n * http://spin.js.org/\n *\n * Example:\n    var opts = {\n      lines: 12             // The number of lines to draw\n    , length: 7             // The length of each line\n    , width: 5              // The line thickness\n    , radius: 10            // The radius of the inner circle\n    , scale: 1.0            // Scales overall size of the spinner\n    , corners: 1            // Roundness (0..1)\n    , color: '#000'         // #rgb or #rrggbb\n    , opacity: 1/4          // Opacity of the lines\n    , rotate: 0             // Rotation offset\n    , direction: 1          // 1: clockwise, -1: counterclockwise\n    , speed: 1              // Rounds per second\n    , trail: 100            // Afterglow percentage\n    , fps: 20               // Frames per second when using setTimeout()\n    , zIndex: 2e9           // Use a high z-index by default\n    , className: 'spinner'  // CSS class to assign to the element\n    , top: '50%'            // center vertically\n    , left: '50%'           // center horizontally\n    , shadow: false         // Whether to render a shadow\n    , hwaccel: false        // Whether to use hardware acceleration (might be buggy)\n    , position: 'absolute'  // Element positioning\n    }\n    var target = document.getElementById('foo')\n    var spinner = new Spinner(opts).spin(target)\n */\n;(function (root, factory) {\n\n  /* CommonJS */\n  if (typeof module == 'object' && module.exports) module.exports = factory()\n\n  /* AMD module */\n  else if (true) !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n\n  /* Browser global */\n  else root.Spinner = factory()\n}(this, function () {\n  \"use strict\"\n\n  var prefixes = ['webkit', 'Moz', 'ms', 'O'] /* Vendor prefixes */\n    , animations = {} /* Animation rules keyed by their name */\n    , useCssAnimations /* Whether to use CSS animations or setTimeout */\n    , sheet /* A stylesheet to hold the @keyframe or VML rules. */\n\n  /**\n   * Utility function to create elements. If no tag name is given,\n   * a DIV is created. Optionally properties can be passed.\n   */\n  function createEl (tag, prop) {\n    var el = document.createElement(tag || 'div')\n      , n\n\n    for (n in prop) el[n] = prop[n]\n    return el\n  }\n\n  /**\n   * Appends children and returns the parent.\n   */\n  function ins (parent /* child1, child2, ...*/) {\n    for (var i = 1, n = arguments.length; i < n; i++) {\n      parent.appendChild(arguments[i])\n    }\n\n    return parent\n  }\n\n  /**\n   * Creates an opacity keyframe animation rule and returns its name.\n   * Since most mobile Webkits have timing issues with animation-delay,\n   * we create separate rules for each line/segment.\n   */\n  function addAnimation (alpha, trail, i, lines) {\n    var name = ['opacity', trail, ~~(alpha * 100), i, lines].join('-')\n      , start = 0.01 + i/lines * 100\n      , z = Math.max(1 - (1-alpha) / trail * (100-start), alpha)\n      , prefix = useCssAnimations.substring(0, useCssAnimations.indexOf('Animation')).toLowerCase()\n      , pre = prefix && '-' + prefix + '-' || ''\n\n    if (!animations[name]) {\n      sheet.insertRule(\n        '@' + pre + 'keyframes ' + name + '{' +\n        '0%{opacity:' + z + '}' +\n        start + '%{opacity:' + alpha + '}' +\n        (start+0.01) + '%{opacity:1}' +\n        (start+trail) % 100 + '%{opacity:' + alpha + '}' +\n        '100%{opacity:' + z + '}' +\n        '}', sheet.cssRules.length)\n\n      animations[name] = 1\n    }\n\n    return name\n  }\n\n  /**\n   * Tries various vendor prefixes and returns the first supported property.\n   */\n  function vendor (el, prop) {\n    var s = el.style\n      , pp\n      , i\n\n    prop = prop.charAt(0).toUpperCase() + prop.slice(1)\n    if (s[prop] !== undefined) return prop\n    for (i = 0; i < prefixes.length; i++) {\n      pp = prefixes[i]+prop\n      if (s[pp] !== undefined) return pp\n    }\n  }\n\n  /**\n   * Sets multiple style properties at once.\n   */\n  function css (el, prop) {\n    for (var n in prop) {\n      el.style[vendor(el, n) || n] = prop[n]\n    }\n\n    return el\n  }\n\n  /**\n   * Fills in default values.\n   */\n  function merge (obj) {\n    for (var i = 1; i < arguments.length; i++) {\n      var def = arguments[i]\n      for (var n in def) {\n        if (obj[n] === undefined) obj[n] = def[n]\n      }\n    }\n    return obj\n  }\n\n  /**\n   * Returns the line color from the given string or array.\n   */\n  function getColor (color, idx) {\n    return typeof color == 'string' ? color : color[idx % color.length]\n  }\n\n  // Built-in defaults\n\n  var defaults = {\n    lines: 12             // The number of lines to draw\n  , length: 7             // The length of each line\n  , width: 5              // The line thickness\n  , radius: 10            // The radius of the inner circle\n  , scale: 1.0            // Scales overall size of the spinner\n  , corners: 1            // Roundness (0..1)\n  , color: '#000'         // #rgb or #rrggbb\n  , opacity: 1/4          // Opacity of the lines\n  , rotate: 0             // Rotation offset\n  , direction: 1          // 1: clockwise, -1: counterclockwise\n  , speed: 1              // Rounds per second\n  , trail: 100            // Afterglow percentage\n  , fps: 20               // Frames per second when using setTimeout()\n  , zIndex: 2e9           // Use a high z-index by default\n  , className: 'spinner'  // CSS class to assign to the element\n  , top: '50%'            // center vertically\n  , left: '50%'           // center horizontally\n  , shadow: false         // Whether to render a shadow\n  , hwaccel: false        // Whether to use hardware acceleration (might be buggy)\n  , position: 'absolute'  // Element positioning\n  }\n\n  /** The constructor */\n  function Spinner (o) {\n    this.opts = merge(o || {}, Spinner.defaults, defaults)\n  }\n\n  // Global defaults that override the built-ins:\n  Spinner.defaults = {}\n\n  merge(Spinner.prototype, {\n    /**\n     * Adds the spinner to the given target element. If this instance is already\n     * spinning, it is automatically removed from its previous target b calling\n     * stop() internally.\n     */\n    spin: function (target) {\n      this.stop()\n\n      var self = this\n        , o = self.opts\n        , el = self.el = createEl(null, {className: o.className})\n\n      css(el, {\n        position: o.position\n      , width: 0\n      , zIndex: o.zIndex\n      , left: o.left\n      , top: o.top\n      })\n\n      if (target) {\n        target.insertBefore(el, target.firstChild || null)\n      }\n\n      el.setAttribute('role', 'progressbar')\n      self.lines(el, self.opts)\n\n      if (!useCssAnimations) {\n        // No CSS animation support, use setTimeout() instead\n        var i = 0\n          , start = (o.lines - 1) * (1 - o.direction) / 2\n          , alpha\n          , fps = o.fps\n          , f = fps / o.speed\n          , ostep = (1 - o.opacity) / (f * o.trail / 100)\n          , astep = f / o.lines\n\n        ;(function anim () {\n          i++\n          for (var j = 0; j < o.lines; j++) {\n            alpha = Math.max(1 - (i + (o.lines - j) * astep) % f * ostep, o.opacity)\n\n            self.opacity(el, j * o.direction + start, alpha, o)\n          }\n          self.timeout = self.el && setTimeout(anim, ~~(1000 / fps))\n        })()\n      }\n      return self\n    }\n\n    /**\n     * Stops and removes the Spinner.\n     */\n  , stop: function () {\n      var el = this.el\n      if (el) {\n        clearTimeout(this.timeout)\n        if (el.parentNode) el.parentNode.removeChild(el)\n        this.el = undefined\n      }\n      return this\n    }\n\n    /**\n     * Internal method that draws the individual lines. Will be overwritten\n     * in VML fallback mode below.\n     */\n  , lines: function (el, o) {\n      var i = 0\n        , start = (o.lines - 1) * (1 - o.direction) / 2\n        , seg\n\n      function fill (color, shadow) {\n        return css(createEl(), {\n          position: 'absolute'\n        , width: o.scale * (o.length + o.width) + 'px'\n        , height: o.scale * o.width + 'px'\n        , background: color\n        , boxShadow: shadow\n        , transformOrigin: 'left'\n        , transform: 'rotate(' + ~~(360/o.lines*i + o.rotate) + 'deg) translate(' + o.scale*o.radius + 'px' + ',0)'\n        , borderRadius: (o.corners * o.scale * o.width >> 1) + 'px'\n        })\n      }\n\n      for (; i < o.lines; i++) {\n        seg = css(createEl(), {\n          position: 'absolute'\n        , top: 1 + ~(o.scale * o.width / 2) + 'px'\n        , transform: o.hwaccel ? 'translate3d(0,0,0)' : ''\n        , opacity: o.opacity\n        , animation: useCssAnimations && addAnimation(o.opacity, o.trail, start + i * o.direction, o.lines) + ' ' + 1 / o.speed + 's linear infinite'\n        })\n\n        if (o.shadow) ins(seg, css(fill('#000', '0 0 4px #000'), {top: '2px'}))\n        ins(el, ins(seg, fill(getColor(o.color, i), '0 0 1px rgba(0,0,0,.1)')))\n      }\n      return el\n    }\n\n    /**\n     * Internal method that adjusts the opacity of a single line.\n     * Will be overwritten in VML fallback mode below.\n     */\n  , opacity: function (el, i, val) {\n      if (i < el.childNodes.length) el.childNodes[i].style.opacity = val\n    }\n\n  })\n\n\n  function initVML () {\n\n    /* Utility function to create a VML tag */\n    function vml (tag, attr) {\n      return createEl('<' + tag + ' xmlns=\"urn:schemas-microsoft.com:vml\" class=\"spin-vml\">', attr)\n    }\n\n    // No CSS transforms but VML support, add a CSS rule for VML elements:\n    sheet.addRule('.spin-vml', 'behavior:url(#default#VML)')\n\n    Spinner.prototype.lines = function (el, o) {\n      var r = o.scale * (o.length + o.width)\n        , s = o.scale * 2 * r\n\n      function grp () {\n        return css(\n          vml('group', {\n            coordsize: s + ' ' + s\n          , coordorigin: -r + ' ' + -r\n          })\n        , { width: s, height: s }\n        )\n      }\n\n      var margin = -(o.width + o.length) * o.scale * 2 + 'px'\n        , g = css(grp(), {position: 'absolute', top: margin, left: margin})\n        , i\n\n      function seg (i, dx, filter) {\n        ins(\n          g\n        , ins(\n            css(grp(), {rotation: 360 / o.lines * i + 'deg', left: ~~dx})\n          , ins(\n              css(\n                vml('roundrect', {arcsize: o.corners})\n              , { width: r\n                , height: o.scale * o.width\n                , left: o.scale * o.radius\n                , top: -o.scale * o.width >> 1\n                , filter: filter\n                }\n              )\n            , vml('fill', {color: getColor(o.color, i), opacity: o.opacity})\n            , vml('stroke', {opacity: 0}) // transparent stroke to fix color bleeding upon opacity change\n            )\n          )\n        )\n      }\n\n      if (o.shadow)\n        for (i = 1; i <= o.lines; i++) {\n          seg(i, -2, 'progid:DXImageTransform.Microsoft.Blur(pixelradius=2,makeshadow=1,shadowopacity=.3)')\n        }\n\n      for (i = 1; i <= o.lines; i++) seg(i)\n      return ins(el, g)\n    }\n\n    Spinner.prototype.opacity = function (el, i, val, o) {\n      var c = el.firstChild\n      o = o.shadow && o.lines || 0\n      if (c && i + o < c.childNodes.length) {\n        c = c.childNodes[i + o]; c = c && c.firstChild; c = c && c.firstChild\n        if (c) c.opacity = val\n      }\n    }\n  }\n\n  if (typeof document !== 'undefined') {\n    sheet = (function () {\n      var el = createEl('style', {type : 'text/css'})\n      ins(document.getElementsByTagName('head')[0], el)\n      return el.sheet || el.styleSheet\n    }())\n\n    var probe = css(createEl('group'), {behavior: 'url(#default#VML)'})\n\n    if (!vendor(probe, 'transform') && probe.adj) initVML()\n    else useCssAnimations = vendor(probe, 'animation')\n  }\n\n  return Spinner\n\n}));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3NwaW4uanMvc3Bpbi5qcz84NzE3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsWUFBWSxrQkFBa0I7QUFDOUIsbUJBQW1CLHNCQUFzQjtBQUN6QywwQkFBMEIsVUFBVTtBQUNwQyxpQ0FBaUMsc0JBQXNCO0FBQ3ZELGNBQWMsa0JBQWtCO0FBQ2hDLFVBQVU7O0FBRVY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLHFCQUFxQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlDQUF5Qyx1QkFBdUI7O0FBRWhFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNBLHlCQUF5QixhQUFhO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUEsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQsa0VBQWtFLFdBQVc7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7O0FBR0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQixnREFBZ0Q7QUFDMUU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0RBQWdEO0FBQ3hFO0FBQ0E7QUFDQSxrQ0FBa0MsbUJBQW1CO0FBQ3JELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0RBQWdEO0FBQzNFLDZCQUE2QixXQUFXO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTs7QUFFQSxpQkFBaUIsY0FBYztBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHVCQUF1QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDLGtCQUFrQjtBQUNwRDtBQUNBO0FBQ0EsS0FBSzs7QUFFTCx3Q0FBd0MsOEJBQThCOztBQUV0RTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyIsImZpbGUiOiI1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAxNCBGZWxpeCBHbmFzc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwOi8vc3Bpbi5qcy5vcmcvXG4gKlxuICogRXhhbXBsZTpcbiAgICB2YXIgb3B0cyA9IHtcbiAgICAgIGxpbmVzOiAxMiAgICAgICAgICAgICAvLyBUaGUgbnVtYmVyIG9mIGxpbmVzIHRvIGRyYXdcbiAgICAsIGxlbmd0aDogNyAgICAgICAgICAgICAvLyBUaGUgbGVuZ3RoIG9mIGVhY2ggbGluZVxuICAgICwgd2lkdGg6IDUgICAgICAgICAgICAgIC8vIFRoZSBsaW5lIHRoaWNrbmVzc1xuICAgICwgcmFkaXVzOiAxMCAgICAgICAgICAgIC8vIFRoZSByYWRpdXMgb2YgdGhlIGlubmVyIGNpcmNsZVxuICAgICwgc2NhbGU6IDEuMCAgICAgICAgICAgIC8vIFNjYWxlcyBvdmVyYWxsIHNpemUgb2YgdGhlIHNwaW5uZXJcbiAgICAsIGNvcm5lcnM6IDEgICAgICAgICAgICAvLyBSb3VuZG5lc3MgKDAuLjEpXG4gICAgLCBjb2xvcjogJyMwMDAnICAgICAgICAgLy8gI3JnYiBvciAjcnJnZ2JiXG4gICAgLCBvcGFjaXR5OiAxLzQgICAgICAgICAgLy8gT3BhY2l0eSBvZiB0aGUgbGluZXNcbiAgICAsIHJvdGF0ZTogMCAgICAgICAgICAgICAvLyBSb3RhdGlvbiBvZmZzZXRcbiAgICAsIGRpcmVjdGlvbjogMSAgICAgICAgICAvLyAxOiBjbG9ja3dpc2UsIC0xOiBjb3VudGVyY2xvY2t3aXNlXG4gICAgLCBzcGVlZDogMSAgICAgICAgICAgICAgLy8gUm91bmRzIHBlciBzZWNvbmRcbiAgICAsIHRyYWlsOiAxMDAgICAgICAgICAgICAvLyBBZnRlcmdsb3cgcGVyY2VudGFnZVxuICAgICwgZnBzOiAyMCAgICAgICAgICAgICAgIC8vIEZyYW1lcyBwZXIgc2Vjb25kIHdoZW4gdXNpbmcgc2V0VGltZW91dCgpXG4gICAgLCB6SW5kZXg6IDJlOSAgICAgICAgICAgLy8gVXNlIGEgaGlnaCB6LWluZGV4IGJ5IGRlZmF1bHRcbiAgICAsIGNsYXNzTmFtZTogJ3NwaW5uZXInICAvLyBDU1MgY2xhc3MgdG8gYXNzaWduIHRvIHRoZSBlbGVtZW50XG4gICAgLCB0b3A6ICc1MCUnICAgICAgICAgICAgLy8gY2VudGVyIHZlcnRpY2FsbHlcbiAgICAsIGxlZnQ6ICc1MCUnICAgICAgICAgICAvLyBjZW50ZXIgaG9yaXpvbnRhbGx5XG4gICAgLCBzaGFkb3c6IGZhbHNlICAgICAgICAgLy8gV2hldGhlciB0byByZW5kZXIgYSBzaGFkb3dcbiAgICAsIGh3YWNjZWw6IGZhbHNlICAgICAgICAvLyBXaGV0aGVyIHRvIHVzZSBoYXJkd2FyZSBhY2NlbGVyYXRpb24gKG1pZ2h0IGJlIGJ1Z2d5KVxuICAgICwgcG9zaXRpb246ICdhYnNvbHV0ZScgIC8vIEVsZW1lbnQgcG9zaXRpb25pbmdcbiAgICB9XG4gICAgdmFyIHRhcmdldCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmb28nKVxuICAgIHZhciBzcGlubmVyID0gbmV3IFNwaW5uZXIob3B0cykuc3Bpbih0YXJnZXQpXG4gKi9cbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblxuICAvKiBDb21tb25KUyAqL1xuICBpZiAodHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KClcblxuICAvKiBBTUQgbW9kdWxlICovXG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSBkZWZpbmUoZmFjdG9yeSlcblxuICAvKiBCcm93c2VyIGdsb2JhbCAqL1xuICBlbHNlIHJvb3QuU3Bpbm5lciA9IGZhY3RvcnkoKVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gIFwidXNlIHN0cmljdFwiXG5cbiAgdmFyIHByZWZpeGVzID0gWyd3ZWJraXQnLCAnTW96JywgJ21zJywgJ08nXSAvKiBWZW5kb3IgcHJlZml4ZXMgKi9cbiAgICAsIGFuaW1hdGlvbnMgPSB7fSAvKiBBbmltYXRpb24gcnVsZXMga2V5ZWQgYnkgdGhlaXIgbmFtZSAqL1xuICAgICwgdXNlQ3NzQW5pbWF0aW9ucyAvKiBXaGV0aGVyIHRvIHVzZSBDU1MgYW5pbWF0aW9ucyBvciBzZXRUaW1lb3V0ICovXG4gICAgLCBzaGVldCAvKiBBIHN0eWxlc2hlZXQgdG8gaG9sZCB0aGUgQGtleWZyYW1lIG9yIFZNTCBydWxlcy4gKi9cblxuICAvKipcbiAgICogVXRpbGl0eSBmdW5jdGlvbiB0byBjcmVhdGUgZWxlbWVudHMuIElmIG5vIHRhZyBuYW1lIGlzIGdpdmVuLFxuICAgKiBhIERJViBpcyBjcmVhdGVkLiBPcHRpb25hbGx5IHByb3BlcnRpZXMgY2FuIGJlIHBhc3NlZC5cbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsICh0YWcsIHByb3ApIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyB8fCAnZGl2JylcbiAgICAgICwgblxuXG4gICAgZm9yIChuIGluIHByb3ApIGVsW25dID0gcHJvcFtuXVxuICAgIHJldHVybiBlbFxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGVuZHMgY2hpbGRyZW4gYW5kIHJldHVybnMgdGhlIHBhcmVudC5cbiAgICovXG4gIGZ1bmN0aW9uIGlucyAocGFyZW50IC8qIGNoaWxkMSwgY2hpbGQyLCAuLi4qLykge1xuICAgIGZvciAodmFyIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGFyZ3VtZW50c1tpXSlcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyZW50XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBvcGFjaXR5IGtleWZyYW1lIGFuaW1hdGlvbiBydWxlIGFuZCByZXR1cm5zIGl0cyBuYW1lLlxuICAgKiBTaW5jZSBtb3N0IG1vYmlsZSBXZWJraXRzIGhhdmUgdGltaW5nIGlzc3VlcyB3aXRoIGFuaW1hdGlvbi1kZWxheSxcbiAgICogd2UgY3JlYXRlIHNlcGFyYXRlIHJ1bGVzIGZvciBlYWNoIGxpbmUvc2VnbWVudC5cbiAgICovXG4gIGZ1bmN0aW9uIGFkZEFuaW1hdGlvbiAoYWxwaGEsIHRyYWlsLCBpLCBsaW5lcykge1xuICAgIHZhciBuYW1lID0gWydvcGFjaXR5JywgdHJhaWwsIH5+KGFscGhhICogMTAwKSwgaSwgbGluZXNdLmpvaW4oJy0nKVxuICAgICAgLCBzdGFydCA9IDAuMDEgKyBpL2xpbmVzICogMTAwXG4gICAgICAsIHogPSBNYXRoLm1heCgxIC0gKDEtYWxwaGEpIC8gdHJhaWwgKiAoMTAwLXN0YXJ0KSwgYWxwaGEpXG4gICAgICAsIHByZWZpeCA9IHVzZUNzc0FuaW1hdGlvbnMuc3Vic3RyaW5nKDAsIHVzZUNzc0FuaW1hdGlvbnMuaW5kZXhPZignQW5pbWF0aW9uJykpLnRvTG93ZXJDYXNlKClcbiAgICAgICwgcHJlID0gcHJlZml4ICYmICctJyArIHByZWZpeCArICctJyB8fCAnJ1xuXG4gICAgaWYgKCFhbmltYXRpb25zW25hbWVdKSB7XG4gICAgICBzaGVldC5pbnNlcnRSdWxlKFxuICAgICAgICAnQCcgKyBwcmUgKyAna2V5ZnJhbWVzICcgKyBuYW1lICsgJ3snICtcbiAgICAgICAgJzAle29wYWNpdHk6JyArIHogKyAnfScgK1xuICAgICAgICBzdGFydCArICcle29wYWNpdHk6JyArIGFscGhhICsgJ30nICtcbiAgICAgICAgKHN0YXJ0KzAuMDEpICsgJyV7b3BhY2l0eToxfScgK1xuICAgICAgICAoc3RhcnQrdHJhaWwpICUgMTAwICsgJyV7b3BhY2l0eTonICsgYWxwaGEgKyAnfScgK1xuICAgICAgICAnMTAwJXtvcGFjaXR5OicgKyB6ICsgJ30nICtcbiAgICAgICAgJ30nLCBzaGVldC5jc3NSdWxlcy5sZW5ndGgpXG5cbiAgICAgIGFuaW1hdGlvbnNbbmFtZV0gPSAxXG4gICAgfVxuXG4gICAgcmV0dXJuIG5hbWVcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmllcyB2YXJpb3VzIHZlbmRvciBwcmVmaXhlcyBhbmQgcmV0dXJucyB0aGUgZmlyc3Qgc3VwcG9ydGVkIHByb3BlcnR5LlxuICAgKi9cbiAgZnVuY3Rpb24gdmVuZG9yIChlbCwgcHJvcCkge1xuICAgIHZhciBzID0gZWwuc3R5bGVcbiAgICAgICwgcHBcbiAgICAgICwgaVxuXG4gICAgcHJvcCA9IHByb3AuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wLnNsaWNlKDEpXG4gICAgaWYgKHNbcHJvcF0gIT09IHVuZGVmaW5lZCkgcmV0dXJuIHByb3BcbiAgICBmb3IgKGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBwID0gcHJlZml4ZXNbaV0rcHJvcFxuICAgICAgaWYgKHNbcHBdICE9PSB1bmRlZmluZWQpIHJldHVybiBwcFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIG11bHRpcGxlIHN0eWxlIHByb3BlcnRpZXMgYXQgb25jZS5cbiAgICovXG4gIGZ1bmN0aW9uIGNzcyAoZWwsIHByb3ApIHtcbiAgICBmb3IgKHZhciBuIGluIHByb3ApIHtcbiAgICAgIGVsLnN0eWxlW3ZlbmRvcihlbCwgbikgfHwgbl0gPSBwcm9wW25dXG4gICAgfVxuXG4gICAgcmV0dXJuIGVsXG4gIH1cblxuICAvKipcbiAgICogRmlsbHMgaW4gZGVmYXVsdCB2YWx1ZXMuXG4gICAqL1xuICBmdW5jdGlvbiBtZXJnZSAob2JqKSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZWYgPSBhcmd1bWVudHNbaV1cbiAgICAgIGZvciAodmFyIG4gaW4gZGVmKSB7XG4gICAgICAgIGlmIChvYmpbbl0gPT09IHVuZGVmaW5lZCkgb2JqW25dID0gZGVmW25dXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmpcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsaW5lIGNvbG9yIGZyb20gdGhlIGdpdmVuIHN0cmluZyBvciBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIGdldENvbG9yIChjb2xvciwgaWR4KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBjb2xvciA9PSAnc3RyaW5nJyA/IGNvbG9yIDogY29sb3JbaWR4ICUgY29sb3IubGVuZ3RoXVxuICB9XG5cbiAgLy8gQnVpbHQtaW4gZGVmYXVsdHNcblxuICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgbGluZXM6IDEyICAgICAgICAgICAgIC8vIFRoZSBudW1iZXIgb2YgbGluZXMgdG8gZHJhd1xuICAsIGxlbmd0aDogNyAgICAgICAgICAgICAvLyBUaGUgbGVuZ3RoIG9mIGVhY2ggbGluZVxuICAsIHdpZHRoOiA1ICAgICAgICAgICAgICAvLyBUaGUgbGluZSB0aGlja25lc3NcbiAgLCByYWRpdXM6IDEwICAgICAgICAgICAgLy8gVGhlIHJhZGl1cyBvZiB0aGUgaW5uZXIgY2lyY2xlXG4gICwgc2NhbGU6IDEuMCAgICAgICAgICAgIC8vIFNjYWxlcyBvdmVyYWxsIHNpemUgb2YgdGhlIHNwaW5uZXJcbiAgLCBjb3JuZXJzOiAxICAgICAgICAgICAgLy8gUm91bmRuZXNzICgwLi4xKVxuICAsIGNvbG9yOiAnIzAwMCcgICAgICAgICAvLyAjcmdiIG9yICNycmdnYmJcbiAgLCBvcGFjaXR5OiAxLzQgICAgICAgICAgLy8gT3BhY2l0eSBvZiB0aGUgbGluZXNcbiAgLCByb3RhdGU6IDAgICAgICAgICAgICAgLy8gUm90YXRpb24gb2Zmc2V0XG4gICwgZGlyZWN0aW9uOiAxICAgICAgICAgIC8vIDE6IGNsb2Nrd2lzZSwgLTE6IGNvdW50ZXJjbG9ja3dpc2VcbiAgLCBzcGVlZDogMSAgICAgICAgICAgICAgLy8gUm91bmRzIHBlciBzZWNvbmRcbiAgLCB0cmFpbDogMTAwICAgICAgICAgICAgLy8gQWZ0ZXJnbG93IHBlcmNlbnRhZ2VcbiAgLCBmcHM6IDIwICAgICAgICAgICAgICAgLy8gRnJhbWVzIHBlciBzZWNvbmQgd2hlbiB1c2luZyBzZXRUaW1lb3V0KClcbiAgLCB6SW5kZXg6IDJlOSAgICAgICAgICAgLy8gVXNlIGEgaGlnaCB6LWluZGV4IGJ5IGRlZmF1bHRcbiAgLCBjbGFzc05hbWU6ICdzcGlubmVyJyAgLy8gQ1NTIGNsYXNzIHRvIGFzc2lnbiB0byB0aGUgZWxlbWVudFxuICAsIHRvcDogJzUwJScgICAgICAgICAgICAvLyBjZW50ZXIgdmVydGljYWxseVxuICAsIGxlZnQ6ICc1MCUnICAgICAgICAgICAvLyBjZW50ZXIgaG9yaXpvbnRhbGx5XG4gICwgc2hhZG93OiBmYWxzZSAgICAgICAgIC8vIFdoZXRoZXIgdG8gcmVuZGVyIGEgc2hhZG93XG4gICwgaHdhY2NlbDogZmFsc2UgICAgICAgIC8vIFdoZXRoZXIgdG8gdXNlIGhhcmR3YXJlIGFjY2VsZXJhdGlvbiAobWlnaHQgYmUgYnVnZ3kpXG4gICwgcG9zaXRpb246ICdhYnNvbHV0ZScgIC8vIEVsZW1lbnQgcG9zaXRpb25pbmdcbiAgfVxuXG4gIC8qKiBUaGUgY29uc3RydWN0b3IgKi9cbiAgZnVuY3Rpb24gU3Bpbm5lciAobykge1xuICAgIHRoaXMub3B0cyA9IG1lcmdlKG8gfHwge30sIFNwaW5uZXIuZGVmYXVsdHMsIGRlZmF1bHRzKVxuICB9XG5cbiAgLy8gR2xvYmFsIGRlZmF1bHRzIHRoYXQgb3ZlcnJpZGUgdGhlIGJ1aWx0LWluczpcbiAgU3Bpbm5lci5kZWZhdWx0cyA9IHt9XG5cbiAgbWVyZ2UoU3Bpbm5lci5wcm90b3R5cGUsIHtcbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBzcGlubmVyIHRvIHRoZSBnaXZlbiB0YXJnZXQgZWxlbWVudC4gSWYgdGhpcyBpbnN0YW5jZSBpcyBhbHJlYWR5XG4gICAgICogc3Bpbm5pbmcsIGl0IGlzIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZCBmcm9tIGl0cyBwcmV2aW91cyB0YXJnZXQgYiBjYWxsaW5nXG4gICAgICogc3RvcCgpIGludGVybmFsbHkuXG4gICAgICovXG4gICAgc3BpbjogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgdGhpcy5zdG9wKClcblxuICAgICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgICAgICwgbyA9IHNlbGYub3B0c1xuICAgICAgICAsIGVsID0gc2VsZi5lbCA9IGNyZWF0ZUVsKG51bGwsIHtjbGFzc05hbWU6IG8uY2xhc3NOYW1lfSlcblxuICAgICAgY3NzKGVsLCB7XG4gICAgICAgIHBvc2l0aW9uOiBvLnBvc2l0aW9uXG4gICAgICAsIHdpZHRoOiAwXG4gICAgICAsIHpJbmRleDogby56SW5kZXhcbiAgICAgICwgbGVmdDogby5sZWZ0XG4gICAgICAsIHRvcDogby50b3BcbiAgICAgIH0pXG5cbiAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgdGFyZ2V0Lmluc2VydEJlZm9yZShlbCwgdGFyZ2V0LmZpcnN0Q2hpbGQgfHwgbnVsbClcbiAgICAgIH1cblxuICAgICAgZWwuc2V0QXR0cmlidXRlKCdyb2xlJywgJ3Byb2dyZXNzYmFyJylcbiAgICAgIHNlbGYubGluZXMoZWwsIHNlbGYub3B0cylcblxuICAgICAgaWYgKCF1c2VDc3NBbmltYXRpb25zKSB7XG4gICAgICAgIC8vIE5vIENTUyBhbmltYXRpb24gc3VwcG9ydCwgdXNlIHNldFRpbWVvdXQoKSBpbnN0ZWFkXG4gICAgICAgIHZhciBpID0gMFxuICAgICAgICAgICwgc3RhcnQgPSAoby5saW5lcyAtIDEpICogKDEgLSBvLmRpcmVjdGlvbikgLyAyXG4gICAgICAgICAgLCBhbHBoYVxuICAgICAgICAgICwgZnBzID0gby5mcHNcbiAgICAgICAgICAsIGYgPSBmcHMgLyBvLnNwZWVkXG4gICAgICAgICAgLCBvc3RlcCA9ICgxIC0gby5vcGFjaXR5KSAvIChmICogby50cmFpbCAvIDEwMClcbiAgICAgICAgICAsIGFzdGVwID0gZiAvIG8ubGluZXNcblxuICAgICAgICA7KGZ1bmN0aW9uIGFuaW0gKCkge1xuICAgICAgICAgIGkrK1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgby5saW5lczsgaisrKSB7XG4gICAgICAgICAgICBhbHBoYSA9IE1hdGgubWF4KDEgLSAoaSArIChvLmxpbmVzIC0gaikgKiBhc3RlcCkgJSBmICogb3N0ZXAsIG8ub3BhY2l0eSlcblxuICAgICAgICAgICAgc2VsZi5vcGFjaXR5KGVsLCBqICogby5kaXJlY3Rpb24gKyBzdGFydCwgYWxwaGEsIG8pXG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGYudGltZW91dCA9IHNlbGYuZWwgJiYgc2V0VGltZW91dChhbmltLCB+figxMDAwIC8gZnBzKSlcbiAgICAgICAgfSkoKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGZcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdG9wcyBhbmQgcmVtb3ZlcyB0aGUgU3Bpbm5lci5cbiAgICAgKi9cbiAgLCBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZWwgPSB0aGlzLmVsXG4gICAgICBpZiAoZWwpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dClcbiAgICAgICAgaWYgKGVsLnBhcmVudE5vZGUpIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpXG4gICAgICAgIHRoaXMuZWwgPSB1bmRlZmluZWRcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgbWV0aG9kIHRoYXQgZHJhd3MgdGhlIGluZGl2aWR1YWwgbGluZXMuIFdpbGwgYmUgb3ZlcndyaXR0ZW5cbiAgICAgKiBpbiBWTUwgZmFsbGJhY2sgbW9kZSBiZWxvdy5cbiAgICAgKi9cbiAgLCBsaW5lczogZnVuY3Rpb24gKGVsLCBvKSB7XG4gICAgICB2YXIgaSA9IDBcbiAgICAgICAgLCBzdGFydCA9IChvLmxpbmVzIC0gMSkgKiAoMSAtIG8uZGlyZWN0aW9uKSAvIDJcbiAgICAgICAgLCBzZWdcblxuICAgICAgZnVuY3Rpb24gZmlsbCAoY29sb3IsIHNoYWRvdykge1xuICAgICAgICByZXR1cm4gY3NzKGNyZWF0ZUVsKCksIHtcbiAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJ1xuICAgICAgICAsIHdpZHRoOiBvLnNjYWxlICogKG8ubGVuZ3RoICsgby53aWR0aCkgKyAncHgnXG4gICAgICAgICwgaGVpZ2h0OiBvLnNjYWxlICogby53aWR0aCArICdweCdcbiAgICAgICAgLCBiYWNrZ3JvdW5kOiBjb2xvclxuICAgICAgICAsIGJveFNoYWRvdzogc2hhZG93XG4gICAgICAgICwgdHJhbnNmb3JtT3JpZ2luOiAnbGVmdCdcbiAgICAgICAgLCB0cmFuc2Zvcm06ICdyb3RhdGUoJyArIH5+KDM2MC9vLmxpbmVzKmkgKyBvLnJvdGF0ZSkgKyAnZGVnKSB0cmFuc2xhdGUoJyArIG8uc2NhbGUqby5yYWRpdXMgKyAncHgnICsgJywwKSdcbiAgICAgICAgLCBib3JkZXJSYWRpdXM6IChvLmNvcm5lcnMgKiBvLnNjYWxlICogby53aWR0aCA+PiAxKSArICdweCdcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgZm9yICg7IGkgPCBvLmxpbmVzOyBpKyspIHtcbiAgICAgICAgc2VnID0gY3NzKGNyZWF0ZUVsKCksIHtcbiAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJ1xuICAgICAgICAsIHRvcDogMSArIH4oby5zY2FsZSAqIG8ud2lkdGggLyAyKSArICdweCdcbiAgICAgICAgLCB0cmFuc2Zvcm06IG8uaHdhY2NlbCA/ICd0cmFuc2xhdGUzZCgwLDAsMCknIDogJydcbiAgICAgICAgLCBvcGFjaXR5OiBvLm9wYWNpdHlcbiAgICAgICAgLCBhbmltYXRpb246IHVzZUNzc0FuaW1hdGlvbnMgJiYgYWRkQW5pbWF0aW9uKG8ub3BhY2l0eSwgby50cmFpbCwgc3RhcnQgKyBpICogby5kaXJlY3Rpb24sIG8ubGluZXMpICsgJyAnICsgMSAvIG8uc3BlZWQgKyAncyBsaW5lYXIgaW5maW5pdGUnXG4gICAgICAgIH0pXG5cbiAgICAgICAgaWYgKG8uc2hhZG93KSBpbnMoc2VnLCBjc3MoZmlsbCgnIzAwMCcsICcwIDAgNHB4ICMwMDAnKSwge3RvcDogJzJweCd9KSlcbiAgICAgICAgaW5zKGVsLCBpbnMoc2VnLCBmaWxsKGdldENvbG9yKG8uY29sb3IsIGkpLCAnMCAwIDFweCByZ2JhKDAsMCwwLC4xKScpKSlcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIG1ldGhvZCB0aGF0IGFkanVzdHMgdGhlIG9wYWNpdHkgb2YgYSBzaW5nbGUgbGluZS5cbiAgICAgKiBXaWxsIGJlIG92ZXJ3cml0dGVuIGluIFZNTCBmYWxsYmFjayBtb2RlIGJlbG93LlxuICAgICAqL1xuICAsIG9wYWNpdHk6IGZ1bmN0aW9uIChlbCwgaSwgdmFsKSB7XG4gICAgICBpZiAoaSA8IGVsLmNoaWxkTm9kZXMubGVuZ3RoKSBlbC5jaGlsZE5vZGVzW2ldLnN0eWxlLm9wYWNpdHkgPSB2YWxcbiAgICB9XG5cbiAgfSlcblxuXG4gIGZ1bmN0aW9uIGluaXRWTUwgKCkge1xuXG4gICAgLyogVXRpbGl0eSBmdW5jdGlvbiB0byBjcmVhdGUgYSBWTUwgdGFnICovXG4gICAgZnVuY3Rpb24gdm1sICh0YWcsIGF0dHIpIHtcbiAgICAgIHJldHVybiBjcmVhdGVFbCgnPCcgKyB0YWcgKyAnIHhtbG5zPVwidXJuOnNjaGVtYXMtbWljcm9zb2Z0LmNvbTp2bWxcIiBjbGFzcz1cInNwaW4tdm1sXCI+JywgYXR0cilcbiAgICB9XG5cbiAgICAvLyBObyBDU1MgdHJhbnNmb3JtcyBidXQgVk1MIHN1cHBvcnQsIGFkZCBhIENTUyBydWxlIGZvciBWTUwgZWxlbWVudHM6XG4gICAgc2hlZXQuYWRkUnVsZSgnLnNwaW4tdm1sJywgJ2JlaGF2aW9yOnVybCgjZGVmYXVsdCNWTUwpJylcblxuICAgIFNwaW5uZXIucHJvdG90eXBlLmxpbmVzID0gZnVuY3Rpb24gKGVsLCBvKSB7XG4gICAgICB2YXIgciA9IG8uc2NhbGUgKiAoby5sZW5ndGggKyBvLndpZHRoKVxuICAgICAgICAsIHMgPSBvLnNjYWxlICogMiAqIHJcblxuICAgICAgZnVuY3Rpb24gZ3JwICgpIHtcbiAgICAgICAgcmV0dXJuIGNzcyhcbiAgICAgICAgICB2bWwoJ2dyb3VwJywge1xuICAgICAgICAgICAgY29vcmRzaXplOiBzICsgJyAnICsgc1xuICAgICAgICAgICwgY29vcmRvcmlnaW46IC1yICsgJyAnICsgLXJcbiAgICAgICAgICB9KVxuICAgICAgICAsIHsgd2lkdGg6IHMsIGhlaWdodDogcyB9XG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgdmFyIG1hcmdpbiA9IC0oby53aWR0aCArIG8ubGVuZ3RoKSAqIG8uc2NhbGUgKiAyICsgJ3B4J1xuICAgICAgICAsIGcgPSBjc3MoZ3JwKCksIHtwb3NpdGlvbjogJ2Fic29sdXRlJywgdG9wOiBtYXJnaW4sIGxlZnQ6IG1hcmdpbn0pXG4gICAgICAgICwgaVxuXG4gICAgICBmdW5jdGlvbiBzZWcgKGksIGR4LCBmaWx0ZXIpIHtcbiAgICAgICAgaW5zKFxuICAgICAgICAgIGdcbiAgICAgICAgLCBpbnMoXG4gICAgICAgICAgICBjc3MoZ3JwKCksIHtyb3RhdGlvbjogMzYwIC8gby5saW5lcyAqIGkgKyAnZGVnJywgbGVmdDogfn5keH0pXG4gICAgICAgICAgLCBpbnMoXG4gICAgICAgICAgICAgIGNzcyhcbiAgICAgICAgICAgICAgICB2bWwoJ3JvdW5kcmVjdCcsIHthcmNzaXplOiBvLmNvcm5lcnN9KVxuICAgICAgICAgICAgICAsIHsgd2lkdGg6IHJcbiAgICAgICAgICAgICAgICAsIGhlaWdodDogby5zY2FsZSAqIG8ud2lkdGhcbiAgICAgICAgICAgICAgICAsIGxlZnQ6IG8uc2NhbGUgKiBvLnJhZGl1c1xuICAgICAgICAgICAgICAgICwgdG9wOiAtby5zY2FsZSAqIG8ud2lkdGggPj4gMVxuICAgICAgICAgICAgICAgICwgZmlsdGVyOiBmaWx0ZXJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICwgdm1sKCdmaWxsJywge2NvbG9yOiBnZXRDb2xvcihvLmNvbG9yLCBpKSwgb3BhY2l0eTogby5vcGFjaXR5fSlcbiAgICAgICAgICAgICwgdm1sKCdzdHJva2UnLCB7b3BhY2l0eTogMH0pIC8vIHRyYW5zcGFyZW50IHN0cm9rZSB0byBmaXggY29sb3IgYmxlZWRpbmcgdXBvbiBvcGFjaXR5IGNoYW5nZVxuICAgICAgICAgICAgKVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICBpZiAoby5zaGFkb3cpXG4gICAgICAgIGZvciAoaSA9IDE7IGkgPD0gby5saW5lczsgaSsrKSB7XG4gICAgICAgICAgc2VnKGksIC0yLCAncHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LkJsdXIocGl4ZWxyYWRpdXM9MixtYWtlc2hhZG93PTEsc2hhZG93b3BhY2l0eT0uMyknKVxuICAgICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDE7IGkgPD0gby5saW5lczsgaSsrKSBzZWcoaSlcbiAgICAgIHJldHVybiBpbnMoZWwsIGcpXG4gICAgfVxuXG4gICAgU3Bpbm5lci5wcm90b3R5cGUub3BhY2l0eSA9IGZ1bmN0aW9uIChlbCwgaSwgdmFsLCBvKSB7XG4gICAgICB2YXIgYyA9IGVsLmZpcnN0Q2hpbGRcbiAgICAgIG8gPSBvLnNoYWRvdyAmJiBvLmxpbmVzIHx8IDBcbiAgICAgIGlmIChjICYmIGkgKyBvIDwgYy5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICBjID0gYy5jaGlsZE5vZGVzW2kgKyBvXTsgYyA9IGMgJiYgYy5maXJzdENoaWxkOyBjID0gYyAmJiBjLmZpcnN0Q2hpbGRcbiAgICAgICAgaWYgKGMpIGMub3BhY2l0eSA9IHZhbFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgc2hlZXQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGVsID0gY3JlYXRlRWwoJ3N0eWxlJywge3R5cGUgOiAndGV4dC9jc3MnfSlcbiAgICAgIGlucyhkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLCBlbClcbiAgICAgIHJldHVybiBlbC5zaGVldCB8fCBlbC5zdHlsZVNoZWV0XG4gICAgfSgpKVxuXG4gICAgdmFyIHByb2JlID0gY3NzKGNyZWF0ZUVsKCdncm91cCcpLCB7YmVoYXZpb3I6ICd1cmwoI2RlZmF1bHQjVk1MKSd9KVxuXG4gICAgaWYgKCF2ZW5kb3IocHJvYmUsICd0cmFuc2Zvcm0nKSAmJiBwcm9iZS5hZGopIGluaXRWTUwoKVxuICAgIGVsc2UgdXNlQ3NzQW5pbWF0aW9ucyA9IHZlbmRvcihwcm9iZSwgJ2FuaW1hdGlvbicpXG4gIH1cblxuICByZXR1cm4gU3Bpbm5lclxuXG59KSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc3Bpbi5qcy9zcGluLmpzXG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\r\n * angular-spinner version 0.8.1\r\n * License: MIT.\r\n * Copyright (C) 2013, 2014, 2015, 2016, Uri Shaked and contributors.\r\n */\r\n\r\n'format amd';\r\n\r\n(function (root) {\r\n\t'use strict';\r\n\r\n\tfunction factory(angular, Spinner) {\r\n\r\n\t\treturn angular\r\n\t\t\t.module('angularSpinner', [])\r\n\r\n\t\t\t.constant('SpinJSSpinner', Spinner)\r\n\r\n\t\t\t.provider('usSpinnerConfig', function () {\r\n\t\t\t\tvar _config = {}, _themes = {};\r\n\r\n\t\t\t\treturn {\r\n\t\t\t\t\tsetDefaults: function (config) {\r\n\t\t\t\t\t\t_config = config || _config;\r\n\t\t\t\t\t},\r\n\t\t\t\t\tsetTheme: function(name, config) {\r\n\t\t\t\t\t\t_themes[name] = config;\r\n\t\t\t\t\t},\r\n\t\t\t\t\t$get: function () {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\tconfig: _config,\r\n\t\t\t\t\t\t\tthemes: _themes\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t})\r\n\r\n\t\t\t.factory('usSpinnerService', ['$rootScope', function ($rootScope) {\r\n\t\t\t\tvar config = {};\r\n\r\n\t\t\t\tconfig.spin = function (key) {\r\n\t\t\t\t\t$rootScope.$broadcast('us-spinner:spin', key);\r\n\t\t\t\t};\r\n\r\n\t\t\t\tconfig.stop = function (key) {\r\n\t\t\t\t\t$rootScope.$broadcast('us-spinner:stop', key);\r\n\t\t\t\t};\r\n\r\n\t\t\t\treturn config;\r\n\t\t\t}])\r\n\r\n\t\t\t.directive('usSpinner', ['SpinJSSpinner', 'usSpinnerConfig', function (SpinJSSpinner, usSpinnerConfig) {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tscope: true,\r\n\t\t\t\t\tlink: function (scope, element, attr) {\r\n\t\t\t\t\t\tscope.spinner = null;\r\n\r\n\t\t\t\t\t\tscope.key = angular.isDefined(attr.spinnerKey) ? attr.spinnerKey : false;\r\n\r\n\t\t\t\t\t\tscope.startActive = angular.isDefined(attr.spinnerStartActive) ?\r\n\t\t\t\t\t\t\tscope.$eval(attr.spinnerStartActive) : scope.key ?\r\n\t\t\t\t\t\t\tfalse : true;\r\n\r\n\t\t\t\t\t\tfunction stopSpinner() {\r\n\t\t\t\t\t\t\tif (scope.spinner) {\r\n\t\t\t\t\t\t\t\tscope.spinner.stop();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tscope.spin = function () {\r\n\t\t\t\t\t\t\tif (scope.spinner) {\r\n\t\t\t\t\t\t\t\tscope.spinner.spin(element[0]);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\tscope.stop = function () {\r\n\t\t\t\t\t\t\tscope.startActive = false;\r\n\t\t\t\t\t\t\tstopSpinner();\r\n\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\tscope.$watch(attr.usSpinner, function (options) {\r\n\t\t\t\t\t\t\tstopSpinner();\r\n\r\n\t\t\t\t\t\t\t// order of precedence: element options, theme, defaults.\r\n\t\t\t\t\t\t\toptions = angular.extend(\r\n\t\t\t\t\t\t\t\t{},\r\n\t\t\t\t\t\t\t\tusSpinnerConfig.config,\r\n\t\t\t\t\t\t\t\tusSpinnerConfig.themes[attr.spinnerTheme],\r\n\t\t\t\t\t\t\t\toptions);\r\n\r\n\t\t\t\t\t\t\tscope.spinner = new SpinJSSpinner(options);\r\n\t\t\t\t\t\t\tif ((!scope.key || scope.startActive) && !attr.spinnerOn) {\r\n\t\t\t\t\t\t\t\tscope.spinner.spin(element[0]);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}, true);\r\n\r\n\t\t\t\t\t\tif (attr.spinnerOn) {\r\n\t\t\t\t\t\t\tscope.$watch(attr.spinnerOn, function (spin) {\r\n\t\t\t\t\t\t\t\tif (spin) {\r\n\t\t\t\t\t\t\t\t\tscope.spin();\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tscope.stop();\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tscope.$on('us-spinner:spin', function (event, key) {\r\n\t\t\t\t\t\t\tif (key === scope.key) {\r\n\t\t\t\t\t\t\t\tscope.spin();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\tscope.$on('us-spinner:stop', function (event, key) {\r\n\t\t\t\t\t\t\tif (key === scope.key) {\r\n\t\t\t\t\t\t\t\tscope.stop();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\tscope.$on('$destroy', function () {\r\n\t\t\t\t\t\t\tscope.stop();\r\n\t\t\t\t\t\t\tscope.spinner = null;\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t}]);\r\n\t}\r\n\r\n    if ((typeof module === 'object') && module.exports) {\r\n\t\t/* CommonJS module */\r\n\t\tmodule.exports = factory(__webpack_require__(1), __webpack_require__(5));\r\n\t} else if (true) {\r\n\t\t/* AMD module */\r\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1), __webpack_require__(5)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t} else {\r\n\t\t/* Browser global */\r\n\t\tfactory(root.angular, root.Spinner);\r\n\t}\r\n}(this));\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2FuZ3VsYXItc3Bpbm5lci9hbmd1bGFyLXNwaW5uZXIuanM/NTJlZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6IjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogYW5ndWxhci1zcGlubmVyIHZlcnNpb24gMC44LjFcclxuICogTGljZW5zZTogTUlULlxyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTMsIDIwMTQsIDIwMTUsIDIwMTYsIFVyaSBTaGFrZWQgYW5kIGNvbnRyaWJ1dG9ycy5cclxuICovXHJcblxyXG4nZm9ybWF0IGFtZCc7XHJcblxyXG4oZnVuY3Rpb24gKHJvb3QpIHtcclxuXHQndXNlIHN0cmljdCc7XHJcblxyXG5cdGZ1bmN0aW9uIGZhY3RvcnkoYW5ndWxhciwgU3Bpbm5lcikge1xyXG5cclxuXHRcdHJldHVybiBhbmd1bGFyXHJcblx0XHRcdC5tb2R1bGUoJ2FuZ3VsYXJTcGlubmVyJywgW10pXHJcblxyXG5cdFx0XHQuY29uc3RhbnQoJ1NwaW5KU1NwaW5uZXInLCBTcGlubmVyKVxyXG5cclxuXHRcdFx0LnByb3ZpZGVyKCd1c1NwaW5uZXJDb25maWcnLCBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdFx0dmFyIF9jb25maWcgPSB7fSwgX3RoZW1lcyA9IHt9O1xyXG5cclxuXHRcdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdFx0c2V0RGVmYXVsdHM6IGZ1bmN0aW9uIChjb25maWcpIHtcclxuXHRcdFx0XHRcdFx0X2NvbmZpZyA9IGNvbmZpZyB8fCBfY29uZmlnO1xyXG5cdFx0XHRcdFx0fSxcclxuXHRcdFx0XHRcdHNldFRoZW1lOiBmdW5jdGlvbihuYW1lLCBjb25maWcpIHtcclxuXHRcdFx0XHRcdFx0X3RoZW1lc1tuYW1lXSA9IGNvbmZpZztcclxuXHRcdFx0XHRcdH0sXHJcblx0XHRcdFx0XHQkZ2V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0XHRcdFx0Y29uZmlnOiBfY29uZmlnLFxyXG5cdFx0XHRcdFx0XHRcdHRoZW1lczogX3RoZW1lc1xyXG5cdFx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH07XHJcblx0XHRcdH0pXHJcblxyXG5cdFx0XHQuZmFjdG9yeSgndXNTcGlubmVyU2VydmljZScsIFsnJHJvb3RTY29wZScsIGZ1bmN0aW9uICgkcm9vdFNjb3BlKSB7XHJcblx0XHRcdFx0dmFyIGNvbmZpZyA9IHt9O1xyXG5cclxuXHRcdFx0XHRjb25maWcuc3BpbiA9IGZ1bmN0aW9uIChrZXkpIHtcclxuXHRcdFx0XHRcdCRyb290U2NvcGUuJGJyb2FkY2FzdCgndXMtc3Bpbm5lcjpzcGluJywga2V5KTtcclxuXHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0XHRjb25maWcuc3RvcCA9IGZ1bmN0aW9uIChrZXkpIHtcclxuXHRcdFx0XHRcdCRyb290U2NvcGUuJGJyb2FkY2FzdCgndXMtc3Bpbm5lcjpzdG9wJywga2V5KTtcclxuXHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gY29uZmlnO1xyXG5cdFx0XHR9XSlcclxuXHJcblx0XHRcdC5kaXJlY3RpdmUoJ3VzU3Bpbm5lcicsIFsnU3BpbkpTU3Bpbm5lcicsICd1c1NwaW5uZXJDb25maWcnLCBmdW5jdGlvbiAoU3BpbkpTU3Bpbm5lciwgdXNTcGlubmVyQ29uZmlnKSB7XHJcblx0XHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRcdHNjb3BlOiB0cnVlLFxyXG5cdFx0XHRcdFx0bGluazogZnVuY3Rpb24gKHNjb3BlLCBlbGVtZW50LCBhdHRyKSB7XHJcblx0XHRcdFx0XHRcdHNjb3BlLnNwaW5uZXIgPSBudWxsO1xyXG5cclxuXHRcdFx0XHRcdFx0c2NvcGUua2V5ID0gYW5ndWxhci5pc0RlZmluZWQoYXR0ci5zcGlubmVyS2V5KSA/IGF0dHIuc3Bpbm5lcktleSA6IGZhbHNlO1xyXG5cclxuXHRcdFx0XHRcdFx0c2NvcGUuc3RhcnRBY3RpdmUgPSBhbmd1bGFyLmlzRGVmaW5lZChhdHRyLnNwaW5uZXJTdGFydEFjdGl2ZSkgP1xyXG5cdFx0XHRcdFx0XHRcdHNjb3BlLiRldmFsKGF0dHIuc3Bpbm5lclN0YXJ0QWN0aXZlKSA6IHNjb3BlLmtleSA/XHJcblx0XHRcdFx0XHRcdFx0ZmFsc2UgOiB0cnVlO1xyXG5cclxuXHRcdFx0XHRcdFx0ZnVuY3Rpb24gc3RvcFNwaW5uZXIoKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYgKHNjb3BlLnNwaW5uZXIpIHtcclxuXHRcdFx0XHRcdFx0XHRcdHNjb3BlLnNwaW5uZXIuc3RvcCgpO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0c2NvcGUuc3BpbiA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHRcdFx0XHRpZiAoc2NvcGUuc3Bpbm5lcikge1xyXG5cdFx0XHRcdFx0XHRcdFx0c2NvcGUuc3Bpbm5lci5zcGluKGVsZW1lbnRbMF0pO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fTtcclxuXHJcblx0XHRcdFx0XHRcdHNjb3BlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdFx0XHRcdFx0c2NvcGUuc3RhcnRBY3RpdmUgPSBmYWxzZTtcclxuXHRcdFx0XHRcdFx0XHRzdG9wU3Bpbm5lcigpO1xyXG5cdFx0XHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0XHRcdFx0c2NvcGUuJHdhdGNoKGF0dHIudXNTcGlubmVyLCBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0XHRcdFx0XHRcdHN0b3BTcGlubmVyKCk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdC8vIG9yZGVyIG9mIHByZWNlZGVuY2U6IGVsZW1lbnQgb3B0aW9ucywgdGhlbWUsIGRlZmF1bHRzLlxyXG5cdFx0XHRcdFx0XHRcdG9wdGlvbnMgPSBhbmd1bGFyLmV4dGVuZChcclxuXHRcdFx0XHRcdFx0XHRcdHt9LFxyXG5cdFx0XHRcdFx0XHRcdFx0dXNTcGlubmVyQ29uZmlnLmNvbmZpZyxcclxuXHRcdFx0XHRcdFx0XHRcdHVzU3Bpbm5lckNvbmZpZy50aGVtZXNbYXR0ci5zcGlubmVyVGhlbWVdLFxyXG5cdFx0XHRcdFx0XHRcdFx0b3B0aW9ucyk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHNjb3BlLnNwaW5uZXIgPSBuZXcgU3BpbkpTU3Bpbm5lcihvcHRpb25zKTtcclxuXHRcdFx0XHRcdFx0XHRpZiAoKCFzY29wZS5rZXkgfHwgc2NvcGUuc3RhcnRBY3RpdmUpICYmICFhdHRyLnNwaW5uZXJPbikge1xyXG5cdFx0XHRcdFx0XHRcdFx0c2NvcGUuc3Bpbm5lci5zcGluKGVsZW1lbnRbMF0pO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fSwgdHJ1ZSk7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoYXR0ci5zcGlubmVyT24pIHtcclxuXHRcdFx0XHRcdFx0XHRzY29wZS4kd2F0Y2goYXR0ci5zcGlubmVyT24sIGZ1bmN0aW9uIChzcGluKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRpZiAoc3Bpbikge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRzY29wZS5zcGluKCk7XHJcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRzY29wZS5zdG9wKCk7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdHNjb3BlLiRvbigndXMtc3Bpbm5lcjpzcGluJywgZnVuY3Rpb24gKGV2ZW50LCBrZXkpIHtcclxuXHRcdFx0XHRcdFx0XHRpZiAoa2V5ID09PSBzY29wZS5rZXkpIHtcclxuXHRcdFx0XHRcdFx0XHRcdHNjb3BlLnNwaW4oKTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHRcdFx0c2NvcGUuJG9uKCd1cy1zcGlubmVyOnN0b3AnLCBmdW5jdGlvbiAoZXZlbnQsIGtleSkge1xyXG5cdFx0XHRcdFx0XHRcdGlmIChrZXkgPT09IHNjb3BlLmtleSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0c2NvcGUuc3RvcCgpO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdFx0XHRzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRcdFx0XHRcdHNjb3BlLnN0b3AoKTtcclxuXHRcdFx0XHRcdFx0XHRzY29wZS5zcGlubmVyID0gbnVsbDtcclxuXHRcdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fTtcclxuXHRcdFx0fV0pO1xyXG5cdH1cclxuXHJcbiAgICBpZiAoKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKSAmJiBtb2R1bGUuZXhwb3J0cykge1xyXG5cdFx0LyogQ29tbW9uSlMgbW9kdWxlICovXHJcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgnYW5ndWxhcicpLCByZXF1aXJlKCdzcGluLmpzJykpO1xyXG5cdH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XHJcblx0XHQvKiBBTUQgbW9kdWxlICovXHJcblx0XHRkZWZpbmUoWydhbmd1bGFyJywgJ3NwaW4nXSwgZmFjdG9yeSk7XHJcblx0fSBlbHNlIHtcclxuXHRcdC8qIEJyb3dzZXIgZ2xvYmFsICovXHJcblx0XHRmYWN0b3J5KHJvb3QuYW5ndWxhciwgcm9vdC5TcGlubmVyKTtcclxuXHR9XHJcbn0odGhpcykpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYW5ndWxhci1zcGlubmVyL2FuZ3VsYXItc3Bpbm5lci5qc1xuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 7 */
/***/ function(module, exports) {

	eval("/*\r\n * angular-auto-validate - v1.19.0 - 2015-10-25\r\n * https://github.com/jonsamwell/angular-auto-validate\r\n * Copyright (c) 2015 Jon Samwell (http://www.jonsamwell.com)\r\n */\r\n(function (String, angular) {\n    'use strict';\n\r\nangular.module('jcs-autoValidate', []);\n\r\nfunction ValidatorFn() {\n  var elementStateModifiers = {},\n    enableValidElementStyling = true,\n    enableInvalidElementStyling = true,\n    validationEnabled = true,\n\n    toBoolean = function (value) {\n      var v;\n      if (value && value.length !== 0) {\n        v = value.toLowerCase();\n        value = !(v === 'f' || v === '0' || v === 'false');\n      } else {\n        value = false;\n      }\n\n      return value;\n    },\n\n    getAttributeValue = function (el, attrName) {\n      var val;\n\n      if (el !== undefined) {\n        val = el.attr(attrName) || el.attr('data-' + attrName);\n      }\n\n      return val;\n    },\n\n    attributeExists = function (el, attrName) {\n      var exists;\n\n      if (el !== undefined) {\n        exists = el.attr(attrName) !== undefined || el.attr('data-' + attrName) !== undefined;\n      }\n\n      return exists;\n    },\n\n    getBooleanAttributeValue = function (el, attrName) {\n      return toBoolean(getAttributeValue(el, attrName));\n    },\n\n    validElementStylingEnabled = function (el) {\n      return enableValidElementStyling && !getBooleanAttributeValue(el, 'disable-valid-styling');\n    },\n\n    autoValidateEnabledOnControl = function (el) {\n      return !getBooleanAttributeValue(el, 'disable-auto-validate');\n    },\n\n    invalidElementStylingEnabled = function (el) {\n      return enableInvalidElementStyling && !getBooleanAttributeValue(el, 'disable-invalid-styling');\n    };\n\n  /**\n   * @ngdoc function\n   * @name validator#enable\n   * @methodOf validator\n   *\n   * @description\n   * By default auto validate will validate all forms and elements with an ngModel directive on.  By\n   * setting enabled to false you will explicitly have to opt in to enable validation on forms and child\n   * elements.\n   *\n   * Note: this can be overridden by add the 'auto-validate-enabled=\"true/false' attribute to a form.\n   *\n   * Example:\n   * <pre>\n   *  app.config(function (validator) {\n   *    validator.enable(false);\n   *  });\n   * </pre>\n   *\n   * @param {Boolean} isEnabled true to enable, false to disable.\n   */\n  this.enable = function (isEnabled) {\n    validationEnabled = isEnabled;\n  };\n\n  /**\n   * @ngdoc function\n   * @name validator#isEnabled\n   * @methodOf validator\n   *\n   * @description\n   * Returns true if the library is enabeld.\n   *\n   * @return {Boolean} true if enabled, otherwise false.\n   */\n  this.isEnabled = function () {\n    return validationEnabled;\n  };\n\n  /**\n   * @ngdoc function\n   * @name validator#setDefaultElementModifier\n   * @methodOf validator\n   *\n   * @description\n   * Sets the default element modifier that will be used by the validator\n   * to change an elements UI state.  Please ensure the modifier has been registered\n   * before setting it as default.\n   *\n   * Note: this can be changed by setting the\n   * element modifier attribute on the input element 'data-element-modifier=\"myCustomModifier\"'\n   *\n   * Example:\n   * <pre>\n   *  app.config(function (validator) {\n   *    validator.setDefaultElementModifier('myCustomModifier');\n   *  });\n   * </pre>\n   *\n   * @param {string} key The key name of the modifier.\n   */\n  this.setDefaultElementModifier = function (key) {\n    if (elementStateModifiers[key] === undefined) {\n      throw new Error('Element modifier not registered: ' + key);\n    }\n\n    this.defaultElementModifier = key;\n  };\n\n  /**\n   * @ngdoc function\n   * @name validator#registerDomModifier\n   * @methodOf validator\n   *\n   * @description\n   * Registers an object that adheres to the elementModifier interface and is\n   * able to modifier an elements dom so that appears valid / invalid for a specific\n   * scenario i.e. the Twitter Bootstrap css framework, Foundation CSS framework etc.\n   *\n   * Example:\n   * <pre>\n   *  app.config(function (validator) {\n   *    validator.registerDomModifier('customDomModifier', {\n   *      makeValid: function (el) {\n   *          el.removeClass(el, 'invalid');\n   *          el.addClass(el, 'valid');\n   *      },\n   *      makeInvalid: function (el, err, domManipulator) {\n   *          el.removeClass(el, 'valid');\n   *          el.addClass(el, 'invalid');\n   *      }\n   *    });\n   *  });\n   * </pre>\n   *\n   * @param {string} key The key name of the modifier\n   * @param {object} modifier An object which implements the elementModifier interface\n   */\n  this.registerDomModifier = function (key, modifier) {\n    elementStateModifiers[key] = modifier;\n  };\n\n  /**\n   * @ngdoc function\n   * @name validator#setErrorMessageResolver\n   * @methodOf validator\n   *\n   * @description\n   * Registers an object that adheres to the elementModifier interface and is\n   * able to modifier an elements dom so that appears valid / invalid for a specific\n   * scenario i.e. the Twitter Bootstrap css framework, Foundation CSS framework etc.\n   *\n   * Example:\n   * <pre>\n   *  app.config(function (validator) {\n   *    validator.setErrorMessageResolver(function (errorKey, el) {\n   *      var defer = $q.defer();\n   *      // resolve the correct error from the given key and resolve the returned promise.\n   *      return defer.promise();\n   *    });\n   *  });\n   * </pre>\n   *\n   * @param {function} resolver A method that returns a promise with the resolved error message in.\n   */\n  this.setErrorMessageResolver = function (resolver) {\n    this.errorMessageResolver = resolver;\n  };\n\n  /**\n   * @ngdoc function\n   * @name validator#getErrorMessage\n   * @methodOf validator\n   *\n   * @description\n   * Resolves the error message for the given error type.\n   *\n   * @param {String} errorKey The error type.\n   * @param {Element} el The UI element that is the focus of the error.\n   * It is provided as the error message may need information from the element i.e. ng-min (the min allowed value).\n   */\n  this.getErrorMessage = function (errorKey, el) {\n    var defer;\n    if (this.errorMessageResolver === undefined) {\n      throw new Error('Please set an error message resolver via the setErrorMessageResolver function before attempting to resolve an error message.');\n    }\n\n    if (attributeExists(el, 'disable-validation-message')) {\n      defer = angular.injector(['ng']).get('$q').defer();\n      defer.resolve('');\n      return defer.promise;\n    } else {\n      return this.errorMessageResolver(errorKey, el);\n    }\n  };\n\n  /**\n   * @ngdoc function\n   * @name validator#setValidElementStyling\n   * @methodOf validator\n   *\n   * @description\n   * Globally enables valid element visual styling.  This is enabled by default.\n   *\n   * @param {Boolean} enabled True to enable style otherwise false.\n   */\n  this.setValidElementStyling = function (enabled) {\n    enableValidElementStyling = enabled;\n  };\n\n  /**\n   * @ngdoc function\n   * @name validator#setInvalidElementStyling\n   * @methodOf validator\n   *\n   * @description\n   * Globally enables invalid element visual styling.  This is enabled by default.\n   *\n   * @param {Boolean} enabled True to enable style otherwise false.\n   */\n  this.setInvalidElementStyling = function (enabled) {\n    enableInvalidElementStyling = enabled;\n  };\n\n  this.getDomModifier = function (el) {\n    var modifierKey = (el !== undefined ? el.attr('element-modifier') : this.defaultElementModifier) ||\n      (el !== undefined ? el.attr('data-element-modifier') : this.defaultElementModifier) ||\n      this.defaultElementModifier;\n\n    if (modifierKey === undefined) {\n      throw new Error('Please set a default dom modifier via the setDefaultElementModifier method on the validator class.');\n    }\n\n    return elementStateModifiers[modifierKey];\n  };\n\n  this.makeValid = function (el) {\n    if (autoValidateEnabledOnControl(el)) {\n      if (validElementStylingEnabled(el)) {\n        this.getDomModifier(el).makeValid(el);\n      } else {\n        this.makeDefault(el);\n      }\n    }\n  };\n\n  this.makeInvalid = function (el, errorMsg) {\n    if (autoValidateEnabledOnControl(el)) {\n      if (invalidElementStylingEnabled(el)) {\n        this.getDomModifier(el).makeInvalid(el, errorMsg);\n      } else {\n        this.makeDefault(el);\n      }\n    }\n  };\n\n  this.makeDefault = function (el) {\n    if (autoValidateEnabledOnControl(el)) {\n      var dm = this.getDomModifier(el);\n      if (dm.makeDefault) {\n        dm.makeDefault(el);\n      }\n    }\n  };\n\n  this.defaultFormValidationOptions = {\n    forceValidation: false,\n    disabled: false,\n    validateNonVisibleControls: false,\n    removeExternalValidationErrorsOnSubmit: true,\n    validateOnFormSubmit: false\n  };\n\n  this.$get = [\n    function () {\n      return this;\n    }\n  ];\n}\n\nangular.module('jcs-autoValidate').provider('validator', ValidatorFn);\n\r\nfunction Bootstrap3ElementModifierFn($log) {\n  var reset = function (el) {\n      angular.forEach(el.find('span'), function (spanEl) {\n        spanEl = angular.element(spanEl);\n        if (spanEl.hasClass('error-msg') || spanEl.hasClass('form-control-feedback') || spanEl.hasClass('control-feedback')) {\n          spanEl.remove();\n        }\n      });\n\n      el.removeClass('has-success has-error has-feedback');\n    },\n    findWithClassElementAsc = function (el, klass) {\n      var returnEl,\n        parent = el;\n      for (var i = 0; i <= 10; i += 1) {\n        if (parent !== undefined && parent.hasClass(klass)) {\n          returnEl = parent;\n          break;\n        } else if (parent !== undefined) {\n          parent = parent.parent();\n        }\n      }\n\n      return returnEl;\n    },\n\n    findWithClassElementDesc = function (el, klass) {\n      var child;\n      for (var i = 0; i < el.children.length; i += 1) {\n        child = el.children[i];\n        if (child !== undefined && angular.element(child).hasClass(klass)) {\n          break;\n        } else if (child.children !== undefined) {\n          child = findWithClassElementDesc(child, klass);\n          if (child.length > 0) {\n            break;\n          }\n        }\n      }\n\n      return angular.element(child);\n    },\n\n    findFormGroupElement = function (el) {\n      return findWithClassElementAsc(el, 'form-group');\n    },\n\n    findInputGroupElement = function (el) {\n      return findWithClassElementDesc(el, 'input-group');\n    },\n\n    insertAfter = function (referenceNode, newNode) {\n      referenceNode[0].parentNode.insertBefore(newNode[0], referenceNode[0].nextSibling);\n    },\n\n    /**\n     * @ngdoc property\n     * @name bootstrap3ElementModifier#addValidationStateIcons\n     * @propertyOf bootstrap3ElementModifier\n     * @returns {bool} True if an state icon will be added to the element in the valid and invalid control\n     * states.  The default is false.\n     */\n    addValidationStateIcons = false,\n\n    /**\n     * @ngdoc function\n     * @name bootstrap3ElementModifier#enableValidationStateIcons\n     * @methodOf bootstrap3ElementModifier\n     *\n     * @description\n     * Makes an element appear invalid by apply an icon to the input element.\n     *\n     * @param {bool} enable - True to enable the icon otherwise false.\n     */\n    enableValidationStateIcons = function (enable) {\n      addValidationStateIcons = enable;\n    },\n\n    /**\n     * @ngdoc function\n     * @name bootstrap3ElementModifier#makeValid\n     * @methodOf bootstrap3ElementModifier\n     *\n     * @description\n     * Makes an element appear valid by apply bootstrap 3 specific styles and child elements. If the service\n     * property 'addValidationStateIcons' is true it will also append validation glyphicon to the element.\n     * See: http://getbootstrap.com/css/#forms-control-validation\n     *\n     * @param {Element} el - The input control element that is the target of the validation.\n     */\n    makeValid = function (el) {\n      var frmGroupEl = findFormGroupElement(el),\n        inputGroupEl;\n\n      if (frmGroupEl) {\n        reset(frmGroupEl);\n        inputGroupEl = findInputGroupElement(frmGroupEl[0]);\n        frmGroupEl.addClass('has-success ' + (inputGroupEl.length > 0 || addValidationStateIcons === false ? '' : 'has-feedback'));\n        if (addValidationStateIcons) {\n          var iconElText = '<span class=\"glyphicon glyphicon-ok form-control-feedback\"></span>';\n          if (inputGroupEl.length > 0) {\n            iconElText = iconElText.replace('form-', '');\n            iconElText = '<span class=\"input-group-addon control-feedback\">' + iconElText + '</span';\n          }\n\n          insertAfter(el, angular.element(iconElText));\n        }\n      } else {\n        $log.error('Angular-auto-validate: invalid bs3 form structure elements must be wrapped by a form-group class');\n      }\n    },\n\n    /**\n     * @ngdoc function\n     * @name bootstrap3ElementModifier#makeInvalid\n     * @methodOf bootstrap3ElementModifier\n     *\n     * @description\n     * Makes an element appear invalid by apply bootstrap 3 specific styles and child elements. If the service\n     * property 'addValidationStateIcons' is true it will also append validation glyphicon to the element.\n     * See: http://getbootstrap.com/css/#forms-control-validation\n     *\n     * @param {Element} el - The input control element that is the target of the validation.\n     */\n    makeInvalid = function (el, errorMsg) {\n      var frmGroupEl = findFormGroupElement(el),\n        helpTextEl = angular.element('<span class=\"help-block has-error error-msg\">' + errorMsg + '</span>'),\n        inputGroupEl;\n\n      if (frmGroupEl) {\n        reset(frmGroupEl);\n        inputGroupEl = findInputGroupElement(frmGroupEl[0]);\n        frmGroupEl.addClass('has-error ' + (inputGroupEl.length > 0 || addValidationStateIcons === false ? '' : 'has-feedback'));\n        insertAfter(inputGroupEl.length > 0 ? inputGroupEl : getCorrectElementToPlaceErrorElementAfter(el), helpTextEl);\n        if (addValidationStateIcons) {\n          var iconElText = '<span class=\"glyphicon glyphicon-remove form-control-feedback\"></span>';\n          if (inputGroupEl.length > 0) {\n            iconElText = iconElText.replace('form-', '');\n            iconElText = '<span class=\"input-group-addon control-feedback\">' + iconElText + '</span';\n          }\n\n          insertAfter(getCorrectElementToPlaceErrorElementAfter(el), angular.element(iconElText));\n        }\n      } else {\n        $log.error('Angular-auto-validate: invalid bs3 form structure elements must be wrapped by a form-group class');\n      }\n    },\n\n    getCorrectElementToPlaceErrorElementAfter = function (el) {\n      var correctEl = el,\n        elType = el[0].type ? el[0].type.toLowerCase() : '';\n\n      if ((elType === 'checkbox' || elType === 'radio') && el.parent()[0].nodeName.toLowerCase() === 'label') {\n        correctEl = el.parent();\n      }\n\n      return correctEl;\n    },\n\n    /**\n     * @ngdoc function\n     * @name bootstrap3ElementModifier#makeDefault\n     * @methodOf bootstrap3ElementModifier\n     *\n     * @description\n     * Makes an element appear in its default visual state by apply bootstrap 3 specific styles and child elements.\n     *\n     * @param {Element} el - The input control element that is the target of the validation.\n     */\n    makeDefault = function (el) {\n      var frmGroupEl = findFormGroupElement(el);\n      if (frmGroupEl) {\n        reset(frmGroupEl);\n      } else {\n        $log.error('Angular-auto-validate: invalid bs3 form structure elements must be wrapped by a form-group class');\n      }\n    };\n\n  return {\n    makeValid: makeValid,\n    makeInvalid: makeInvalid,\n    makeDefault: makeDefault,\n    enableValidationStateIcons: enableValidationStateIcons,\n    key: 'bs3'\n  };\n}\n\nBootstrap3ElementModifierFn.$inject = [\n  '$log'\n];\n\nangular.module('jcs-autoValidate').factory('bootstrap3ElementModifier', Bootstrap3ElementModifierFn);\n\r\n/*\n * Taken from https://github.com/angular/angular.js/issues/2690#issue-14462164 (with added tests of course!)\n */\nfunction JCSDebounceFn($timeout) {\n  var debounce = function (fn, timeout, apply) {\n    timeout = angular.isUndefined(timeout) ? 0 : timeout;\n    apply = angular.isUndefined(apply) ? true : apply; // !!default is true! most suitable to my experience\n    var nthCall = 0;\n    return function () { // intercepting fn\n      var that = this;\n      var argz = arguments;\n      nthCall += 1;\n      var later = (function (version) {\n        return function () {\n          if (version === nthCall) {\n            return fn.apply(that, argz);\n          }\n        };\n      })(nthCall);\n\n      return $timeout(later, timeout, apply);\n    };\n  };\n\n  return {\n    debounce: debounce\n  };\n}\n\nJCSDebounceFn.$inject = [\n  '$timeout'\n];\n\nangular.module('jcs-autoValidate').factory('jcs-debounce', JCSDebounceFn);\n\r\n/**\n * Replaces string placeholders with corresponding template string\n */\nif (!('format' in String.prototype)) {\n  String.prototype.format = function () {\n    var args = arguments;\n    return this.replace(/{(\\d+)}/g, function (match, number) {\n      return typeof args[number] !== undefined ? args[number] : match;\n    });\n  };\n}\n\nangular.autoValidate = angular.autoValidate || {\n  errorMessages: {}\n};\n\nangular.autoValidate.errorMessages['default'] = {\n  defaultMsg: 'Please add error message for {0}',\n  email: 'Please enter a valid email address',\n  minlength: 'Please enter at least {0} characters',\n  maxlength: 'You have entered more than the maximum {0} characters',\n  min: 'Please enter the minimum number of {0}',\n  max: 'Please enter the maximum number of {0}',\n  required: 'This field is required',\n  date: 'Please enter a valid date',\n  pattern: 'Please ensure the entered information adheres to this pattern {0}',\n  number: 'Please enter a valid number',\n  url: 'Please enter a valid URL in the format of http(s)://www.google.com'\n};\n\nfunction DefaultErrorMessageResolverFn($q, $http) {\n  var currentCulture = 'default',\n\n    i18nFileRootPath = 'js/angular-auto-validate/dist/lang',\n\n    cultureRetrievalPromise,\n\n    loadRemoteCulture = function (culture) {\n      cultureRetrievalPromise = $http.get('{0}/jcs-auto-validate_{1}.json'.format(i18nFileRootPath, culture.toLowerCase()));\n      return cultureRetrievalPromise;\n    },\n\n    /**\n     * @ngdoc function\n     * @name defaultErrorMessageResolver#setI18nFileRootPath\n     * @methodOf defaultErrorMessageResolver\n     *\n     * @description\n     * Set the root path to the il8n files on the server\n     *\n     * @param {String} rootPath - The root path on the server to the il8n file - this defaults\n     * to 'js/angular-auto-validate/lang/'\n     */\n    setI18nFileRootPath = function (rootPath) {\n      i18nFileRootPath = rootPath;\n    },\n\n    /**\n     * @ngdoc function\n     * @name defaultErrorMessageResolver#setCulture\n     * @methodOf defaultErrorMessageResolver\n     *\n     * @description\n     * Set the culture for the error messages by loading an the correct culture resource file.\n     *\n     * @param {String} culture - The new culture in the format of 'en-gb' etc.\n     * @param {Function} cultureLoadingFn - A optional function to load the culture resolve which should\n     * return a promise which is resolved with the culture errorMessage object.  If a function is not specified\n     * the culture file is loaded from the **i18nFileRootPath**.\n     * @returns {Promise} - A promise which is resolved with the loaded culture error messages object.\n     */\n    setCulture = function (culture, cultureLoadingFn) {\n      var defer = $q.defer();\n      cultureLoadingFn = cultureLoadingFn || loadRemoteCulture;\n      currentCulture = culture.toLowerCase();\n      if (angular.autoValidate.errorMessages[currentCulture] === undefined) {\n        cultureRetrievalPromise = cultureLoadingFn(culture);\n        cultureRetrievalPromise.then(function (response) {\n          cultureRetrievalPromise = undefined;\n          angular.autoValidate.errorMessages[currentCulture] = response.data;\n          defer.resolve(angular.autoValidate.errorMessages[currentCulture]);\n        }, function (err) {\n          angular.autoValidate.errorMessages[currentCulture] = {\n            defaultMsg: 'Loading culture failed!'\n          };\n          cultureRetrievalPromise = null;\n          defer.reject(err);\n        });\n      } else {\n        defer.resolve(angular.autoValidate.errorMessages[currentCulture]);\n      }\n\n      return defer.promise;\n    },\n\n    getErrorMessages = function (culture) {\n      var defer = $q.defer();\n      culture = culture === undefined ? currentCulture : culture.toLowerCase();\n      if (cultureRetrievalPromise !== undefined) {\n        cultureRetrievalPromise.then(function () {\n          defer.resolve(angular.autoValidate.errorMessages[culture]);\n        }, function (err) {\n          defer.reject(err);\n        });\n      } else {\n        defer.resolve(angular.autoValidate.errorMessages[culture]);\n      }\n      return defer.promise;\n    },\n\n    getMessageTypeOverride = function (errorType, el) {\n      var overrideKey;\n\n      if (el) {\n        // try and find an attribute which overrides the given error type in the form of errorType-err-type=\"someMsgKey\"\n        errorType += '-err-type';\n\n\n        overrideKey = el.attr('ng-' + errorType);\n        if (overrideKey === undefined) {\n          overrideKey = el.attr('data-ng-' + errorType) || el.attr(errorType);\n        }\n\n        if (overrideKey) {\n          overrideKey = overrideKey.replace(/[\\W]/g, '');\n        }\n      }\n\n      return overrideKey;\n    },\n\n    /**\n     * @ngdoc function\n     * @name defaultErrorMessageResolver#resolve\n     * @methodOf defaultErrorMessageResolver\n     *\n     * @description\n     * Resolves a validate error type into a user validation error message\n     *\n     * @param {String} errorType - The type of validation error that has occurred.\n     * @param {Element} el - The input element that is the source of the validation error.\n     * @returns {Promise} A promise that is resolved when the validation message has been produced.\n     */\n    resolve = function (errorType, el) {\n      var defer = $q.defer(),\n        errMsg,\n        parameters = [],\n        parameter,\n        messageTypeOverride;\n\n      if (cultureRetrievalPromise !== undefined) {\n        cultureRetrievalPromise.then(function () {\n          resolve(errorType, el).then(function (msg) {\n            defer.resolve(msg);\n          });\n        });\n      } else {\n        errMsg = angular.autoValidate.errorMessages[currentCulture][errorType];\n        messageTypeOverride = getMessageTypeOverride(errorType, el);\n        if (messageTypeOverride) {\n          errMsg = angular.autoValidate.errorMessages[currentCulture][messageTypeOverride];\n        }\n\n        if (errMsg === undefined && messageTypeOverride !== undefined) {\n          errMsg = angular.autoValidate.errorMessages[currentCulture].defaultMsg.format(messageTypeOverride);\n        } else if (errMsg === undefined) {\n          errMsg = angular.autoValidate.errorMessages[currentCulture].defaultMsg.format(errorType);\n        }\n\n        if (el && el.attr) {\n          try {\n            parameter = el.attr('ng-' + errorType);\n            if (parameter === undefined) {\n              parameter = el.attr('data-ng-' + errorType) || el.attr(errorType);\n            }\n\n            parameters.push(parameter || '');\n\n            errMsg = errMsg.format(parameters);\n          } catch (e) {}\n        }\n\n        defer.resolve(errMsg);\n      }\n\n      return defer.promise;\n    };\n\n  return {\n    setI18nFileRootPath: setI18nFileRootPath,\n    setCulture: setCulture,\n    getErrorMessages: getErrorMessages,\n    resolve: resolve\n  };\n}\n\nDefaultErrorMessageResolverFn.$inject = [\n  '$q',\n  '$http'\n];\n\nangular.module('jcs-autoValidate').factory('defaultErrorMessageResolver', DefaultErrorMessageResolverFn);\n\r\nfunction Foundation5ElementModifierFn() {\n  var reset = function (el, inputEl) {\n      angular.forEach(el.find('small'), function (smallEl) {\n        if (angular.element(smallEl).hasClass('error')) {\n          angular.element(smallEl).remove();\n        }\n      });\n\n      inputEl.removeClass('error');\n    },\n    findParentColumn = function (el) {\n      var parent = el;\n      for (var i = 0; i <= 3; i += 1) {\n        if (parent !== undefined && (parent.hasClass('columns') || parent.hasClass('column'))) {\n          break;\n        } else if (parent !== undefined) {\n          parent = parent.parent();\n        }\n      }\n\n      return parent;\n    },\n\n    /**\n     * @ngdoc function\n     * @name foundation5ElementModifier#makeValid\n     * @methodOf foundation5ElementModifier\n     *\n     * @description\n     * Makes an element appear valid by apply Foundation 5 specific styles and child elements.\n     * See: http://foundation.zurb.com/docs/components/forms.html\n     *\n     * @param {Element} el - The input control element that is the target of the validation.\n     */\n    makeValid = function (el) {\n      var parentColumn = findParentColumn(el);\n      reset(parentColumn && parentColumn.length > 0 ? parentColumn : el, el);\n    },\n\n    /**\n     * @ngdoc function\n     * @name foundation5ElementModifier#makeInvalid\n     * @methodOf foundation5ElementModifier\n     *\n     * @description\n     * Makes an element appear invalid by apply Foundation 5 specific styles and child elements.\n     * See: http://foundation.zurb.com/docs/components/forms.html\n     *\n     * @param {Element} el - The input control element that is the target of the validation.\n     */\n    makeInvalid = function (el, errorMsg) {\n      var parentColumn = findParentColumn(el),\n        helpTextEl;\n      reset(parentColumn || el, el);\n      el.addClass('error');\n      if (parentColumn) {\n        helpTextEl = angular.element('<small class=\"error\">' + errorMsg + '</small>');\n        parentColumn.append(helpTextEl);\n      }\n    },\n\n    /**\n     * @ngdoc function\n     * @name foundation5ElementModifier#makeDefault\n     * @methodOf foundation5ElementModifier\n     *\n     * @description\n     * Makes an element appear in its default visual state by apply foundation 5 specific styles and child elements.\n     *\n     * @param {Element} el - The input control element that is the target of the validation.\n     */\n    makeDefault = function (el) {\n      makeValid(el);\n    };\n\n  return {\n    makeValid: makeValid,\n    makeInvalid: makeInvalid,\n    makeDefault: makeDefault,\n    key: 'foundation5'\n  };\n}\n\nangular.module('jcs-autoValidate').factory('foundation5ElementModifier', Foundation5ElementModifierFn);\n\r\nfunction ElementUtilsFn() {\n  var isElementVisible = function (el) {\n    return el[0].offsetWidth > 0 && el[0].offsetHeight > 0;\n  };\n\n  return {\n    isElementVisible: isElementVisible\n  };\n}\n\nfunction ValidationManagerFn(validator, elementUtils) {\n  var elementTypesToValidate = ['input', 'textarea', 'select', 'form'],\n\n    elementIsVisible = function (el) {\n      return elementUtils.isElementVisible(el);\n    },\n\n    getFormOptions = function (el) {\n      var frmCtrl = angular.element(el).controller('form'),\n        options;\n\n      if (frmCtrl !== undefined && frmCtrl !== null) {\n        options = frmCtrl.autoValidateFormOptions;\n      } else {\n        options = validator.defaultFormValidationOptions;\n      }\n\n      return options;\n    },\n\n    /**\n     * Only validate if the element is present, it is visible, if it is not a comment,\n     * it is either a valid user input control (input, select, textare, form) or\n     * it is a custom control register by the developer.\n     * @param el\n     * @param formOptions The validation options of the parent form\n     * @returns {boolean} true to indicate it should be validated\n     */\n    shouldValidateElement = function (el, formOptions, formSubmitted) {\n      var elementExists = el && el.length > 0,\n        isElementAComment = elementExists && el[0].nodeName.toLowerCase() === '#comment',\n        correctVisibilityToValidate,\n        correctTypeToValidate,\n        correctPhaseToValidate;\n\n      if (elementExists && isElementAComment === false) {\n        correctVisibilityToValidate = elementIsVisible(el) || formOptions.validateNonVisibleControls;\n        correctTypeToValidate = elementTypesToValidate.indexOf(el[0].nodeName.toLowerCase()) > -1 ||\n          el[0].hasAttribute('register-custom-form-control');\n        correctPhaseToValidate = formOptions.validateOnFormSubmit === false ||\n          (formOptions.validateOnFormSubmit === true && formSubmitted === true);\n      }\n\n      return elementExists && !isElementAComment && correctVisibilityToValidate && correctTypeToValidate && correctPhaseToValidate;\n\n    },\n\n    /**\n     * @ngdoc validateElement\n     * @name validation#validateElement\n     * @param {object} modelCtrl holds the information about the element e.g. $invalid, $valid\n     * @param {options}\n     *  - forceValidation if set to true forces the validation even if the element is pristine\n     *  - disabled if set to true forces the validation is disabled and will return true\n     *  - validateNonVisibleControls if set to true forces the validation of non visible element i.e. display:block\n     * @description\n     * Validate the form element and make invalid/valid element model status.\n     *\n     * As of v1.17.22:\n     * BREAKING CHANGE to validateElement on the validationManger.  The third parameter is now the parent form's\n     * autoValidateFormOptions object on the form controller.  This can be left blank and will be found by the\n     * validationManager.\n     */\n    validateElement = function (modelCtrl, el, options) {\n      var isValid = true,\n        frmOptions = options || getFormOptions(el),\n        needsValidation = modelCtrl.$pristine === false || frmOptions.forceValidation,\n        errorType,\n        findErrorType = function ($errors) {\n          var keepGoing = true,\n            errorTypeToReturn;\n          angular.forEach($errors, function (status, errortype) {\n            if (keepGoing && status) {\n              keepGoing = false;\n              errorTypeToReturn = errortype;\n            }\n          });\n\n          return errorTypeToReturn;\n        };\n\n      if (frmOptions.disabled === false) {\n        if ((frmOptions.forceValidation ||\n            (shouldValidateElement(el, frmOptions, frmOptions.getFormController().$submitted) &&\n              modelCtrl &&\n              needsValidation))) {\n          isValid = !modelCtrl.$invalid;\n\n          if (frmOptions.removeExternalValidationErrorsOnSubmit && modelCtrl.removeAllExternalValidation) {\n            modelCtrl.removeAllExternalValidation();\n          }\n\n          if (isValid) {\n            validator.makeValid(el);\n          } else {\n            errorType = findErrorType(modelCtrl.$errors || modelCtrl.$error);\n            if (errorType === undefined) {\n              // we have a weird situation some users are encountering where a custom control\n              // is valid but the ngModel is report it isn't and thus no valid error type can be found\n              isValid = true;\n            } else {\n              validator.getErrorMessage(errorType, el).then(function (errorMsg) {\n                validator.makeInvalid(el, errorMsg);\n              });\n            }\n          }\n        }\n      }\n\n      return isValid;\n    },\n\n    resetElement = function (element) {\n      validator.makeDefault(element);\n    },\n\n    resetForm = function (frmElement) {\n      angular.forEach((frmElement[0].all || frmElement[0].elements) || frmElement[0], function (element) {\n        var controller,\n          ctrlElement = angular.element(element);\n        controller = ctrlElement.controller('ngModel');\n\n        if (controller !== undefined) {\n          if (ctrlElement[0].nodeName.toLowerCase() === 'form') {\n            // we probably have a sub form\n            resetForm(ctrlElement);\n          } else {\n            controller.$setPristine();\n          }\n        }\n      });\n    },\n\n    validateForm = function (frmElement) {\n      var frmValid = true,\n        frmCtrl = frmElement ? angular.element(frmElement).controller('form') : undefined,\n        processElement = function (ctrlElement, force, formOptions) {\n          var controller, isValid, ctrlFormOptions, originalForceValue;\n\n          ctrlElement = angular.element(ctrlElement);\n          controller = ctrlElement.controller('ngModel');\n\n          if (controller !== undefined && (force || shouldValidateElement(ctrlElement, formOptions, frmCtrl.$submitted))) {\n            if (ctrlElement[0].nodeName.toLowerCase() === 'form') {\n              // we probably have a sub form\n              validateForm(ctrlElement);\n            } else {\n              // we need to get the options for the element rather than use the passed in as the\n              // element could be an ng-form and have different options to the parent form.\n              ctrlFormOptions = getFormOptions(ctrlElement);\n              originalForceValue = ctrlFormOptions.forceValidation;\n              ctrlFormOptions.forceValidation = force;\n              try {\n                isValid = validateElement(controller, ctrlElement, ctrlFormOptions);\n                frmValid = frmValid && isValid;\n              } finally {\n                ctrlFormOptions.forceValidation = originalForceValue;\n              }\n            }\n          }\n        },\n        clonedOptions;\n\n      if (frmElement === undefined || (frmCtrl !== undefined && frmCtrl.autoValidateFormOptions.disabled)) {\n        return frmElement !== undefined;\n      }\n\n      //force the validation of controls\n      clonedOptions = angular.copy(frmCtrl.autoValidateFormOptions);\n      clonedOptions.forceValidation = true;\n\n      // IE8 holds the child controls collection in the all property\n      // Firefox in the elements and chrome as a child iterator\n      angular.forEach((frmElement[0].elements || frmElement[0].all) || frmElement[0], function (ctrlElement) {\n        processElement(ctrlElement, true, clonedOptions);\n      });\n\n      // If you have a custom form control that should be validated i.e.\n      // <my-custom-element>...</my-custom-element> it will not be part of the forms\n      // HTMLFormControlsCollection and thus won't be included in the above element iteration although\n      // it will be on the Angular FormController (if it has a name attribute).  So adding the directive\n      // register-custom-form-control=\"\" to the control root and autoValidate will include it in this\n      // iteration.\n      if (frmElement[0].customHTMLFormControlsCollection) {\n        angular.forEach(frmElement[0].customHTMLFormControlsCollection, function (ctrlElement) {\n          // need to force the validation as the element might not be a known form input type\n          // so the normal validation process will ignore it.\n          processElement(ctrlElement, true, clonedOptions);\n        });\n      }\n\n      return frmValid;\n    },\n\n    setElementValidationError = function (element, errorMsgKey, errorMsg) {\n      if (errorMsgKey) {\n        validator.getErrorMessage(errorMsgKey, element).then(function (msg) {\n          validator.makeInvalid(element, msg);\n        });\n      } else {\n        validator.makeInvalid(element, errorMsg);\n      }\n    };\n\n  return {\n    setElementValidationError: setElementValidationError,\n    validateElement: validateElement,\n    validateForm: validateForm,\n    resetElement: resetElement,\n    resetForm: resetForm\n  };\n}\n\nValidationManagerFn.$inject = [\n  'validator',\n  'jcs-elementUtils'\n];\n\nangular.module('jcs-autoValidate').factory('jcs-elementUtils', ElementUtilsFn);\nangular.module('jcs-autoValidate').factory('validationManager', ValidationManagerFn);\n\r\nfunction parseBooleanAttributeValue(val, defaultValue) {\n  if ((val === undefined || val === null) && defaultValue !== undefined) {\n    return defaultValue;\n  } else {\n    return val !== 'false';\n  }\n}\n\nfunction parseOptions(ctrl, validator, attrs) {\n  var opts = ctrl.autoValidateFormOptions = ctrl.autoValidateFormOptions || angular.copy(validator.defaultFormValidationOptions);\n\n  // needed to stop circular ref in json serialisation\n  opts.getFormController = function () {\n    return ctrl;\n  };\n  opts.forceValidation = false;\n  opts.disabled = !validator.isEnabled() || parseBooleanAttributeValue(attrs.disableDynamicValidation, opts.disabled);\n  opts.validateNonVisibleControls = parseBooleanAttributeValue(attrs.validateNonVisibleControls, opts.validateNonVisibleControls);\n  opts.validateOnFormSubmit = parseBooleanAttributeValue(attrs.validateOnFormSubmit, opts.validateOnFormSubmit);\n  opts.removeExternalValidationErrorsOnSubmit = attrs.removeExternalValidationErrorsOnSubmit === undefined ?\n    opts.removeExternalValidationErrorsOnSubmit :\n    parseBooleanAttributeValue(attrs.removeExternalValidationErrorsOnSubmit, opts.removeExternalValidationErrorsOnSubmit);\n\n  // the library might be globally disabled but enabled on a particular form so check the\n  // disableDynamicValidation attribute is on the form\n  if (validator.isEnabled() === false && attrs.disableDynamicValidation === 'false') {\n    opts.disabled = false;\n  }\n}\n\nangular.module('jcs-autoValidate').directive('form', [\n  'validator',\n  function (validator) {\n    return {\n      restrict: 'E',\n      require: 'form',\n      priority: 9999,\n      compile: function () {\n        return {\n          pre: function (scope, element, attrs, ctrl) {\n            parseOptions(ctrl, validator, attrs);\n          }\n        };\n      }\n    };\n  }\n]);\n\nangular.module('jcs-autoValidate').directive('ngForm', [\n  'validator',\n  function (validator) {\n    return {\n      restrict: 'EA',\n      require: 'form',\n      priority: 9999,\n      compile: function () {\n        return {\n          pre: function (scope, element, attrs, ctrl) {\n            parseOptions(ctrl, validator, attrs);\n          }\n        };\n      }\n    };\n  }\n]);\n\r\nfunction FormResetDirectiveFn(validationManager) {\n  return {\n    restrict: 'E',\n    link: function (scope, el) {\n      var formController = el.controller('form');\n\n      function resetFn() {\n        validationManager.resetForm(el);\n        if (formController.$setPristine) {\n          formController.$setPristine();\n        }\n\n        if (formController.$setUntouched) {\n          formController.$setUntouched();\n        }\n      }\n\n      if (formController !== undefined &&\n        formController.autoValidateFormOptions &&\n        formController.autoValidateFormOptions.disabled === false) {\n        el.on('reset', resetFn);\n\n        scope.$on('$destroy', function () {\n          el.off('reset', resetFn);\n        });\n      }\n    }\n  };\n}\n\nFormResetDirectiveFn.$inject = [\n  'validationManager'\n];\n\nangular.module('jcs-autoValidate').directive('form', FormResetDirectiveFn);\n\r\nfunction RegisterCustomFormControlFn() {\n  var findParentForm = function (el) {\n    var parent = el;\n    for (var i = 0; i <= 50; i += 1) {\n      if (parent !== undefined && parent.nodeName.toLowerCase() === 'form') {\n        break;\n      } else if (parent !== undefined) {\n        parent = angular.element(parent).parent()[0];\n      }\n    }\n\n    return parent;\n  };\n\n  return {\n    restrict: 'A',\n    link: function (scope, element) {\n      var frmEl = findParentForm(element.parent()[0]);\n      if (frmEl) {\n        frmEl.customHTMLFormControlsCollection = frmEl.customHTMLFormControlsCollection || [];\n        frmEl.customHTMLFormControlsCollection.push(element[0]);\n      }\n    }\n  };\n}\n\nangular.module('jcs-autoValidate').directive('registerCustomFormControl', RegisterCustomFormControlFn);\n\r\nfunction SubmitDecorator($delegate, $parse, validationManager) {\n  $delegate[0].compile = function ($element, attrs) {\n    var fn = $parse(attrs.ngSubmit),\n      force = attrs.ngSubmitForce === 'true';\n\n    return function (scope, element) {\n      var formController = element.controller('form'),\n        resetListenerOffFn;\n\n      function handlerFn(event) {\n        scope.$apply(function () {\n          if (formController !== undefined &&\n            formController !== null &&\n            formController.autoValidateFormOptions &&\n            formController.autoValidateFormOptions.disabled === true) {\n            fn(scope, {\n              $event: event\n            });\n          } else {\n            if (formController.$setSubmitted === undefined) {\n              // we probably have angular <= 1.2\n              formController.$submitted = true;\n            }\n\n            if (validationManager.validateForm(element) || force === true) {\n              fn(scope, {\n                $event: event\n              });\n            }\n          }\n        });\n      }\n\n      function resetFormFn() {\n        if (element[0].reset) {\n          element[0].reset();\n        } else {\n          validationManager.resetForm(element);\n        }\n      }\n\n      if (formController && formController.autoValidateFormOptions) {\n        // allow the form to be reset programatically or via raising the event\n        // form:formName:reset\n        formController.autoValidateFormOptions.resetForm = resetFormFn;\n        if (formController.$name !== undefined && formController.$name !== '') {\n          resetListenerOffFn = scope.$on('form:' + formController.$name + ':reset', resetFormFn);\n        }\n      }\n\n      element.on('submit', handlerFn);\n      scope.$on('$destroy', function () {\n        element.off('submit', handlerFn);\n        if (resetListenerOffFn) {\n          resetListenerOffFn();\n        }\n      });\n    };\n  };\n\n  return $delegate;\n}\n\nSubmitDecorator.$inject = [\n  '$delegate',\n  '$parse',\n  'validationManager'\n];\n\nfunction ProviderFn($provide) {\n  $provide.decorator('ngSubmitDirective', SubmitDecorator);\n}\n\nProviderFn.$inject = [\n  '$provide'\n];\n\nangular.module('jcs-autoValidate').config(ProviderFn);\n\r\nangular.module('jcs-autoValidate').config(['$provide',\n  function ($provide) {\n    $provide.decorator('ngModelDirective', [\n      '$timeout',\n      '$delegate',\n      'validationManager',\n      'jcs-debounce',\n      function ($timeout, $delegate, validationManager, debounce) {\n        var directive = $delegate[0],\n          link = directive.link || directive.compile;\n\n        directive.compile = function (el) {\n          var supportsNgModelOptions = angular.version.major >= 1 && angular.version.minor >= 3,\n            originalLink = link;\n\n          // in the RC of 1.3 there is no directive.link only the directive.compile which\n          // needs to be invoked to get at the link functions.\n          if (supportsNgModelOptions && angular.isFunction(link)) {\n            originalLink = link(el);\n          }\n\n          return {\n            pre: function (scope, element, attrs, ctrls) {\n              var ngModelCtrl = ctrls[0],\n                frmCtrl = ctrls[1],\n                ngModelOptions = attrs.ngModelOptions === undefined ? undefined : scope.$eval(attrs.ngModelOptions),\n                setValidity = ngModelCtrl.$setValidity,\n                setPristine = ngModelCtrl.$setPristine,\n                setValidationState = debounce.debounce(function () {\n                  var validateOptions = frmCtrl !== undefined && frmCtrl !== null ? frmCtrl.autoValidateFormOptions : undefined;\n                  validationManager.validateElement(ngModelCtrl, element, validateOptions);\n                }, 100);\n\n              if (attrs.formnovalidate === undefined &&\n                (frmCtrl !== undefined && frmCtrl !== null && frmCtrl.autoValidateFormOptions &&\n                  frmCtrl.autoValidateFormOptions.disabled === false)) {\n                if (!supportsNgModelOptions || ngModelOptions === undefined || ngModelOptions.updateOn === undefined || ngModelOptions.updateOn === '') {\n                  ngModelCtrl.$setValidity = function (validationErrorKey, isValid) {\n                    setValidity.call(ngModelCtrl, validationErrorKey, isValid);\n                    setValidationState();\n                  };\n                } else {\n                  element.on(ngModelOptions.updateOn, function () {\n                    setValidationState();\n                  });\n\n                  scope.$on('$destroy', function () {\n                    element.off(ngModelOptions.updateOn);\n                  });\n                }\n\n                // We override this so we can reset the element state when it is called.\n                ngModelCtrl.$setPristine = function () {\n                  setPristine.call(ngModelCtrl);\n                  validationManager.resetElement(element);\n                };\n\n                ngModelCtrl.autoValidated = true;\n              }\n\n              ngModelCtrl.setExternalValidation = function (errorMsgKey, errorMessage, addToModelErrors) {\n                if (addToModelErrors) {\n                  var collection = ngModelCtrl.$error || ngModelCtrl.$errors;\n                  collection[errorMsgKey] = false;\n                }\n\n                ngModelCtrl.externalErrors = ngModelCtrl.externalErrors || {};\n                ngModelCtrl.externalErrors[errorMsgKey] = false;\n                validationManager.setElementValidationError(element, errorMsgKey, errorMessage);\n              };\n\n              ngModelCtrl.removeExternalValidation = function (errorMsgKey, addToModelErrors) {\n                if (addToModelErrors) {\n                  var collection = ngModelCtrl.$error || ngModelCtrl.$errors;\n                  delete collection[errorMsgKey];\n                }\n\n                if (ngModelCtrl.externalErrors) {\n                  delete ngModelCtrl.externalErrors[errorMsgKey];\n                }\n\n                validationManager.resetElement(element);\n              };\n\n              ngModelCtrl.removeAllExternalValidation = function () {\n                if (ngModelCtrl.externalErrors) {\n                  var errorCollection = ngModelCtrl.$error || ngModelCtrl.$errors;\n                  angular.forEach(ngModelCtrl.externalErrors, function (value, key) {\n                    delete errorCollection[key];\n                  });\n\n                  ngModelCtrl.externalErrors = {};\n\n                  validationManager.resetElement(element);\n                }\n              };\n\n              if (frmCtrl) {\n                frmCtrl.setExternalValidation = function (modelProperty, errorMsgKey, errorMessageOverride, addToModelErrors) {\n                  var success = false;\n                  if (frmCtrl[modelProperty]) {\n                    frmCtrl[modelProperty].setExternalValidation(errorMsgKey, errorMessageOverride, addToModelErrors);\n                    success = true;\n                  }\n\n                  return success;\n                };\n\n                frmCtrl.removeExternalValidation = function (modelProperty, errorMsgKey, errorMessageOverride, addToModelErrors) {\n                  var success = false;\n                  if (frmCtrl[modelProperty]) {\n                    frmCtrl[modelProperty].removeExternalValidation(errorMsgKey, addToModelErrors);\n                    success = true;\n                  }\n\n                  return success;\n                };\n              }\n\n              return originalLink.pre ?\n                originalLink.pre.apply(this, arguments) :\n                this;\n            },\n            post: function (scope, element, attrs, ctrls) {\n              return originalLink.post ?\n                originalLink.post.apply(this, arguments) :\n                originalLink.apply(this, arguments);\n            }\n          };\n        };\n\n        return $delegate;\n      }\n    ]);\n  }\n]);\n\r\nfunction AutoValidateRunFn(validator, defaultErrorMessageResolver, bootstrap3ElementModifier, foundation5ElementModifier) {\n  validator.setErrorMessageResolver(defaultErrorMessageResolver.resolve);\n  validator.registerDomModifier(bootstrap3ElementModifier.key, bootstrap3ElementModifier);\n  validator.registerDomModifier(foundation5ElementModifier.key, foundation5ElementModifier);\n  validator.setDefaultElementModifier(bootstrap3ElementModifier.key);\n}\n\nAutoValidateRunFn.$inject = [\n  'validator',\n  'defaultErrorMessageResolver',\n  'bootstrap3ElementModifier',\n  'foundation5ElementModifier'\n];\n\nangular.module('jcs-autoValidate').run(AutoValidateRunFn);\n\r\n}(String, angular));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2FuZ3VsYXItYXV0by12YWxpZGF0ZS9kaXN0L2pjcy1hdXRvLXZhbGlkYXRlLmpzPzliYjciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EscUJBQXFCLHdCQUF3QjtBQUM3QztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixLQUFLO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE1BQU07QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkMsRUFBRTtBQUMvQztBQUNBLHFDQUFxQyxFQUFFO0FBQ3ZDLHNEQUFzRCxFQUFFO0FBQ3hELDRDQUE0QyxFQUFFO0FBQzlDLDRDQUE0QyxFQUFFO0FBQzlDO0FBQ0E7QUFDQSwyRUFBMkUsRUFBRTtBQUM3RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLDRDQUE0QyxFQUFFLG9CQUFvQixFQUFFO0FBQ3BFO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyIsImZpbGUiOiI3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcclxuICogYW5ndWxhci1hdXRvLXZhbGlkYXRlIC0gdjEuMTkuMCAtIDIwMTUtMTAtMjVcclxuICogaHR0cHM6Ly9naXRodWIuY29tL2pvbnNhbXdlbGwvYW5ndWxhci1hdXRvLXZhbGlkYXRlXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNSBKb24gU2Ftd2VsbCAoaHR0cDovL3d3dy5qb25zYW13ZWxsLmNvbSlcclxuICovXHJcbihmdW5jdGlvbiAoU3RyaW5nLCBhbmd1bGFyKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXHJcbmFuZ3VsYXIubW9kdWxlKCdqY3MtYXV0b1ZhbGlkYXRlJywgW10pO1xuXHJcbmZ1bmN0aW9uIFZhbGlkYXRvckZuKCkge1xuICB2YXIgZWxlbWVudFN0YXRlTW9kaWZpZXJzID0ge30sXG4gICAgZW5hYmxlVmFsaWRFbGVtZW50U3R5bGluZyA9IHRydWUsXG4gICAgZW5hYmxlSW52YWxpZEVsZW1lbnRTdHlsaW5nID0gdHJ1ZSxcbiAgICB2YWxpZGF0aW9uRW5hYmxlZCA9IHRydWUsXG5cbiAgICB0b0Jvb2xlYW4gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHZhciB2O1xuICAgICAgaWYgKHZhbHVlICYmIHZhbHVlLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICB2ID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdmFsdWUgPSAhKHYgPT09ICdmJyB8fCB2ID09PSAnMCcgfHwgdiA9PT0gJ2ZhbHNlJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcblxuICAgIGdldEF0dHJpYnV0ZVZhbHVlID0gZnVuY3Rpb24gKGVsLCBhdHRyTmFtZSkge1xuICAgICAgdmFyIHZhbDtcblxuICAgICAgaWYgKGVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFsID0gZWwuYXR0cihhdHRyTmFtZSkgfHwgZWwuYXR0cignZGF0YS0nICsgYXR0ck5hbWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsO1xuICAgIH0sXG5cbiAgICBhdHRyaWJ1dGVFeGlzdHMgPSBmdW5jdGlvbiAoZWwsIGF0dHJOYW1lKSB7XG4gICAgICB2YXIgZXhpc3RzO1xuXG4gICAgICBpZiAoZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBleGlzdHMgPSBlbC5hdHRyKGF0dHJOYW1lKSAhPT0gdW5kZWZpbmVkIHx8IGVsLmF0dHIoJ2RhdGEtJyArIGF0dHJOYW1lKSAhPT0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXhpc3RzO1xuICAgIH0sXG5cbiAgICBnZXRCb29sZWFuQXR0cmlidXRlVmFsdWUgPSBmdW5jdGlvbiAoZWwsIGF0dHJOYW1lKSB7XG4gICAgICByZXR1cm4gdG9Cb29sZWFuKGdldEF0dHJpYnV0ZVZhbHVlKGVsLCBhdHRyTmFtZSkpO1xuICAgIH0sXG5cbiAgICB2YWxpZEVsZW1lbnRTdHlsaW5nRW5hYmxlZCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgcmV0dXJuIGVuYWJsZVZhbGlkRWxlbWVudFN0eWxpbmcgJiYgIWdldEJvb2xlYW5BdHRyaWJ1dGVWYWx1ZShlbCwgJ2Rpc2FibGUtdmFsaWQtc3R5bGluZycpO1xuICAgIH0sXG5cbiAgICBhdXRvVmFsaWRhdGVFbmFibGVkT25Db250cm9sID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICByZXR1cm4gIWdldEJvb2xlYW5BdHRyaWJ1dGVWYWx1ZShlbCwgJ2Rpc2FibGUtYXV0by12YWxpZGF0ZScpO1xuICAgIH0sXG5cbiAgICBpbnZhbGlkRWxlbWVudFN0eWxpbmdFbmFibGVkID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICByZXR1cm4gZW5hYmxlSW52YWxpZEVsZW1lbnRTdHlsaW5nICYmICFnZXRCb29sZWFuQXR0cmlidXRlVmFsdWUoZWwsICdkaXNhYmxlLWludmFsaWQtc3R5bGluZycpO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgKiBAbmFtZSB2YWxpZGF0b3IjZW5hYmxlXG4gICAqIEBtZXRob2RPZiB2YWxpZGF0b3JcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEJ5IGRlZmF1bHQgYXV0byB2YWxpZGF0ZSB3aWxsIHZhbGlkYXRlIGFsbCBmb3JtcyBhbmQgZWxlbWVudHMgd2l0aCBhbiBuZ01vZGVsIGRpcmVjdGl2ZSBvbi4gIEJ5XG4gICAqIHNldHRpbmcgZW5hYmxlZCB0byBmYWxzZSB5b3Ugd2lsbCBleHBsaWNpdGx5IGhhdmUgdG8gb3B0IGluIHRvIGVuYWJsZSB2YWxpZGF0aW9uIG9uIGZvcm1zIGFuZCBjaGlsZFxuICAgKiBlbGVtZW50cy5cbiAgICpcbiAgICogTm90ZTogdGhpcyBjYW4gYmUgb3ZlcnJpZGRlbiBieSBhZGQgdGhlICdhdXRvLXZhbGlkYXRlLWVuYWJsZWQ9XCJ0cnVlL2ZhbHNlJyBhdHRyaWJ1dGUgdG8gYSBmb3JtLlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKiA8cHJlPlxuICAgKiAgYXBwLmNvbmZpZyhmdW5jdGlvbiAodmFsaWRhdG9yKSB7XG4gICAqICAgIHZhbGlkYXRvci5lbmFibGUoZmFsc2UpO1xuICAgKiAgfSk7XG4gICAqIDwvcHJlPlxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzRW5hYmxlZCB0cnVlIHRvIGVuYWJsZSwgZmFsc2UgdG8gZGlzYWJsZS5cbiAgICovXG4gIHRoaXMuZW5hYmxlID0gZnVuY3Rpb24gKGlzRW5hYmxlZCkge1xuICAgIHZhbGlkYXRpb25FbmFibGVkID0gaXNFbmFibGVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAbmdkb2MgZnVuY3Rpb25cbiAgICogQG5hbWUgdmFsaWRhdG9yI2lzRW5hYmxlZFxuICAgKiBAbWV0aG9kT2YgdmFsaWRhdG9yXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGxpYnJhcnkgaXMgZW5hYmVsZC5cbiAgICpcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBlbmFibGVkLCBvdGhlcndpc2UgZmFsc2UuXG4gICAqL1xuICB0aGlzLmlzRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdmFsaWRhdGlvbkVuYWJsZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgKiBAbmFtZSB2YWxpZGF0b3Ijc2V0RGVmYXVsdEVsZW1lbnRNb2RpZmllclxuICAgKiBAbWV0aG9kT2YgdmFsaWRhdG9yXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBTZXRzIHRoZSBkZWZhdWx0IGVsZW1lbnQgbW9kaWZpZXIgdGhhdCB3aWxsIGJlIHVzZWQgYnkgdGhlIHZhbGlkYXRvclxuICAgKiB0byBjaGFuZ2UgYW4gZWxlbWVudHMgVUkgc3RhdGUuICBQbGVhc2UgZW5zdXJlIHRoZSBtb2RpZmllciBoYXMgYmVlbiByZWdpc3RlcmVkXG4gICAqIGJlZm9yZSBzZXR0aW5nIGl0IGFzIGRlZmF1bHQuXG4gICAqXG4gICAqIE5vdGU6IHRoaXMgY2FuIGJlIGNoYW5nZWQgYnkgc2V0dGluZyB0aGVcbiAgICogZWxlbWVudCBtb2RpZmllciBhdHRyaWJ1dGUgb24gdGhlIGlucHV0IGVsZW1lbnQgJ2RhdGEtZWxlbWVudC1tb2RpZmllcj1cIm15Q3VzdG9tTW9kaWZpZXJcIidcbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICogPHByZT5cbiAgICogIGFwcC5jb25maWcoZnVuY3Rpb24gKHZhbGlkYXRvcikge1xuICAgKiAgICB2YWxpZGF0b3Iuc2V0RGVmYXVsdEVsZW1lbnRNb2RpZmllcignbXlDdXN0b21Nb2RpZmllcicpO1xuICAgKiAgfSk7XG4gICAqIDwvcHJlPlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgbmFtZSBvZiB0aGUgbW9kaWZpZXIuXG4gICAqL1xuICB0aGlzLnNldERlZmF1bHRFbGVtZW50TW9kaWZpZXIgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKGVsZW1lbnRTdGF0ZU1vZGlmaWVyc1trZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRWxlbWVudCBtb2RpZmllciBub3QgcmVnaXN0ZXJlZDogJyArIGtleSk7XG4gICAgfVxuXG4gICAgdGhpcy5kZWZhdWx0RWxlbWVudE1vZGlmaWVyID0ga2V5O1xuICB9O1xuXG4gIC8qKlxuICAgKiBAbmdkb2MgZnVuY3Rpb25cbiAgICogQG5hbWUgdmFsaWRhdG9yI3JlZ2lzdGVyRG9tTW9kaWZpZXJcbiAgICogQG1ldGhvZE9mIHZhbGlkYXRvclxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogUmVnaXN0ZXJzIGFuIG9iamVjdCB0aGF0IGFkaGVyZXMgdG8gdGhlIGVsZW1lbnRNb2RpZmllciBpbnRlcmZhY2UgYW5kIGlzXG4gICAqIGFibGUgdG8gbW9kaWZpZXIgYW4gZWxlbWVudHMgZG9tIHNvIHRoYXQgYXBwZWFycyB2YWxpZCAvIGludmFsaWQgZm9yIGEgc3BlY2lmaWNcbiAgICogc2NlbmFyaW8gaS5lLiB0aGUgVHdpdHRlciBCb290c3RyYXAgY3NzIGZyYW1ld29yaywgRm91bmRhdGlvbiBDU1MgZnJhbWV3b3JrIGV0Yy5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICogPHByZT5cbiAgICogIGFwcC5jb25maWcoZnVuY3Rpb24gKHZhbGlkYXRvcikge1xuICAgKiAgICB2YWxpZGF0b3IucmVnaXN0ZXJEb21Nb2RpZmllcignY3VzdG9tRG9tTW9kaWZpZXInLCB7XG4gICAqICAgICAgbWFrZVZhbGlkOiBmdW5jdGlvbiAoZWwpIHtcbiAgICogICAgICAgICAgZWwucmVtb3ZlQ2xhc3MoZWwsICdpbnZhbGlkJyk7XG4gICAqICAgICAgICAgIGVsLmFkZENsYXNzKGVsLCAndmFsaWQnKTtcbiAgICogICAgICB9LFxuICAgKiAgICAgIG1ha2VJbnZhbGlkOiBmdW5jdGlvbiAoZWwsIGVyciwgZG9tTWFuaXB1bGF0b3IpIHtcbiAgICogICAgICAgICAgZWwucmVtb3ZlQ2xhc3MoZWwsICd2YWxpZCcpO1xuICAgKiAgICAgICAgICBlbC5hZGRDbGFzcyhlbCwgJ2ludmFsaWQnKTtcbiAgICogICAgICB9XG4gICAqICAgIH0pO1xuICAgKiAgfSk7XG4gICAqIDwvcHJlPlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgbmFtZSBvZiB0aGUgbW9kaWZpZXJcbiAgICogQHBhcmFtIHtvYmplY3R9IG1vZGlmaWVyIEFuIG9iamVjdCB3aGljaCBpbXBsZW1lbnRzIHRoZSBlbGVtZW50TW9kaWZpZXIgaW50ZXJmYWNlXG4gICAqL1xuICB0aGlzLnJlZ2lzdGVyRG9tTW9kaWZpZXIgPSBmdW5jdGlvbiAoa2V5LCBtb2RpZmllcikge1xuICAgIGVsZW1lbnRTdGF0ZU1vZGlmaWVyc1trZXldID0gbW9kaWZpZXI7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgKiBAbmFtZSB2YWxpZGF0b3Ijc2V0RXJyb3JNZXNzYWdlUmVzb2x2ZXJcbiAgICogQG1ldGhvZE9mIHZhbGlkYXRvclxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogUmVnaXN0ZXJzIGFuIG9iamVjdCB0aGF0IGFkaGVyZXMgdG8gdGhlIGVsZW1lbnRNb2RpZmllciBpbnRlcmZhY2UgYW5kIGlzXG4gICAqIGFibGUgdG8gbW9kaWZpZXIgYW4gZWxlbWVudHMgZG9tIHNvIHRoYXQgYXBwZWFycyB2YWxpZCAvIGludmFsaWQgZm9yIGEgc3BlY2lmaWNcbiAgICogc2NlbmFyaW8gaS5lLiB0aGUgVHdpdHRlciBCb290c3RyYXAgY3NzIGZyYW1ld29yaywgRm91bmRhdGlvbiBDU1MgZnJhbWV3b3JrIGV0Yy5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICogPHByZT5cbiAgICogIGFwcC5jb25maWcoZnVuY3Rpb24gKHZhbGlkYXRvcikge1xuICAgKiAgICB2YWxpZGF0b3Iuc2V0RXJyb3JNZXNzYWdlUmVzb2x2ZXIoZnVuY3Rpb24gKGVycm9yS2V5LCBlbCkge1xuICAgKiAgICAgIHZhciBkZWZlciA9ICRxLmRlZmVyKCk7XG4gICAqICAgICAgLy8gcmVzb2x2ZSB0aGUgY29ycmVjdCBlcnJvciBmcm9tIHRoZSBnaXZlbiBrZXkgYW5kIHJlc29sdmUgdGhlIHJldHVybmVkIHByb21pc2UuXG4gICAqICAgICAgcmV0dXJuIGRlZmVyLnByb21pc2UoKTtcbiAgICogICAgfSk7XG4gICAqICB9KTtcbiAgICogPC9wcmU+XG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IHJlc29sdmVyIEEgbWV0aG9kIHRoYXQgcmV0dXJucyBhIHByb21pc2Ugd2l0aCB0aGUgcmVzb2x2ZWQgZXJyb3IgbWVzc2FnZSBpbi5cbiAgICovXG4gIHRoaXMuc2V0RXJyb3JNZXNzYWdlUmVzb2x2ZXIgPSBmdW5jdGlvbiAocmVzb2x2ZXIpIHtcbiAgICB0aGlzLmVycm9yTWVzc2FnZVJlc29sdmVyID0gcmVzb2x2ZXI7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgKiBAbmFtZSB2YWxpZGF0b3IjZ2V0RXJyb3JNZXNzYWdlXG4gICAqIEBtZXRob2RPZiB2YWxpZGF0b3JcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFJlc29sdmVzIHRoZSBlcnJvciBtZXNzYWdlIGZvciB0aGUgZ2l2ZW4gZXJyb3IgdHlwZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGVycm9yS2V5IFRoZSBlcnJvciB0eXBlLlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsIFRoZSBVSSBlbGVtZW50IHRoYXQgaXMgdGhlIGZvY3VzIG9mIHRoZSBlcnJvci5cbiAgICogSXQgaXMgcHJvdmlkZWQgYXMgdGhlIGVycm9yIG1lc3NhZ2UgbWF5IG5lZWQgaW5mb3JtYXRpb24gZnJvbSB0aGUgZWxlbWVudCBpLmUuIG5nLW1pbiAodGhlIG1pbiBhbGxvd2VkIHZhbHVlKS5cbiAgICovXG4gIHRoaXMuZ2V0RXJyb3JNZXNzYWdlID0gZnVuY3Rpb24gKGVycm9yS2V5LCBlbCkge1xuICAgIHZhciBkZWZlcjtcbiAgICBpZiAodGhpcy5lcnJvck1lc3NhZ2VSZXNvbHZlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBzZXQgYW4gZXJyb3IgbWVzc2FnZSByZXNvbHZlciB2aWEgdGhlIHNldEVycm9yTWVzc2FnZVJlc29sdmVyIGZ1bmN0aW9uIGJlZm9yZSBhdHRlbXB0aW5nIHRvIHJlc29sdmUgYW4gZXJyb3IgbWVzc2FnZS4nKTtcbiAgICB9XG5cbiAgICBpZiAoYXR0cmlidXRlRXhpc3RzKGVsLCAnZGlzYWJsZS12YWxpZGF0aW9uLW1lc3NhZ2UnKSkge1xuICAgICAgZGVmZXIgPSBhbmd1bGFyLmluamVjdG9yKFsnbmcnXSkuZ2V0KCckcScpLmRlZmVyKCk7XG4gICAgICBkZWZlci5yZXNvbHZlKCcnKTtcbiAgICAgIHJldHVybiBkZWZlci5wcm9taXNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5lcnJvck1lc3NhZ2VSZXNvbHZlcihlcnJvcktleSwgZWwpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAqIEBuYW1lIHZhbGlkYXRvciNzZXRWYWxpZEVsZW1lbnRTdHlsaW5nXG4gICAqIEBtZXRob2RPZiB2YWxpZGF0b3JcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEdsb2JhbGx5IGVuYWJsZXMgdmFsaWQgZWxlbWVudCB2aXN1YWwgc3R5bGluZy4gIFRoaXMgaXMgZW5hYmxlZCBieSBkZWZhdWx0LlxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGVuYWJsZWQgVHJ1ZSB0byBlbmFibGUgc3R5bGUgb3RoZXJ3aXNlIGZhbHNlLlxuICAgKi9cbiAgdGhpcy5zZXRWYWxpZEVsZW1lbnRTdHlsaW5nID0gZnVuY3Rpb24gKGVuYWJsZWQpIHtcbiAgICBlbmFibGVWYWxpZEVsZW1lbnRTdHlsaW5nID0gZW5hYmxlZDtcbiAgfTtcblxuICAvKipcbiAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAqIEBuYW1lIHZhbGlkYXRvciNzZXRJbnZhbGlkRWxlbWVudFN0eWxpbmdcbiAgICogQG1ldGhvZE9mIHZhbGlkYXRvclxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogR2xvYmFsbHkgZW5hYmxlcyBpbnZhbGlkIGVsZW1lbnQgdmlzdWFsIHN0eWxpbmcuICBUaGlzIGlzIGVuYWJsZWQgYnkgZGVmYXVsdC5cbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufSBlbmFibGVkIFRydWUgdG8gZW5hYmxlIHN0eWxlIG90aGVyd2lzZSBmYWxzZS5cbiAgICovXG4gIHRoaXMuc2V0SW52YWxpZEVsZW1lbnRTdHlsaW5nID0gZnVuY3Rpb24gKGVuYWJsZWQpIHtcbiAgICBlbmFibGVJbnZhbGlkRWxlbWVudFN0eWxpbmcgPSBlbmFibGVkO1xuICB9O1xuXG4gIHRoaXMuZ2V0RG9tTW9kaWZpZXIgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICB2YXIgbW9kaWZpZXJLZXkgPSAoZWwgIT09IHVuZGVmaW5lZCA/IGVsLmF0dHIoJ2VsZW1lbnQtbW9kaWZpZXInKSA6IHRoaXMuZGVmYXVsdEVsZW1lbnRNb2RpZmllcikgfHxcbiAgICAgIChlbCAhPT0gdW5kZWZpbmVkID8gZWwuYXR0cignZGF0YS1lbGVtZW50LW1vZGlmaWVyJykgOiB0aGlzLmRlZmF1bHRFbGVtZW50TW9kaWZpZXIpIHx8XG4gICAgICB0aGlzLmRlZmF1bHRFbGVtZW50TW9kaWZpZXI7XG5cbiAgICBpZiAobW9kaWZpZXJLZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2Ugc2V0IGEgZGVmYXVsdCBkb20gbW9kaWZpZXIgdmlhIHRoZSBzZXREZWZhdWx0RWxlbWVudE1vZGlmaWVyIG1ldGhvZCBvbiB0aGUgdmFsaWRhdG9yIGNsYXNzLicpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50U3RhdGVNb2RpZmllcnNbbW9kaWZpZXJLZXldO1xuICB9O1xuXG4gIHRoaXMubWFrZVZhbGlkID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgaWYgKGF1dG9WYWxpZGF0ZUVuYWJsZWRPbkNvbnRyb2woZWwpKSB7XG4gICAgICBpZiAodmFsaWRFbGVtZW50U3R5bGluZ0VuYWJsZWQoZWwpKSB7XG4gICAgICAgIHRoaXMuZ2V0RG9tTW9kaWZpZXIoZWwpLm1ha2VWYWxpZChlbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm1ha2VEZWZhdWx0KGVsKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdGhpcy5tYWtlSW52YWxpZCA9IGZ1bmN0aW9uIChlbCwgZXJyb3JNc2cpIHtcbiAgICBpZiAoYXV0b1ZhbGlkYXRlRW5hYmxlZE9uQ29udHJvbChlbCkpIHtcbiAgICAgIGlmIChpbnZhbGlkRWxlbWVudFN0eWxpbmdFbmFibGVkKGVsKSkge1xuICAgICAgICB0aGlzLmdldERvbU1vZGlmaWVyKGVsKS5tYWtlSW52YWxpZChlbCwgZXJyb3JNc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tYWtlRGVmYXVsdChlbCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHRoaXMubWFrZURlZmF1bHQgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICBpZiAoYXV0b1ZhbGlkYXRlRW5hYmxlZE9uQ29udHJvbChlbCkpIHtcbiAgICAgIHZhciBkbSA9IHRoaXMuZ2V0RG9tTW9kaWZpZXIoZWwpO1xuICAgICAgaWYgKGRtLm1ha2VEZWZhdWx0KSB7XG4gICAgICAgIGRtLm1ha2VEZWZhdWx0KGVsKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdGhpcy5kZWZhdWx0Rm9ybVZhbGlkYXRpb25PcHRpb25zID0ge1xuICAgIGZvcmNlVmFsaWRhdGlvbjogZmFsc2UsXG4gICAgZGlzYWJsZWQ6IGZhbHNlLFxuICAgIHZhbGlkYXRlTm9uVmlzaWJsZUNvbnRyb2xzOiBmYWxzZSxcbiAgICByZW1vdmVFeHRlcm5hbFZhbGlkYXRpb25FcnJvcnNPblN1Ym1pdDogdHJ1ZSxcbiAgICB2YWxpZGF0ZU9uRm9ybVN1Ym1pdDogZmFsc2VcbiAgfTtcblxuICB0aGlzLiRnZXQgPSBbXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICBdO1xufVxuXG5hbmd1bGFyLm1vZHVsZSgnamNzLWF1dG9WYWxpZGF0ZScpLnByb3ZpZGVyKCd2YWxpZGF0b3InLCBWYWxpZGF0b3JGbik7XG5cclxuZnVuY3Rpb24gQm9vdHN0cmFwM0VsZW1lbnRNb2RpZmllckZuKCRsb2cpIHtcbiAgdmFyIHJlc2V0ID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICBhbmd1bGFyLmZvckVhY2goZWwuZmluZCgnc3BhbicpLCBmdW5jdGlvbiAoc3BhbkVsKSB7XG4gICAgICAgIHNwYW5FbCA9IGFuZ3VsYXIuZWxlbWVudChzcGFuRWwpO1xuICAgICAgICBpZiAoc3BhbkVsLmhhc0NsYXNzKCdlcnJvci1tc2cnKSB8fCBzcGFuRWwuaGFzQ2xhc3MoJ2Zvcm0tY29udHJvbC1mZWVkYmFjaycpIHx8IHNwYW5FbC5oYXNDbGFzcygnY29udHJvbC1mZWVkYmFjaycpKSB7XG4gICAgICAgICAgc3BhbkVsLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgZWwucmVtb3ZlQ2xhc3MoJ2hhcy1zdWNjZXNzIGhhcy1lcnJvciBoYXMtZmVlZGJhY2snKTtcbiAgICB9LFxuICAgIGZpbmRXaXRoQ2xhc3NFbGVtZW50QXNjID0gZnVuY3Rpb24gKGVsLCBrbGFzcykge1xuICAgICAgdmFyIHJldHVybkVsLFxuICAgICAgICBwYXJlbnQgPSBlbDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IDEwOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKHBhcmVudCAhPT0gdW5kZWZpbmVkICYmIHBhcmVudC5oYXNDbGFzcyhrbGFzcykpIHtcbiAgICAgICAgICByZXR1cm5FbCA9IHBhcmVudDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmIChwYXJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0dXJuRWw7XG4gICAgfSxcblxuICAgIGZpbmRXaXRoQ2xhc3NFbGVtZW50RGVzYyA9IGZ1bmN0aW9uIChlbCwga2xhc3MpIHtcbiAgICAgIHZhciBjaGlsZDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWwuY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY2hpbGQgPSBlbC5jaGlsZHJlbltpXTtcbiAgICAgICAgaWYgKGNoaWxkICE9PSB1bmRlZmluZWQgJiYgYW5ndWxhci5lbGVtZW50KGNoaWxkKS5oYXNDbGFzcyhrbGFzcykpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmIChjaGlsZC5jaGlsZHJlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY2hpbGQgPSBmaW5kV2l0aENsYXNzRWxlbWVudERlc2MoY2hpbGQsIGtsYXNzKTtcbiAgICAgICAgICBpZiAoY2hpbGQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhbmd1bGFyLmVsZW1lbnQoY2hpbGQpO1xuICAgIH0sXG5cbiAgICBmaW5kRm9ybUdyb3VwRWxlbWVudCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgcmV0dXJuIGZpbmRXaXRoQ2xhc3NFbGVtZW50QXNjKGVsLCAnZm9ybS1ncm91cCcpO1xuICAgIH0sXG5cbiAgICBmaW5kSW5wdXRHcm91cEVsZW1lbnQgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgIHJldHVybiBmaW5kV2l0aENsYXNzRWxlbWVudERlc2MoZWwsICdpbnB1dC1ncm91cCcpO1xuICAgIH0sXG5cbiAgICBpbnNlcnRBZnRlciA9IGZ1bmN0aW9uIChyZWZlcmVuY2VOb2RlLCBuZXdOb2RlKSB7XG4gICAgICByZWZlcmVuY2VOb2RlWzBdLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld05vZGVbMF0sIHJlZmVyZW5jZU5vZGVbMF0ubmV4dFNpYmxpbmcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmdkb2MgcHJvcGVydHlcbiAgICAgKiBAbmFtZSBib290c3RyYXAzRWxlbWVudE1vZGlmaWVyI2FkZFZhbGlkYXRpb25TdGF0ZUljb25zXG4gICAgICogQHByb3BlcnR5T2YgYm9vdHN0cmFwM0VsZW1lbnRNb2RpZmllclxuICAgICAqIEByZXR1cm5zIHtib29sfSBUcnVlIGlmIGFuIHN0YXRlIGljb24gd2lsbCBiZSBhZGRlZCB0byB0aGUgZWxlbWVudCBpbiB0aGUgdmFsaWQgYW5kIGludmFsaWQgY29udHJvbFxuICAgICAqIHN0YXRlcy4gIFRoZSBkZWZhdWx0IGlzIGZhbHNlLlxuICAgICAqL1xuICAgIGFkZFZhbGlkYXRpb25TdGF0ZUljb25zID0gZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAbmdkb2MgZnVuY3Rpb25cbiAgICAgKiBAbmFtZSBib290c3RyYXAzRWxlbWVudE1vZGlmaWVyI2VuYWJsZVZhbGlkYXRpb25TdGF0ZUljb25zXG4gICAgICogQG1ldGhvZE9mIGJvb3RzdHJhcDNFbGVtZW50TW9kaWZpZXJcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIE1ha2VzIGFuIGVsZW1lbnQgYXBwZWFyIGludmFsaWQgYnkgYXBwbHkgYW4gaWNvbiB0byB0aGUgaW5wdXQgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbH0gZW5hYmxlIC0gVHJ1ZSB0byBlbmFibGUgdGhlIGljb24gb3RoZXJ3aXNlIGZhbHNlLlxuICAgICAqL1xuICAgIGVuYWJsZVZhbGlkYXRpb25TdGF0ZUljb25zID0gZnVuY3Rpb24gKGVuYWJsZSkge1xuICAgICAgYWRkVmFsaWRhdGlvblN0YXRlSWNvbnMgPSBlbmFibGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgICAqIEBuYW1lIGJvb3RzdHJhcDNFbGVtZW50TW9kaWZpZXIjbWFrZVZhbGlkXG4gICAgICogQG1ldGhvZE9mIGJvb3RzdHJhcDNFbGVtZW50TW9kaWZpZXJcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIE1ha2VzIGFuIGVsZW1lbnQgYXBwZWFyIHZhbGlkIGJ5IGFwcGx5IGJvb3RzdHJhcCAzIHNwZWNpZmljIHN0eWxlcyBhbmQgY2hpbGQgZWxlbWVudHMuIElmIHRoZSBzZXJ2aWNlXG4gICAgICogcHJvcGVydHkgJ2FkZFZhbGlkYXRpb25TdGF0ZUljb25zJyBpcyB0cnVlIGl0IHdpbGwgYWxzbyBhcHBlbmQgdmFsaWRhdGlvbiBnbHlwaGljb24gdG8gdGhlIGVsZW1lbnQuXG4gICAgICogU2VlOiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9jc3MvI2Zvcm1zLWNvbnRyb2wtdmFsaWRhdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbCAtIFRoZSBpbnB1dCBjb250cm9sIGVsZW1lbnQgdGhhdCBpcyB0aGUgdGFyZ2V0IG9mIHRoZSB2YWxpZGF0aW9uLlxuICAgICAqL1xuICAgIG1ha2VWYWxpZCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgdmFyIGZybUdyb3VwRWwgPSBmaW5kRm9ybUdyb3VwRWxlbWVudChlbCksXG4gICAgICAgIGlucHV0R3JvdXBFbDtcblxuICAgICAgaWYgKGZybUdyb3VwRWwpIHtcbiAgICAgICAgcmVzZXQoZnJtR3JvdXBFbCk7XG4gICAgICAgIGlucHV0R3JvdXBFbCA9IGZpbmRJbnB1dEdyb3VwRWxlbWVudChmcm1Hcm91cEVsWzBdKTtcbiAgICAgICAgZnJtR3JvdXBFbC5hZGRDbGFzcygnaGFzLXN1Y2Nlc3MgJyArIChpbnB1dEdyb3VwRWwubGVuZ3RoID4gMCB8fCBhZGRWYWxpZGF0aW9uU3RhdGVJY29ucyA9PT0gZmFsc2UgPyAnJyA6ICdoYXMtZmVlZGJhY2snKSk7XG4gICAgICAgIGlmIChhZGRWYWxpZGF0aW9uU3RhdGVJY29ucykge1xuICAgICAgICAgIHZhciBpY29uRWxUZXh0ID0gJzxzcGFuIGNsYXNzPVwiZ2x5cGhpY29uIGdseXBoaWNvbi1vayBmb3JtLWNvbnRyb2wtZmVlZGJhY2tcIj48L3NwYW4+JztcbiAgICAgICAgICBpZiAoaW5wdXRHcm91cEVsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGljb25FbFRleHQgPSBpY29uRWxUZXh0LnJlcGxhY2UoJ2Zvcm0tJywgJycpO1xuICAgICAgICAgICAgaWNvbkVsVGV4dCA9ICc8c3BhbiBjbGFzcz1cImlucHV0LWdyb3VwLWFkZG9uIGNvbnRyb2wtZmVlZGJhY2tcIj4nICsgaWNvbkVsVGV4dCArICc8L3NwYW4nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGluc2VydEFmdGVyKGVsLCBhbmd1bGFyLmVsZW1lbnQoaWNvbkVsVGV4dCkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkbG9nLmVycm9yKCdBbmd1bGFyLWF1dG8tdmFsaWRhdGU6IGludmFsaWQgYnMzIGZvcm0gc3RydWN0dXJlIGVsZW1lbnRzIG11c3QgYmUgd3JhcHBlZCBieSBhIGZvcm0tZ3JvdXAgY2xhc3MnKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAgICogQG5hbWUgYm9vdHN0cmFwM0VsZW1lbnRNb2RpZmllciNtYWtlSW52YWxpZFxuICAgICAqIEBtZXRob2RPZiBib290c3RyYXAzRWxlbWVudE1vZGlmaWVyXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBNYWtlcyBhbiBlbGVtZW50IGFwcGVhciBpbnZhbGlkIGJ5IGFwcGx5IGJvb3RzdHJhcCAzIHNwZWNpZmljIHN0eWxlcyBhbmQgY2hpbGQgZWxlbWVudHMuIElmIHRoZSBzZXJ2aWNlXG4gICAgICogcHJvcGVydHkgJ2FkZFZhbGlkYXRpb25TdGF0ZUljb25zJyBpcyB0cnVlIGl0IHdpbGwgYWxzbyBhcHBlbmQgdmFsaWRhdGlvbiBnbHlwaGljb24gdG8gdGhlIGVsZW1lbnQuXG4gICAgICogU2VlOiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9jc3MvI2Zvcm1zLWNvbnRyb2wtdmFsaWRhdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbCAtIFRoZSBpbnB1dCBjb250cm9sIGVsZW1lbnQgdGhhdCBpcyB0aGUgdGFyZ2V0IG9mIHRoZSB2YWxpZGF0aW9uLlxuICAgICAqL1xuICAgIG1ha2VJbnZhbGlkID0gZnVuY3Rpb24gKGVsLCBlcnJvck1zZykge1xuICAgICAgdmFyIGZybUdyb3VwRWwgPSBmaW5kRm9ybUdyb3VwRWxlbWVudChlbCksXG4gICAgICAgIGhlbHBUZXh0RWwgPSBhbmd1bGFyLmVsZW1lbnQoJzxzcGFuIGNsYXNzPVwiaGVscC1ibG9jayBoYXMtZXJyb3IgZXJyb3ItbXNnXCI+JyArIGVycm9yTXNnICsgJzwvc3Bhbj4nKSxcbiAgICAgICAgaW5wdXRHcm91cEVsO1xuXG4gICAgICBpZiAoZnJtR3JvdXBFbCkge1xuICAgICAgICByZXNldChmcm1Hcm91cEVsKTtcbiAgICAgICAgaW5wdXRHcm91cEVsID0gZmluZElucHV0R3JvdXBFbGVtZW50KGZybUdyb3VwRWxbMF0pO1xuICAgICAgICBmcm1Hcm91cEVsLmFkZENsYXNzKCdoYXMtZXJyb3IgJyArIChpbnB1dEdyb3VwRWwubGVuZ3RoID4gMCB8fCBhZGRWYWxpZGF0aW9uU3RhdGVJY29ucyA9PT0gZmFsc2UgPyAnJyA6ICdoYXMtZmVlZGJhY2snKSk7XG4gICAgICAgIGluc2VydEFmdGVyKGlucHV0R3JvdXBFbC5sZW5ndGggPiAwID8gaW5wdXRHcm91cEVsIDogZ2V0Q29ycmVjdEVsZW1lbnRUb1BsYWNlRXJyb3JFbGVtZW50QWZ0ZXIoZWwpLCBoZWxwVGV4dEVsKTtcbiAgICAgICAgaWYgKGFkZFZhbGlkYXRpb25TdGF0ZUljb25zKSB7XG4gICAgICAgICAgdmFyIGljb25FbFRleHQgPSAnPHNwYW4gY2xhc3M9XCJnbHlwaGljb24gZ2x5cGhpY29uLXJlbW92ZSBmb3JtLWNvbnRyb2wtZmVlZGJhY2tcIj48L3NwYW4+JztcbiAgICAgICAgICBpZiAoaW5wdXRHcm91cEVsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGljb25FbFRleHQgPSBpY29uRWxUZXh0LnJlcGxhY2UoJ2Zvcm0tJywgJycpO1xuICAgICAgICAgICAgaWNvbkVsVGV4dCA9ICc8c3BhbiBjbGFzcz1cImlucHV0LWdyb3VwLWFkZG9uIGNvbnRyb2wtZmVlZGJhY2tcIj4nICsgaWNvbkVsVGV4dCArICc8L3NwYW4nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGluc2VydEFmdGVyKGdldENvcnJlY3RFbGVtZW50VG9QbGFjZUVycm9yRWxlbWVudEFmdGVyKGVsKSwgYW5ndWxhci5lbGVtZW50KGljb25FbFRleHQpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJGxvZy5lcnJvcignQW5ndWxhci1hdXRvLXZhbGlkYXRlOiBpbnZhbGlkIGJzMyBmb3JtIHN0cnVjdHVyZSBlbGVtZW50cyBtdXN0IGJlIHdyYXBwZWQgYnkgYSBmb3JtLWdyb3VwIGNsYXNzJyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGdldENvcnJlY3RFbGVtZW50VG9QbGFjZUVycm9yRWxlbWVudEFmdGVyID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICB2YXIgY29ycmVjdEVsID0gZWwsXG4gICAgICAgIGVsVHlwZSA9IGVsWzBdLnR5cGUgPyBlbFswXS50eXBlLnRvTG93ZXJDYXNlKCkgOiAnJztcblxuICAgICAgaWYgKChlbFR5cGUgPT09ICdjaGVja2JveCcgfHwgZWxUeXBlID09PSAncmFkaW8nKSAmJiBlbC5wYXJlbnQoKVswXS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnbGFiZWwnKSB7XG4gICAgICAgIGNvcnJlY3RFbCA9IGVsLnBhcmVudCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29ycmVjdEVsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmdkb2MgZnVuY3Rpb25cbiAgICAgKiBAbmFtZSBib290c3RyYXAzRWxlbWVudE1vZGlmaWVyI21ha2VEZWZhdWx0XG4gICAgICogQG1ldGhvZE9mIGJvb3RzdHJhcDNFbGVtZW50TW9kaWZpZXJcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIE1ha2VzIGFuIGVsZW1lbnQgYXBwZWFyIGluIGl0cyBkZWZhdWx0IHZpc3VhbCBzdGF0ZSBieSBhcHBseSBib290c3RyYXAgMyBzcGVjaWZpYyBzdHlsZXMgYW5kIGNoaWxkIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbCAtIFRoZSBpbnB1dCBjb250cm9sIGVsZW1lbnQgdGhhdCBpcyB0aGUgdGFyZ2V0IG9mIHRoZSB2YWxpZGF0aW9uLlxuICAgICAqL1xuICAgIG1ha2VEZWZhdWx0ID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICB2YXIgZnJtR3JvdXBFbCA9IGZpbmRGb3JtR3JvdXBFbGVtZW50KGVsKTtcbiAgICAgIGlmIChmcm1Hcm91cEVsKSB7XG4gICAgICAgIHJlc2V0KGZybUdyb3VwRWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJGxvZy5lcnJvcignQW5ndWxhci1hdXRvLXZhbGlkYXRlOiBpbnZhbGlkIGJzMyBmb3JtIHN0cnVjdHVyZSBlbGVtZW50cyBtdXN0IGJlIHdyYXBwZWQgYnkgYSBmb3JtLWdyb3VwIGNsYXNzJyk7XG4gICAgICB9XG4gICAgfTtcblxuICByZXR1cm4ge1xuICAgIG1ha2VWYWxpZDogbWFrZVZhbGlkLFxuICAgIG1ha2VJbnZhbGlkOiBtYWtlSW52YWxpZCxcbiAgICBtYWtlRGVmYXVsdDogbWFrZURlZmF1bHQsXG4gICAgZW5hYmxlVmFsaWRhdGlvblN0YXRlSWNvbnM6IGVuYWJsZVZhbGlkYXRpb25TdGF0ZUljb25zLFxuICAgIGtleTogJ2JzMydcbiAgfTtcbn1cblxuQm9vdHN0cmFwM0VsZW1lbnRNb2RpZmllckZuLiRpbmplY3QgPSBbXG4gICckbG9nJ1xuXTtcblxuYW5ndWxhci5tb2R1bGUoJ2pjcy1hdXRvVmFsaWRhdGUnKS5mYWN0b3J5KCdib290c3RyYXAzRWxlbWVudE1vZGlmaWVyJywgQm9vdHN0cmFwM0VsZW1lbnRNb2RpZmllckZuKTtcblxyXG4vKlxuICogVGFrZW4gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyLmpzL2lzc3Vlcy8yNjkwI2lzc3VlLTE0NDYyMTY0ICh3aXRoIGFkZGVkIHRlc3RzIG9mIGNvdXJzZSEpXG4gKi9cbmZ1bmN0aW9uIEpDU0RlYm91bmNlRm4oJHRpbWVvdXQpIHtcbiAgdmFyIGRlYm91bmNlID0gZnVuY3Rpb24gKGZuLCB0aW1lb3V0LCBhcHBseSkge1xuICAgIHRpbWVvdXQgPSBhbmd1bGFyLmlzVW5kZWZpbmVkKHRpbWVvdXQpID8gMCA6IHRpbWVvdXQ7XG4gICAgYXBwbHkgPSBhbmd1bGFyLmlzVW5kZWZpbmVkKGFwcGx5KSA/IHRydWUgOiBhcHBseTsgLy8gISFkZWZhdWx0IGlzIHRydWUhIG1vc3Qgc3VpdGFibGUgdG8gbXkgZXhwZXJpZW5jZVxuICAgIHZhciBudGhDYWxsID0gMDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyAvLyBpbnRlcmNlcHRpbmcgZm5cbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIHZhciBhcmd6ID0gYXJndW1lbnRzO1xuICAgICAgbnRoQ2FsbCArPSAxO1xuICAgICAgdmFyIGxhdGVyID0gKGZ1bmN0aW9uICh2ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHZlcnNpb24gPT09IG50aENhbGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd6KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KShudGhDYWxsKTtcblxuICAgICAgcmV0dXJuICR0aW1lb3V0KGxhdGVyLCB0aW1lb3V0LCBhcHBseSk7XG4gICAgfTtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGRlYm91bmNlOiBkZWJvdW5jZVxuICB9O1xufVxuXG5KQ1NEZWJvdW5jZUZuLiRpbmplY3QgPSBbXG4gICckdGltZW91dCdcbl07XG5cbmFuZ3VsYXIubW9kdWxlKCdqY3MtYXV0b1ZhbGlkYXRlJykuZmFjdG9yeSgnamNzLWRlYm91bmNlJywgSkNTRGVib3VuY2VGbik7XG5cclxuLyoqXG4gKiBSZXBsYWNlcyBzdHJpbmcgcGxhY2Vob2xkZXJzIHdpdGggY29ycmVzcG9uZGluZyB0ZW1wbGF0ZSBzdHJpbmdcbiAqL1xuaWYgKCEoJ2Zvcm1hdCcgaW4gU3RyaW5nLnByb3RvdHlwZSkpIHtcbiAgU3RyaW5nLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIHRoaXMucmVwbGFjZSgveyhcXGQrKX0vZywgZnVuY3Rpb24gKG1hdGNoLCBudW1iZXIpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgYXJnc1tudW1iZXJdICE9PSB1bmRlZmluZWQgPyBhcmdzW251bWJlcl0gOiBtYXRjaDtcbiAgICB9KTtcbiAgfTtcbn1cblxuYW5ndWxhci5hdXRvVmFsaWRhdGUgPSBhbmd1bGFyLmF1dG9WYWxpZGF0ZSB8fCB7XG4gIGVycm9yTWVzc2FnZXM6IHt9XG59O1xuXG5hbmd1bGFyLmF1dG9WYWxpZGF0ZS5lcnJvck1lc3NhZ2VzWydkZWZhdWx0J10gPSB7XG4gIGRlZmF1bHRNc2c6ICdQbGVhc2UgYWRkIGVycm9yIG1lc3NhZ2UgZm9yIHswfScsXG4gIGVtYWlsOiAnUGxlYXNlIGVudGVyIGEgdmFsaWQgZW1haWwgYWRkcmVzcycsXG4gIG1pbmxlbmd0aDogJ1BsZWFzZSBlbnRlciBhdCBsZWFzdCB7MH0gY2hhcmFjdGVycycsXG4gIG1heGxlbmd0aDogJ1lvdSBoYXZlIGVudGVyZWQgbW9yZSB0aGFuIHRoZSBtYXhpbXVtIHswfSBjaGFyYWN0ZXJzJyxcbiAgbWluOiAnUGxlYXNlIGVudGVyIHRoZSBtaW5pbXVtIG51bWJlciBvZiB7MH0nLFxuICBtYXg6ICdQbGVhc2UgZW50ZXIgdGhlIG1heGltdW0gbnVtYmVyIG9mIHswfScsXG4gIHJlcXVpcmVkOiAnVGhpcyBmaWVsZCBpcyByZXF1aXJlZCcsXG4gIGRhdGU6ICdQbGVhc2UgZW50ZXIgYSB2YWxpZCBkYXRlJyxcbiAgcGF0dGVybjogJ1BsZWFzZSBlbnN1cmUgdGhlIGVudGVyZWQgaW5mb3JtYXRpb24gYWRoZXJlcyB0byB0aGlzIHBhdHRlcm4gezB9JyxcbiAgbnVtYmVyOiAnUGxlYXNlIGVudGVyIGEgdmFsaWQgbnVtYmVyJyxcbiAgdXJsOiAnUGxlYXNlIGVudGVyIGEgdmFsaWQgVVJMIGluIHRoZSBmb3JtYXQgb2YgaHR0cChzKTovL3d3dy5nb29nbGUuY29tJ1xufTtcblxuZnVuY3Rpb24gRGVmYXVsdEVycm9yTWVzc2FnZVJlc29sdmVyRm4oJHEsICRodHRwKSB7XG4gIHZhciBjdXJyZW50Q3VsdHVyZSA9ICdkZWZhdWx0JyxcblxuICAgIGkxOG5GaWxlUm9vdFBhdGggPSAnanMvYW5ndWxhci1hdXRvLXZhbGlkYXRlL2Rpc3QvbGFuZycsXG5cbiAgICBjdWx0dXJlUmV0cmlldmFsUHJvbWlzZSxcblxuICAgIGxvYWRSZW1vdGVDdWx0dXJlID0gZnVuY3Rpb24gKGN1bHR1cmUpIHtcbiAgICAgIGN1bHR1cmVSZXRyaWV2YWxQcm9taXNlID0gJGh0dHAuZ2V0KCd7MH0vamNzLWF1dG8tdmFsaWRhdGVfezF9Lmpzb24nLmZvcm1hdChpMThuRmlsZVJvb3RQYXRoLCBjdWx0dXJlLnRvTG93ZXJDYXNlKCkpKTtcbiAgICAgIHJldHVybiBjdWx0dXJlUmV0cmlldmFsUHJvbWlzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAgICogQG5hbWUgZGVmYXVsdEVycm9yTWVzc2FnZVJlc29sdmVyI3NldEkxOG5GaWxlUm9vdFBhdGhcbiAgICAgKiBAbWV0aG9kT2YgZGVmYXVsdEVycm9yTWVzc2FnZVJlc29sdmVyXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBTZXQgdGhlIHJvb3QgcGF0aCB0byB0aGUgaWw4biBmaWxlcyBvbiB0aGUgc2VydmVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcm9vdFBhdGggLSBUaGUgcm9vdCBwYXRoIG9uIHRoZSBzZXJ2ZXIgdG8gdGhlIGlsOG4gZmlsZSAtIHRoaXMgZGVmYXVsdHNcbiAgICAgKiB0byAnanMvYW5ndWxhci1hdXRvLXZhbGlkYXRlL2xhbmcvJ1xuICAgICAqL1xuICAgIHNldEkxOG5GaWxlUm9vdFBhdGggPSBmdW5jdGlvbiAocm9vdFBhdGgpIHtcbiAgICAgIGkxOG5GaWxlUm9vdFBhdGggPSByb290UGF0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAgICogQG5hbWUgZGVmYXVsdEVycm9yTWVzc2FnZVJlc29sdmVyI3NldEN1bHR1cmVcbiAgICAgKiBAbWV0aG9kT2YgZGVmYXVsdEVycm9yTWVzc2FnZVJlc29sdmVyXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBTZXQgdGhlIGN1bHR1cmUgZm9yIHRoZSBlcnJvciBtZXNzYWdlcyBieSBsb2FkaW5nIGFuIHRoZSBjb3JyZWN0IGN1bHR1cmUgcmVzb3VyY2UgZmlsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjdWx0dXJlIC0gVGhlIG5ldyBjdWx0dXJlIGluIHRoZSBmb3JtYXQgb2YgJ2VuLWdiJyBldGMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VsdHVyZUxvYWRpbmdGbiAtIEEgb3B0aW9uYWwgZnVuY3Rpb24gdG8gbG9hZCB0aGUgY3VsdHVyZSByZXNvbHZlIHdoaWNoIHNob3VsZFxuICAgICAqIHJldHVybiBhIHByb21pc2Ugd2hpY2ggaXMgcmVzb2x2ZWQgd2l0aCB0aGUgY3VsdHVyZSBlcnJvck1lc3NhZ2Ugb2JqZWN0LiAgSWYgYSBmdW5jdGlvbiBpcyBub3Qgc3BlY2lmaWVkXG4gICAgICogdGhlIGN1bHR1cmUgZmlsZSBpcyBsb2FkZWQgZnJvbSB0aGUgKippMThuRmlsZVJvb3RQYXRoKiouXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IC0gQSBwcm9taXNlIHdoaWNoIGlzIHJlc29sdmVkIHdpdGggdGhlIGxvYWRlZCBjdWx0dXJlIGVycm9yIG1lc3NhZ2VzIG9iamVjdC5cbiAgICAgKi9cbiAgICBzZXRDdWx0dXJlID0gZnVuY3Rpb24gKGN1bHR1cmUsIGN1bHR1cmVMb2FkaW5nRm4pIHtcbiAgICAgIHZhciBkZWZlciA9ICRxLmRlZmVyKCk7XG4gICAgICBjdWx0dXJlTG9hZGluZ0ZuID0gY3VsdHVyZUxvYWRpbmdGbiB8fCBsb2FkUmVtb3RlQ3VsdHVyZTtcbiAgICAgIGN1cnJlbnRDdWx0dXJlID0gY3VsdHVyZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKGFuZ3VsYXIuYXV0b1ZhbGlkYXRlLmVycm9yTWVzc2FnZXNbY3VycmVudEN1bHR1cmVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY3VsdHVyZVJldHJpZXZhbFByb21pc2UgPSBjdWx0dXJlTG9hZGluZ0ZuKGN1bHR1cmUpO1xuICAgICAgICBjdWx0dXJlUmV0cmlldmFsUHJvbWlzZS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgIGN1bHR1cmVSZXRyaWV2YWxQcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGFuZ3VsYXIuYXV0b1ZhbGlkYXRlLmVycm9yTWVzc2FnZXNbY3VycmVudEN1bHR1cmVdID0gcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgICBkZWZlci5yZXNvbHZlKGFuZ3VsYXIuYXV0b1ZhbGlkYXRlLmVycm9yTWVzc2FnZXNbY3VycmVudEN1bHR1cmVdKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIGFuZ3VsYXIuYXV0b1ZhbGlkYXRlLmVycm9yTWVzc2FnZXNbY3VycmVudEN1bHR1cmVdID0ge1xuICAgICAgICAgICAgZGVmYXVsdE1zZzogJ0xvYWRpbmcgY3VsdHVyZSBmYWlsZWQhJ1xuICAgICAgICAgIH07XG4gICAgICAgICAgY3VsdHVyZVJldHJpZXZhbFByb21pc2UgPSBudWxsO1xuICAgICAgICAgIGRlZmVyLnJlamVjdChlcnIpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZmVyLnJlc29sdmUoYW5ndWxhci5hdXRvVmFsaWRhdGUuZXJyb3JNZXNzYWdlc1tjdXJyZW50Q3VsdHVyZV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVmZXIucHJvbWlzZTtcbiAgICB9LFxuXG4gICAgZ2V0RXJyb3JNZXNzYWdlcyA9IGZ1bmN0aW9uIChjdWx0dXJlKSB7XG4gICAgICB2YXIgZGVmZXIgPSAkcS5kZWZlcigpO1xuICAgICAgY3VsdHVyZSA9IGN1bHR1cmUgPT09IHVuZGVmaW5lZCA/IGN1cnJlbnRDdWx0dXJlIDogY3VsdHVyZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKGN1bHR1cmVSZXRyaWV2YWxQcm9taXNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY3VsdHVyZVJldHJpZXZhbFByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZGVmZXIucmVzb2x2ZShhbmd1bGFyLmF1dG9WYWxpZGF0ZS5lcnJvck1lc3NhZ2VzW2N1bHR1cmVdKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIGRlZmVyLnJlamVjdChlcnIpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZmVyLnJlc29sdmUoYW5ndWxhci5hdXRvVmFsaWRhdGUuZXJyb3JNZXNzYWdlc1tjdWx0dXJlXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVmZXIucHJvbWlzZTtcbiAgICB9LFxuXG4gICAgZ2V0TWVzc2FnZVR5cGVPdmVycmlkZSA9IGZ1bmN0aW9uIChlcnJvclR5cGUsIGVsKSB7XG4gICAgICB2YXIgb3ZlcnJpZGVLZXk7XG5cbiAgICAgIGlmIChlbCkge1xuICAgICAgICAvLyB0cnkgYW5kIGZpbmQgYW4gYXR0cmlidXRlIHdoaWNoIG92ZXJyaWRlcyB0aGUgZ2l2ZW4gZXJyb3IgdHlwZSBpbiB0aGUgZm9ybSBvZiBlcnJvclR5cGUtZXJyLXR5cGU9XCJzb21lTXNnS2V5XCJcbiAgICAgICAgZXJyb3JUeXBlICs9ICctZXJyLXR5cGUnO1xuXG5cbiAgICAgICAgb3ZlcnJpZGVLZXkgPSBlbC5hdHRyKCduZy0nICsgZXJyb3JUeXBlKTtcbiAgICAgICAgaWYgKG92ZXJyaWRlS2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBvdmVycmlkZUtleSA9IGVsLmF0dHIoJ2RhdGEtbmctJyArIGVycm9yVHlwZSkgfHwgZWwuYXR0cihlcnJvclR5cGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG92ZXJyaWRlS2V5KSB7XG4gICAgICAgICAgb3ZlcnJpZGVLZXkgPSBvdmVycmlkZUtleS5yZXBsYWNlKC9bXFxXXS9nLCAnJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG92ZXJyaWRlS2V5O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmdkb2MgZnVuY3Rpb25cbiAgICAgKiBAbmFtZSBkZWZhdWx0RXJyb3JNZXNzYWdlUmVzb2x2ZXIjcmVzb2x2ZVxuICAgICAqIEBtZXRob2RPZiBkZWZhdWx0RXJyb3JNZXNzYWdlUmVzb2x2ZXJcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFJlc29sdmVzIGEgdmFsaWRhdGUgZXJyb3IgdHlwZSBpbnRvIGEgdXNlciB2YWxpZGF0aW9uIGVycm9yIG1lc3NhZ2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBlcnJvclR5cGUgLSBUaGUgdHlwZSBvZiB2YWxpZGF0aW9uIGVycm9yIHRoYXQgaGFzIG9jY3VycmVkLlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWwgLSBUaGUgaW5wdXQgZWxlbWVudCB0aGF0IGlzIHRoZSBzb3VyY2Ugb2YgdGhlIHZhbGlkYXRpb24gZXJyb3IuXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IEEgcHJvbWlzZSB0aGF0IGlzIHJlc29sdmVkIHdoZW4gdGhlIHZhbGlkYXRpb24gbWVzc2FnZSBoYXMgYmVlbiBwcm9kdWNlZC5cbiAgICAgKi9cbiAgICByZXNvbHZlID0gZnVuY3Rpb24gKGVycm9yVHlwZSwgZWwpIHtcbiAgICAgIHZhciBkZWZlciA9ICRxLmRlZmVyKCksXG4gICAgICAgIGVyck1zZyxcbiAgICAgICAgcGFyYW1ldGVycyA9IFtdLFxuICAgICAgICBwYXJhbWV0ZXIsXG4gICAgICAgIG1lc3NhZ2VUeXBlT3ZlcnJpZGU7XG5cbiAgICAgIGlmIChjdWx0dXJlUmV0cmlldmFsUHJvbWlzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGN1bHR1cmVSZXRyaWV2YWxQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJlc29sdmUoZXJyb3JUeXBlLCBlbCkudGhlbihmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgICAgICBkZWZlci5yZXNvbHZlKG1zZyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyTXNnID0gYW5ndWxhci5hdXRvVmFsaWRhdGUuZXJyb3JNZXNzYWdlc1tjdXJyZW50Q3VsdHVyZV1bZXJyb3JUeXBlXTtcbiAgICAgICAgbWVzc2FnZVR5cGVPdmVycmlkZSA9IGdldE1lc3NhZ2VUeXBlT3ZlcnJpZGUoZXJyb3JUeXBlLCBlbCk7XG4gICAgICAgIGlmIChtZXNzYWdlVHlwZU92ZXJyaWRlKSB7XG4gICAgICAgICAgZXJyTXNnID0gYW5ndWxhci5hdXRvVmFsaWRhdGUuZXJyb3JNZXNzYWdlc1tjdXJyZW50Q3VsdHVyZV1bbWVzc2FnZVR5cGVPdmVycmlkZV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyTXNnID09PSB1bmRlZmluZWQgJiYgbWVzc2FnZVR5cGVPdmVycmlkZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZXJyTXNnID0gYW5ndWxhci5hdXRvVmFsaWRhdGUuZXJyb3JNZXNzYWdlc1tjdXJyZW50Q3VsdHVyZV0uZGVmYXVsdE1zZy5mb3JtYXQobWVzc2FnZVR5cGVPdmVycmlkZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXJyTXNnID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBlcnJNc2cgPSBhbmd1bGFyLmF1dG9WYWxpZGF0ZS5lcnJvck1lc3NhZ2VzW2N1cnJlbnRDdWx0dXJlXS5kZWZhdWx0TXNnLmZvcm1hdChlcnJvclR5cGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVsICYmIGVsLmF0dHIpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcGFyYW1ldGVyID0gZWwuYXR0cignbmctJyArIGVycm9yVHlwZSk7XG4gICAgICAgICAgICBpZiAocGFyYW1ldGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgcGFyYW1ldGVyID0gZWwuYXR0cignZGF0YS1uZy0nICsgZXJyb3JUeXBlKSB8fCBlbC5hdHRyKGVycm9yVHlwZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBhcmFtZXRlcnMucHVzaChwYXJhbWV0ZXIgfHwgJycpO1xuXG4gICAgICAgICAgICBlcnJNc2cgPSBlcnJNc2cuZm9ybWF0KHBhcmFtZXRlcnMpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIH1cblxuICAgICAgICBkZWZlci5yZXNvbHZlKGVyck1zZyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkZWZlci5wcm9taXNlO1xuICAgIH07XG5cbiAgcmV0dXJuIHtcbiAgICBzZXRJMThuRmlsZVJvb3RQYXRoOiBzZXRJMThuRmlsZVJvb3RQYXRoLFxuICAgIHNldEN1bHR1cmU6IHNldEN1bHR1cmUsXG4gICAgZ2V0RXJyb3JNZXNzYWdlczogZ2V0RXJyb3JNZXNzYWdlcyxcbiAgICByZXNvbHZlOiByZXNvbHZlXG4gIH07XG59XG5cbkRlZmF1bHRFcnJvck1lc3NhZ2VSZXNvbHZlckZuLiRpbmplY3QgPSBbXG4gICckcScsXG4gICckaHR0cCdcbl07XG5cbmFuZ3VsYXIubW9kdWxlKCdqY3MtYXV0b1ZhbGlkYXRlJykuZmFjdG9yeSgnZGVmYXVsdEVycm9yTWVzc2FnZVJlc29sdmVyJywgRGVmYXVsdEVycm9yTWVzc2FnZVJlc29sdmVyRm4pO1xuXHJcbmZ1bmN0aW9uIEZvdW5kYXRpb241RWxlbWVudE1vZGlmaWVyRm4oKSB7XG4gIHZhciByZXNldCA9IGZ1bmN0aW9uIChlbCwgaW5wdXRFbCkge1xuICAgICAgYW5ndWxhci5mb3JFYWNoKGVsLmZpbmQoJ3NtYWxsJyksIGZ1bmN0aW9uIChzbWFsbEVsKSB7XG4gICAgICAgIGlmIChhbmd1bGFyLmVsZW1lbnQoc21hbGxFbCkuaGFzQ2xhc3MoJ2Vycm9yJykpIHtcbiAgICAgICAgICBhbmd1bGFyLmVsZW1lbnQoc21hbGxFbCkucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpbnB1dEVsLnJlbW92ZUNsYXNzKCdlcnJvcicpO1xuICAgIH0sXG4gICAgZmluZFBhcmVudENvbHVtbiA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgdmFyIHBhcmVudCA9IGVsO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gMzsgaSArPSAxKSB7XG4gICAgICAgIGlmIChwYXJlbnQgIT09IHVuZGVmaW5lZCAmJiAocGFyZW50Lmhhc0NsYXNzKCdjb2x1bW5zJykgfHwgcGFyZW50Lmhhc0NsYXNzKCdjb2x1bW4nKSkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmIChwYXJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFyZW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmdkb2MgZnVuY3Rpb25cbiAgICAgKiBAbmFtZSBmb3VuZGF0aW9uNUVsZW1lbnRNb2RpZmllciNtYWtlVmFsaWRcbiAgICAgKiBAbWV0aG9kT2YgZm91bmRhdGlvbjVFbGVtZW50TW9kaWZpZXJcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIE1ha2VzIGFuIGVsZW1lbnQgYXBwZWFyIHZhbGlkIGJ5IGFwcGx5IEZvdW5kYXRpb24gNSBzcGVjaWZpYyBzdHlsZXMgYW5kIGNoaWxkIGVsZW1lbnRzLlxuICAgICAqIFNlZTogaHR0cDovL2ZvdW5kYXRpb24uenVyYi5jb20vZG9jcy9jb21wb25lbnRzL2Zvcm1zLmh0bWxcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWwgLSBUaGUgaW5wdXQgY29udHJvbCBlbGVtZW50IHRoYXQgaXMgdGhlIHRhcmdldCBvZiB0aGUgdmFsaWRhdGlvbi5cbiAgICAgKi9cbiAgICBtYWtlVmFsaWQgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgIHZhciBwYXJlbnRDb2x1bW4gPSBmaW5kUGFyZW50Q29sdW1uKGVsKTtcbiAgICAgIHJlc2V0KHBhcmVudENvbHVtbiAmJiBwYXJlbnRDb2x1bW4ubGVuZ3RoID4gMCA/IHBhcmVudENvbHVtbiA6IGVsLCBlbCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgICAqIEBuYW1lIGZvdW5kYXRpb241RWxlbWVudE1vZGlmaWVyI21ha2VJbnZhbGlkXG4gICAgICogQG1ldGhvZE9mIGZvdW5kYXRpb241RWxlbWVudE1vZGlmaWVyXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBNYWtlcyBhbiBlbGVtZW50IGFwcGVhciBpbnZhbGlkIGJ5IGFwcGx5IEZvdW5kYXRpb24gNSBzcGVjaWZpYyBzdHlsZXMgYW5kIGNoaWxkIGVsZW1lbnRzLlxuICAgICAqIFNlZTogaHR0cDovL2ZvdW5kYXRpb24uenVyYi5jb20vZG9jcy9jb21wb25lbnRzL2Zvcm1zLmh0bWxcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWwgLSBUaGUgaW5wdXQgY29udHJvbCBlbGVtZW50IHRoYXQgaXMgdGhlIHRhcmdldCBvZiB0aGUgdmFsaWRhdGlvbi5cbiAgICAgKi9cbiAgICBtYWtlSW52YWxpZCA9IGZ1bmN0aW9uIChlbCwgZXJyb3JNc2cpIHtcbiAgICAgIHZhciBwYXJlbnRDb2x1bW4gPSBmaW5kUGFyZW50Q29sdW1uKGVsKSxcbiAgICAgICAgaGVscFRleHRFbDtcbiAgICAgIHJlc2V0KHBhcmVudENvbHVtbiB8fCBlbCwgZWwpO1xuICAgICAgZWwuYWRkQ2xhc3MoJ2Vycm9yJyk7XG4gICAgICBpZiAocGFyZW50Q29sdW1uKSB7XG4gICAgICAgIGhlbHBUZXh0RWwgPSBhbmd1bGFyLmVsZW1lbnQoJzxzbWFsbCBjbGFzcz1cImVycm9yXCI+JyArIGVycm9yTXNnICsgJzwvc21hbGw+Jyk7XG4gICAgICAgIHBhcmVudENvbHVtbi5hcHBlbmQoaGVscFRleHRFbCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgICAqIEBuYW1lIGZvdW5kYXRpb241RWxlbWVudE1vZGlmaWVyI21ha2VEZWZhdWx0XG4gICAgICogQG1ldGhvZE9mIGZvdW5kYXRpb241RWxlbWVudE1vZGlmaWVyXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBNYWtlcyBhbiBlbGVtZW50IGFwcGVhciBpbiBpdHMgZGVmYXVsdCB2aXN1YWwgc3RhdGUgYnkgYXBwbHkgZm91bmRhdGlvbiA1IHNwZWNpZmljIHN0eWxlcyBhbmQgY2hpbGQgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsIC0gVGhlIGlucHV0IGNvbnRyb2wgZWxlbWVudCB0aGF0IGlzIHRoZSB0YXJnZXQgb2YgdGhlIHZhbGlkYXRpb24uXG4gICAgICovXG4gICAgbWFrZURlZmF1bHQgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgIG1ha2VWYWxpZChlbCk7XG4gICAgfTtcblxuICByZXR1cm4ge1xuICAgIG1ha2VWYWxpZDogbWFrZVZhbGlkLFxuICAgIG1ha2VJbnZhbGlkOiBtYWtlSW52YWxpZCxcbiAgICBtYWtlRGVmYXVsdDogbWFrZURlZmF1bHQsXG4gICAga2V5OiAnZm91bmRhdGlvbjUnXG4gIH07XG59XG5cbmFuZ3VsYXIubW9kdWxlKCdqY3MtYXV0b1ZhbGlkYXRlJykuZmFjdG9yeSgnZm91bmRhdGlvbjVFbGVtZW50TW9kaWZpZXInLCBGb3VuZGF0aW9uNUVsZW1lbnRNb2RpZmllckZuKTtcblxyXG5mdW5jdGlvbiBFbGVtZW50VXRpbHNGbigpIHtcbiAgdmFyIGlzRWxlbWVudFZpc2libGUgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICByZXR1cm4gZWxbMF0ub2Zmc2V0V2lkdGggPiAwICYmIGVsWzBdLm9mZnNldEhlaWdodCA+IDA7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBpc0VsZW1lbnRWaXNpYmxlOiBpc0VsZW1lbnRWaXNpYmxlXG4gIH07XG59XG5cbmZ1bmN0aW9uIFZhbGlkYXRpb25NYW5hZ2VyRm4odmFsaWRhdG9yLCBlbGVtZW50VXRpbHMpIHtcbiAgdmFyIGVsZW1lbnRUeXBlc1RvVmFsaWRhdGUgPSBbJ2lucHV0JywgJ3RleHRhcmVhJywgJ3NlbGVjdCcsICdmb3JtJ10sXG5cbiAgICBlbGVtZW50SXNWaXNpYmxlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICByZXR1cm4gZWxlbWVudFV0aWxzLmlzRWxlbWVudFZpc2libGUoZWwpO1xuICAgIH0sXG5cbiAgICBnZXRGb3JtT3B0aW9ucyA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgdmFyIGZybUN0cmwgPSBhbmd1bGFyLmVsZW1lbnQoZWwpLmNvbnRyb2xsZXIoJ2Zvcm0nKSxcbiAgICAgICAgb3B0aW9ucztcblxuICAgICAgaWYgKGZybUN0cmwgIT09IHVuZGVmaW5lZCAmJiBmcm1DdHJsICE9PSBudWxsKSB7XG4gICAgICAgIG9wdGlvbnMgPSBmcm1DdHJsLmF1dG9WYWxpZGF0ZUZvcm1PcHRpb25zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9ucyA9IHZhbGlkYXRvci5kZWZhdWx0Rm9ybVZhbGlkYXRpb25PcHRpb25zO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT25seSB2YWxpZGF0ZSBpZiB0aGUgZWxlbWVudCBpcyBwcmVzZW50LCBpdCBpcyB2aXNpYmxlLCBpZiBpdCBpcyBub3QgYSBjb21tZW50LFxuICAgICAqIGl0IGlzIGVpdGhlciBhIHZhbGlkIHVzZXIgaW5wdXQgY29udHJvbCAoaW5wdXQsIHNlbGVjdCwgdGV4dGFyZSwgZm9ybSkgb3JcbiAgICAgKiBpdCBpcyBhIGN1c3RvbSBjb250cm9sIHJlZ2lzdGVyIGJ5IHRoZSBkZXZlbG9wZXIuXG4gICAgICogQHBhcmFtIGVsXG4gICAgICogQHBhcmFtIGZvcm1PcHRpb25zIFRoZSB2YWxpZGF0aW9uIG9wdGlvbnMgb2YgdGhlIHBhcmVudCBmb3JtXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgdG8gaW5kaWNhdGUgaXQgc2hvdWxkIGJlIHZhbGlkYXRlZFxuICAgICAqL1xuICAgIHNob3VsZFZhbGlkYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChlbCwgZm9ybU9wdGlvbnMsIGZvcm1TdWJtaXR0ZWQpIHtcbiAgICAgIHZhciBlbGVtZW50RXhpc3RzID0gZWwgJiYgZWwubGVuZ3RoID4gMCxcbiAgICAgICAgaXNFbGVtZW50QUNvbW1lbnQgPSBlbGVtZW50RXhpc3RzICYmIGVsWzBdLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICcjY29tbWVudCcsXG4gICAgICAgIGNvcnJlY3RWaXNpYmlsaXR5VG9WYWxpZGF0ZSxcbiAgICAgICAgY29ycmVjdFR5cGVUb1ZhbGlkYXRlLFxuICAgICAgICBjb3JyZWN0UGhhc2VUb1ZhbGlkYXRlO1xuXG4gICAgICBpZiAoZWxlbWVudEV4aXN0cyAmJiBpc0VsZW1lbnRBQ29tbWVudCA9PT0gZmFsc2UpIHtcbiAgICAgICAgY29ycmVjdFZpc2liaWxpdHlUb1ZhbGlkYXRlID0gZWxlbWVudElzVmlzaWJsZShlbCkgfHwgZm9ybU9wdGlvbnMudmFsaWRhdGVOb25WaXNpYmxlQ29udHJvbHM7XG4gICAgICAgIGNvcnJlY3RUeXBlVG9WYWxpZGF0ZSA9IGVsZW1lbnRUeXBlc1RvVmFsaWRhdGUuaW5kZXhPZihlbFswXS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSA+IC0xIHx8XG4gICAgICAgICAgZWxbMF0uaGFzQXR0cmlidXRlKCdyZWdpc3Rlci1jdXN0b20tZm9ybS1jb250cm9sJyk7XG4gICAgICAgIGNvcnJlY3RQaGFzZVRvVmFsaWRhdGUgPSBmb3JtT3B0aW9ucy52YWxpZGF0ZU9uRm9ybVN1Ym1pdCA9PT0gZmFsc2UgfHxcbiAgICAgICAgICAoZm9ybU9wdGlvbnMudmFsaWRhdGVPbkZvcm1TdWJtaXQgPT09IHRydWUgJiYgZm9ybVN1Ym1pdHRlZCA9PT0gdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbGVtZW50RXhpc3RzICYmICFpc0VsZW1lbnRBQ29tbWVudCAmJiBjb3JyZWN0VmlzaWJpbGl0eVRvVmFsaWRhdGUgJiYgY29ycmVjdFR5cGVUb1ZhbGlkYXRlICYmIGNvcnJlY3RQaGFzZVRvVmFsaWRhdGU7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5nZG9jIHZhbGlkYXRlRWxlbWVudFxuICAgICAqIEBuYW1lIHZhbGlkYXRpb24jdmFsaWRhdGVFbGVtZW50XG4gICAgICogQHBhcmFtIHtvYmplY3R9IG1vZGVsQ3RybCBob2xkcyB0aGUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGVsZW1lbnQgZS5nLiAkaW52YWxpZCwgJHZhbGlkXG4gICAgICogQHBhcmFtIHtvcHRpb25zfVxuICAgICAqICAtIGZvcmNlVmFsaWRhdGlvbiBpZiBzZXQgdG8gdHJ1ZSBmb3JjZXMgdGhlIHZhbGlkYXRpb24gZXZlbiBpZiB0aGUgZWxlbWVudCBpcyBwcmlzdGluZVxuICAgICAqICAtIGRpc2FibGVkIGlmIHNldCB0byB0cnVlIGZvcmNlcyB0aGUgdmFsaWRhdGlvbiBpcyBkaXNhYmxlZCBhbmQgd2lsbCByZXR1cm4gdHJ1ZVxuICAgICAqICAtIHZhbGlkYXRlTm9uVmlzaWJsZUNvbnRyb2xzIGlmIHNldCB0byB0cnVlIGZvcmNlcyB0aGUgdmFsaWRhdGlvbiBvZiBub24gdmlzaWJsZSBlbGVtZW50IGkuZS4gZGlzcGxheTpibG9ja1xuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFZhbGlkYXRlIHRoZSBmb3JtIGVsZW1lbnQgYW5kIG1ha2UgaW52YWxpZC92YWxpZCBlbGVtZW50IG1vZGVsIHN0YXR1cy5cbiAgICAgKlxuICAgICAqIEFzIG9mIHYxLjE3LjIyOlxuICAgICAqIEJSRUFLSU5HIENIQU5HRSB0byB2YWxpZGF0ZUVsZW1lbnQgb24gdGhlIHZhbGlkYXRpb25NYW5nZXIuICBUaGUgdGhpcmQgcGFyYW1ldGVyIGlzIG5vdyB0aGUgcGFyZW50IGZvcm0nc1xuICAgICAqIGF1dG9WYWxpZGF0ZUZvcm1PcHRpb25zIG9iamVjdCBvbiB0aGUgZm9ybSBjb250cm9sbGVyLiAgVGhpcyBjYW4gYmUgbGVmdCBibGFuayBhbmQgd2lsbCBiZSBmb3VuZCBieSB0aGVcbiAgICAgKiB2YWxpZGF0aW9uTWFuYWdlci5cbiAgICAgKi9cbiAgICB2YWxpZGF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAobW9kZWxDdHJsLCBlbCwgb3B0aW9ucykge1xuICAgICAgdmFyIGlzVmFsaWQgPSB0cnVlLFxuICAgICAgICBmcm1PcHRpb25zID0gb3B0aW9ucyB8fCBnZXRGb3JtT3B0aW9ucyhlbCksXG4gICAgICAgIG5lZWRzVmFsaWRhdGlvbiA9IG1vZGVsQ3RybC4kcHJpc3RpbmUgPT09IGZhbHNlIHx8IGZybU9wdGlvbnMuZm9yY2VWYWxpZGF0aW9uLFxuICAgICAgICBlcnJvclR5cGUsXG4gICAgICAgIGZpbmRFcnJvclR5cGUgPSBmdW5jdGlvbiAoJGVycm9ycykge1xuICAgICAgICAgIHZhciBrZWVwR29pbmcgPSB0cnVlLFxuICAgICAgICAgICAgZXJyb3JUeXBlVG9SZXR1cm47XG4gICAgICAgICAgYW5ndWxhci5mb3JFYWNoKCRlcnJvcnMsIGZ1bmN0aW9uIChzdGF0dXMsIGVycm9ydHlwZSkge1xuICAgICAgICAgICAgaWYgKGtlZXBHb2luZyAmJiBzdGF0dXMpIHtcbiAgICAgICAgICAgICAga2VlcEdvaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgIGVycm9yVHlwZVRvUmV0dXJuID0gZXJyb3J0eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmV0dXJuIGVycm9yVHlwZVRvUmV0dXJuO1xuICAgICAgICB9O1xuXG4gICAgICBpZiAoZnJtT3B0aW9ucy5kaXNhYmxlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKChmcm1PcHRpb25zLmZvcmNlVmFsaWRhdGlvbiB8fFxuICAgICAgICAgICAgKHNob3VsZFZhbGlkYXRlRWxlbWVudChlbCwgZnJtT3B0aW9ucywgZnJtT3B0aW9ucy5nZXRGb3JtQ29udHJvbGxlcigpLiRzdWJtaXR0ZWQpICYmXG4gICAgICAgICAgICAgIG1vZGVsQ3RybCAmJlxuICAgICAgICAgICAgICBuZWVkc1ZhbGlkYXRpb24pKSkge1xuICAgICAgICAgIGlzVmFsaWQgPSAhbW9kZWxDdHJsLiRpbnZhbGlkO1xuXG4gICAgICAgICAgaWYgKGZybU9wdGlvbnMucmVtb3ZlRXh0ZXJuYWxWYWxpZGF0aW9uRXJyb3JzT25TdWJtaXQgJiYgbW9kZWxDdHJsLnJlbW92ZUFsbEV4dGVybmFsVmFsaWRhdGlvbikge1xuICAgICAgICAgICAgbW9kZWxDdHJsLnJlbW92ZUFsbEV4dGVybmFsVmFsaWRhdGlvbigpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpc1ZhbGlkKSB7XG4gICAgICAgICAgICB2YWxpZGF0b3IubWFrZVZhbGlkKGVsKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3JUeXBlID0gZmluZEVycm9yVHlwZShtb2RlbEN0cmwuJGVycm9ycyB8fCBtb2RlbEN0cmwuJGVycm9yKTtcbiAgICAgICAgICAgIGlmIChlcnJvclR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAvLyB3ZSBoYXZlIGEgd2VpcmQgc2l0dWF0aW9uIHNvbWUgdXNlcnMgYXJlIGVuY291bnRlcmluZyB3aGVyZSBhIGN1c3RvbSBjb250cm9sXG4gICAgICAgICAgICAgIC8vIGlzIHZhbGlkIGJ1dCB0aGUgbmdNb2RlbCBpcyByZXBvcnQgaXQgaXNuJ3QgYW5kIHRodXMgbm8gdmFsaWQgZXJyb3IgdHlwZSBjYW4gYmUgZm91bmRcbiAgICAgICAgICAgICAgaXNWYWxpZCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YWxpZGF0b3IuZ2V0RXJyb3JNZXNzYWdlKGVycm9yVHlwZSwgZWwpLnRoZW4oZnVuY3Rpb24gKGVycm9yTXNnKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdG9yLm1ha2VJbnZhbGlkKGVsLCBlcnJvck1zZyk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXNWYWxpZDtcbiAgICB9LFxuXG4gICAgcmVzZXRFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgIHZhbGlkYXRvci5tYWtlRGVmYXVsdChlbGVtZW50KTtcbiAgICB9LFxuXG4gICAgcmVzZXRGb3JtID0gZnVuY3Rpb24gKGZybUVsZW1lbnQpIHtcbiAgICAgIGFuZ3VsYXIuZm9yRWFjaCgoZnJtRWxlbWVudFswXS5hbGwgfHwgZnJtRWxlbWVudFswXS5lbGVtZW50cykgfHwgZnJtRWxlbWVudFswXSwgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGNvbnRyb2xsZXIsXG4gICAgICAgICAgY3RybEVsZW1lbnQgPSBhbmd1bGFyLmVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgIGNvbnRyb2xsZXIgPSBjdHJsRWxlbWVudC5jb250cm9sbGVyKCduZ01vZGVsJyk7XG5cbiAgICAgICAgaWYgKGNvbnRyb2xsZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChjdHJsRWxlbWVudFswXS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnZm9ybScpIHtcbiAgICAgICAgICAgIC8vIHdlIHByb2JhYmx5IGhhdmUgYSBzdWIgZm9ybVxuICAgICAgICAgICAgcmVzZXRGb3JtKGN0cmxFbGVtZW50KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udHJvbGxlci4kc2V0UHJpc3RpbmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICB2YWxpZGF0ZUZvcm0gPSBmdW5jdGlvbiAoZnJtRWxlbWVudCkge1xuICAgICAgdmFyIGZybVZhbGlkID0gdHJ1ZSxcbiAgICAgICAgZnJtQ3RybCA9IGZybUVsZW1lbnQgPyBhbmd1bGFyLmVsZW1lbnQoZnJtRWxlbWVudCkuY29udHJvbGxlcignZm9ybScpIDogdW5kZWZpbmVkLFxuICAgICAgICBwcm9jZXNzRWxlbWVudCA9IGZ1bmN0aW9uIChjdHJsRWxlbWVudCwgZm9yY2UsIGZvcm1PcHRpb25zKSB7XG4gICAgICAgICAgdmFyIGNvbnRyb2xsZXIsIGlzVmFsaWQsIGN0cmxGb3JtT3B0aW9ucywgb3JpZ2luYWxGb3JjZVZhbHVlO1xuXG4gICAgICAgICAgY3RybEVsZW1lbnQgPSBhbmd1bGFyLmVsZW1lbnQoY3RybEVsZW1lbnQpO1xuICAgICAgICAgIGNvbnRyb2xsZXIgPSBjdHJsRWxlbWVudC5jb250cm9sbGVyKCduZ01vZGVsJyk7XG5cbiAgICAgICAgICBpZiAoY29udHJvbGxlciAhPT0gdW5kZWZpbmVkICYmIChmb3JjZSB8fCBzaG91bGRWYWxpZGF0ZUVsZW1lbnQoY3RybEVsZW1lbnQsIGZvcm1PcHRpb25zLCBmcm1DdHJsLiRzdWJtaXR0ZWQpKSkge1xuICAgICAgICAgICAgaWYgKGN0cmxFbGVtZW50WzBdLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdmb3JtJykge1xuICAgICAgICAgICAgICAvLyB3ZSBwcm9iYWJseSBoYXZlIGEgc3ViIGZvcm1cbiAgICAgICAgICAgICAgdmFsaWRhdGVGb3JtKGN0cmxFbGVtZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gZ2V0IHRoZSBvcHRpb25zIGZvciB0aGUgZWxlbWVudCByYXRoZXIgdGhhbiB1c2UgdGhlIHBhc3NlZCBpbiBhcyB0aGVcbiAgICAgICAgICAgICAgLy8gZWxlbWVudCBjb3VsZCBiZSBhbiBuZy1mb3JtIGFuZCBoYXZlIGRpZmZlcmVudCBvcHRpb25zIHRvIHRoZSBwYXJlbnQgZm9ybS5cbiAgICAgICAgICAgICAgY3RybEZvcm1PcHRpb25zID0gZ2V0Rm9ybU9wdGlvbnMoY3RybEVsZW1lbnQpO1xuICAgICAgICAgICAgICBvcmlnaW5hbEZvcmNlVmFsdWUgPSBjdHJsRm9ybU9wdGlvbnMuZm9yY2VWYWxpZGF0aW9uO1xuICAgICAgICAgICAgICBjdHJsRm9ybU9wdGlvbnMuZm9yY2VWYWxpZGF0aW9uID0gZm9yY2U7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaXNWYWxpZCA9IHZhbGlkYXRlRWxlbWVudChjb250cm9sbGVyLCBjdHJsRWxlbWVudCwgY3RybEZvcm1PcHRpb25zKTtcbiAgICAgICAgICAgICAgICBmcm1WYWxpZCA9IGZybVZhbGlkICYmIGlzVmFsaWQ7XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgY3RybEZvcm1PcHRpb25zLmZvcmNlVmFsaWRhdGlvbiA9IG9yaWdpbmFsRm9yY2VWYWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY2xvbmVkT3B0aW9ucztcblxuICAgICAgaWYgKGZybUVsZW1lbnQgPT09IHVuZGVmaW5lZCB8fCAoZnJtQ3RybCAhPT0gdW5kZWZpbmVkICYmIGZybUN0cmwuYXV0b1ZhbGlkYXRlRm9ybU9wdGlvbnMuZGlzYWJsZWQpKSB7XG4gICAgICAgIHJldHVybiBmcm1FbGVtZW50ICE9PSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIC8vZm9yY2UgdGhlIHZhbGlkYXRpb24gb2YgY29udHJvbHNcbiAgICAgIGNsb25lZE9wdGlvbnMgPSBhbmd1bGFyLmNvcHkoZnJtQ3RybC5hdXRvVmFsaWRhdGVGb3JtT3B0aW9ucyk7XG4gICAgICBjbG9uZWRPcHRpb25zLmZvcmNlVmFsaWRhdGlvbiA9IHRydWU7XG5cbiAgICAgIC8vIElFOCBob2xkcyB0aGUgY2hpbGQgY29udHJvbHMgY29sbGVjdGlvbiBpbiB0aGUgYWxsIHByb3BlcnR5XG4gICAgICAvLyBGaXJlZm94IGluIHRoZSBlbGVtZW50cyBhbmQgY2hyb21lIGFzIGEgY2hpbGQgaXRlcmF0b3JcbiAgICAgIGFuZ3VsYXIuZm9yRWFjaCgoZnJtRWxlbWVudFswXS5lbGVtZW50cyB8fCBmcm1FbGVtZW50WzBdLmFsbCkgfHwgZnJtRWxlbWVudFswXSwgZnVuY3Rpb24gKGN0cmxFbGVtZW50KSB7XG4gICAgICAgIHByb2Nlc3NFbGVtZW50KGN0cmxFbGVtZW50LCB0cnVlLCBjbG9uZWRPcHRpb25zKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBJZiB5b3UgaGF2ZSBhIGN1c3RvbSBmb3JtIGNvbnRyb2wgdGhhdCBzaG91bGQgYmUgdmFsaWRhdGVkIGkuZS5cbiAgICAgIC8vIDxteS1jdXN0b20tZWxlbWVudD4uLi48L215LWN1c3RvbS1lbGVtZW50PiBpdCB3aWxsIG5vdCBiZSBwYXJ0IG9mIHRoZSBmb3Jtc1xuICAgICAgLy8gSFRNTEZvcm1Db250cm9sc0NvbGxlY3Rpb24gYW5kIHRodXMgd29uJ3QgYmUgaW5jbHVkZWQgaW4gdGhlIGFib3ZlIGVsZW1lbnQgaXRlcmF0aW9uIGFsdGhvdWdoXG4gICAgICAvLyBpdCB3aWxsIGJlIG9uIHRoZSBBbmd1bGFyIEZvcm1Db250cm9sbGVyIChpZiBpdCBoYXMgYSBuYW1lIGF0dHJpYnV0ZSkuICBTbyBhZGRpbmcgdGhlIGRpcmVjdGl2ZVxuICAgICAgLy8gcmVnaXN0ZXItY3VzdG9tLWZvcm0tY29udHJvbD1cIlwiIHRvIHRoZSBjb250cm9sIHJvb3QgYW5kIGF1dG9WYWxpZGF0ZSB3aWxsIGluY2x1ZGUgaXQgaW4gdGhpc1xuICAgICAgLy8gaXRlcmF0aW9uLlxuICAgICAgaWYgKGZybUVsZW1lbnRbMF0uY3VzdG9tSFRNTEZvcm1Db250cm9sc0NvbGxlY3Rpb24pIHtcbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKGZybUVsZW1lbnRbMF0uY3VzdG9tSFRNTEZvcm1Db250cm9sc0NvbGxlY3Rpb24sIGZ1bmN0aW9uIChjdHJsRWxlbWVudCkge1xuICAgICAgICAgIC8vIG5lZWQgdG8gZm9yY2UgdGhlIHZhbGlkYXRpb24gYXMgdGhlIGVsZW1lbnQgbWlnaHQgbm90IGJlIGEga25vd24gZm9ybSBpbnB1dCB0eXBlXG4gICAgICAgICAgLy8gc28gdGhlIG5vcm1hbCB2YWxpZGF0aW9uIHByb2Nlc3Mgd2lsbCBpZ25vcmUgaXQuXG4gICAgICAgICAgcHJvY2Vzc0VsZW1lbnQoY3RybEVsZW1lbnQsIHRydWUsIGNsb25lZE9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZybVZhbGlkO1xuICAgIH0sXG5cbiAgICBzZXRFbGVtZW50VmFsaWRhdGlvbkVycm9yID0gZnVuY3Rpb24gKGVsZW1lbnQsIGVycm9yTXNnS2V5LCBlcnJvck1zZykge1xuICAgICAgaWYgKGVycm9yTXNnS2V5KSB7XG4gICAgICAgIHZhbGlkYXRvci5nZXRFcnJvck1lc3NhZ2UoZXJyb3JNc2dLZXksIGVsZW1lbnQpLnRoZW4oZnVuY3Rpb24gKG1zZykge1xuICAgICAgICAgIHZhbGlkYXRvci5tYWtlSW52YWxpZChlbGVtZW50LCBtc2cpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbGlkYXRvci5tYWtlSW52YWxpZChlbGVtZW50LCBlcnJvck1zZyk7XG4gICAgICB9XG4gICAgfTtcblxuICByZXR1cm4ge1xuICAgIHNldEVsZW1lbnRWYWxpZGF0aW9uRXJyb3I6IHNldEVsZW1lbnRWYWxpZGF0aW9uRXJyb3IsXG4gICAgdmFsaWRhdGVFbGVtZW50OiB2YWxpZGF0ZUVsZW1lbnQsXG4gICAgdmFsaWRhdGVGb3JtOiB2YWxpZGF0ZUZvcm0sXG4gICAgcmVzZXRFbGVtZW50OiByZXNldEVsZW1lbnQsXG4gICAgcmVzZXRGb3JtOiByZXNldEZvcm1cbiAgfTtcbn1cblxuVmFsaWRhdGlvbk1hbmFnZXJGbi4kaW5qZWN0ID0gW1xuICAndmFsaWRhdG9yJyxcbiAgJ2pjcy1lbGVtZW50VXRpbHMnXG5dO1xuXG5hbmd1bGFyLm1vZHVsZSgnamNzLWF1dG9WYWxpZGF0ZScpLmZhY3RvcnkoJ2pjcy1lbGVtZW50VXRpbHMnLCBFbGVtZW50VXRpbHNGbik7XG5hbmd1bGFyLm1vZHVsZSgnamNzLWF1dG9WYWxpZGF0ZScpLmZhY3RvcnkoJ3ZhbGlkYXRpb25NYW5hZ2VyJywgVmFsaWRhdGlvbk1hbmFnZXJGbik7XG5cclxuZnVuY3Rpb24gcGFyc2VCb29sZWFuQXR0cmlidXRlVmFsdWUodmFsLCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKCh2YWwgPT09IHVuZGVmaW5lZCB8fCB2YWwgPT09IG51bGwpICYmIGRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsICE9PSAnZmFsc2UnO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlT3B0aW9ucyhjdHJsLCB2YWxpZGF0b3IsIGF0dHJzKSB7XG4gIHZhciBvcHRzID0gY3RybC5hdXRvVmFsaWRhdGVGb3JtT3B0aW9ucyA9IGN0cmwuYXV0b1ZhbGlkYXRlRm9ybU9wdGlvbnMgfHwgYW5ndWxhci5jb3B5KHZhbGlkYXRvci5kZWZhdWx0Rm9ybVZhbGlkYXRpb25PcHRpb25zKTtcblxuICAvLyBuZWVkZWQgdG8gc3RvcCBjaXJjdWxhciByZWYgaW4ganNvbiBzZXJpYWxpc2F0aW9uXG4gIG9wdHMuZ2V0Rm9ybUNvbnRyb2xsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGN0cmw7XG4gIH07XG4gIG9wdHMuZm9yY2VWYWxpZGF0aW9uID0gZmFsc2U7XG4gIG9wdHMuZGlzYWJsZWQgPSAhdmFsaWRhdG9yLmlzRW5hYmxlZCgpIHx8IHBhcnNlQm9vbGVhbkF0dHJpYnV0ZVZhbHVlKGF0dHJzLmRpc2FibGVEeW5hbWljVmFsaWRhdGlvbiwgb3B0cy5kaXNhYmxlZCk7XG4gIG9wdHMudmFsaWRhdGVOb25WaXNpYmxlQ29udHJvbHMgPSBwYXJzZUJvb2xlYW5BdHRyaWJ1dGVWYWx1ZShhdHRycy52YWxpZGF0ZU5vblZpc2libGVDb250cm9scywgb3B0cy52YWxpZGF0ZU5vblZpc2libGVDb250cm9scyk7XG4gIG9wdHMudmFsaWRhdGVPbkZvcm1TdWJtaXQgPSBwYXJzZUJvb2xlYW5BdHRyaWJ1dGVWYWx1ZShhdHRycy52YWxpZGF0ZU9uRm9ybVN1Ym1pdCwgb3B0cy52YWxpZGF0ZU9uRm9ybVN1Ym1pdCk7XG4gIG9wdHMucmVtb3ZlRXh0ZXJuYWxWYWxpZGF0aW9uRXJyb3JzT25TdWJtaXQgPSBhdHRycy5yZW1vdmVFeHRlcm5hbFZhbGlkYXRpb25FcnJvcnNPblN1Ym1pdCA9PT0gdW5kZWZpbmVkID9cbiAgICBvcHRzLnJlbW92ZUV4dGVybmFsVmFsaWRhdGlvbkVycm9yc09uU3VibWl0IDpcbiAgICBwYXJzZUJvb2xlYW5BdHRyaWJ1dGVWYWx1ZShhdHRycy5yZW1vdmVFeHRlcm5hbFZhbGlkYXRpb25FcnJvcnNPblN1Ym1pdCwgb3B0cy5yZW1vdmVFeHRlcm5hbFZhbGlkYXRpb25FcnJvcnNPblN1Ym1pdCk7XG5cbiAgLy8gdGhlIGxpYnJhcnkgbWlnaHQgYmUgZ2xvYmFsbHkgZGlzYWJsZWQgYnV0IGVuYWJsZWQgb24gYSBwYXJ0aWN1bGFyIGZvcm0gc28gY2hlY2sgdGhlXG4gIC8vIGRpc2FibGVEeW5hbWljVmFsaWRhdGlvbiBhdHRyaWJ1dGUgaXMgb24gdGhlIGZvcm1cbiAgaWYgKHZhbGlkYXRvci5pc0VuYWJsZWQoKSA9PT0gZmFsc2UgJiYgYXR0cnMuZGlzYWJsZUR5bmFtaWNWYWxpZGF0aW9uID09PSAnZmFsc2UnKSB7XG4gICAgb3B0cy5kaXNhYmxlZCA9IGZhbHNlO1xuICB9XG59XG5cbmFuZ3VsYXIubW9kdWxlKCdqY3MtYXV0b1ZhbGlkYXRlJykuZGlyZWN0aXZlKCdmb3JtJywgW1xuICAndmFsaWRhdG9yJyxcbiAgZnVuY3Rpb24gKHZhbGlkYXRvcikge1xuICAgIHJldHVybiB7XG4gICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgcmVxdWlyZTogJ2Zvcm0nLFxuICAgICAgcHJpb3JpdHk6IDk5OTksXG4gICAgICBjb21waWxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcHJlOiBmdW5jdGlvbiAoc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBjdHJsKSB7XG4gICAgICAgICAgICBwYXJzZU9wdGlvbnMoY3RybCwgdmFsaWRhdG9yLCBhdHRycyk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cbl0pO1xuXG5hbmd1bGFyLm1vZHVsZSgnamNzLWF1dG9WYWxpZGF0ZScpLmRpcmVjdGl2ZSgnbmdGb3JtJywgW1xuICAndmFsaWRhdG9yJyxcbiAgZnVuY3Rpb24gKHZhbGlkYXRvcikge1xuICAgIHJldHVybiB7XG4gICAgICByZXN0cmljdDogJ0VBJyxcbiAgICAgIHJlcXVpcmU6ICdmb3JtJyxcbiAgICAgIHByaW9yaXR5OiA5OTk5LFxuICAgICAgY29tcGlsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHByZTogZnVuY3Rpb24gKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY3RybCkge1xuICAgICAgICAgICAgcGFyc2VPcHRpb25zKGN0cmwsIHZhbGlkYXRvciwgYXR0cnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5dKTtcblxyXG5mdW5jdGlvbiBGb3JtUmVzZXREaXJlY3RpdmVGbih2YWxpZGF0aW9uTWFuYWdlcikge1xuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OiAnRScsXG4gICAgbGluazogZnVuY3Rpb24gKHNjb3BlLCBlbCkge1xuICAgICAgdmFyIGZvcm1Db250cm9sbGVyID0gZWwuY29udHJvbGxlcignZm9ybScpO1xuXG4gICAgICBmdW5jdGlvbiByZXNldEZuKCkge1xuICAgICAgICB2YWxpZGF0aW9uTWFuYWdlci5yZXNldEZvcm0oZWwpO1xuICAgICAgICBpZiAoZm9ybUNvbnRyb2xsZXIuJHNldFByaXN0aW5lKSB7XG4gICAgICAgICAgZm9ybUNvbnRyb2xsZXIuJHNldFByaXN0aW5lKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZm9ybUNvbnRyb2xsZXIuJHNldFVudG91Y2hlZCkge1xuICAgICAgICAgIGZvcm1Db250cm9sbGVyLiRzZXRVbnRvdWNoZWQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZm9ybUNvbnRyb2xsZXIgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBmb3JtQ29udHJvbGxlci5hdXRvVmFsaWRhdGVGb3JtT3B0aW9ucyAmJlxuICAgICAgICBmb3JtQ29udHJvbGxlci5hdXRvVmFsaWRhdGVGb3JtT3B0aW9ucy5kaXNhYmxlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgZWwub24oJ3Jlc2V0JywgcmVzZXRGbik7XG5cbiAgICAgICAgc2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbC5vZmYoJ3Jlc2V0JywgcmVzZXRGbik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuRm9ybVJlc2V0RGlyZWN0aXZlRm4uJGluamVjdCA9IFtcbiAgJ3ZhbGlkYXRpb25NYW5hZ2VyJ1xuXTtcblxuYW5ndWxhci5tb2R1bGUoJ2pjcy1hdXRvVmFsaWRhdGUnKS5kaXJlY3RpdmUoJ2Zvcm0nLCBGb3JtUmVzZXREaXJlY3RpdmVGbik7XG5cclxuZnVuY3Rpb24gUmVnaXN0ZXJDdXN0b21Gb3JtQ29udHJvbEZuKCkge1xuICB2YXIgZmluZFBhcmVudEZvcm0gPSBmdW5jdGlvbiAoZWwpIHtcbiAgICB2YXIgcGFyZW50ID0gZWw7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gNTA7IGkgKz0gMSkge1xuICAgICAgaWYgKHBhcmVudCAhPT0gdW5kZWZpbmVkICYmIHBhcmVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnZm9ybScpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKHBhcmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBhcmVudCA9IGFuZ3VsYXIuZWxlbWVudChwYXJlbnQpLnBhcmVudCgpWzBdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwYXJlbnQ7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0EnLFxuICAgIGxpbms6IGZ1bmN0aW9uIChzY29wZSwgZWxlbWVudCkge1xuICAgICAgdmFyIGZybUVsID0gZmluZFBhcmVudEZvcm0oZWxlbWVudC5wYXJlbnQoKVswXSk7XG4gICAgICBpZiAoZnJtRWwpIHtcbiAgICAgICAgZnJtRWwuY3VzdG9tSFRNTEZvcm1Db250cm9sc0NvbGxlY3Rpb24gPSBmcm1FbC5jdXN0b21IVE1MRm9ybUNvbnRyb2xzQ29sbGVjdGlvbiB8fCBbXTtcbiAgICAgICAgZnJtRWwuY3VzdG9tSFRNTEZvcm1Db250cm9sc0NvbGxlY3Rpb24ucHVzaChlbGVtZW50WzBdKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmFuZ3VsYXIubW9kdWxlKCdqY3MtYXV0b1ZhbGlkYXRlJykuZGlyZWN0aXZlKCdyZWdpc3RlckN1c3RvbUZvcm1Db250cm9sJywgUmVnaXN0ZXJDdXN0b21Gb3JtQ29udHJvbEZuKTtcblxyXG5mdW5jdGlvbiBTdWJtaXREZWNvcmF0b3IoJGRlbGVnYXRlLCAkcGFyc2UsIHZhbGlkYXRpb25NYW5hZ2VyKSB7XG4gICRkZWxlZ2F0ZVswXS5jb21waWxlID0gZnVuY3Rpb24gKCRlbGVtZW50LCBhdHRycykge1xuICAgIHZhciBmbiA9ICRwYXJzZShhdHRycy5uZ1N1Ym1pdCksXG4gICAgICBmb3JjZSA9IGF0dHJzLm5nU3VibWl0Rm9yY2UgPT09ICd0cnVlJztcblxuICAgIHJldHVybiBmdW5jdGlvbiAoc2NvcGUsIGVsZW1lbnQpIHtcbiAgICAgIHZhciBmb3JtQ29udHJvbGxlciA9IGVsZW1lbnQuY29udHJvbGxlcignZm9ybScpLFxuICAgICAgICByZXNldExpc3RlbmVyT2ZmRm47XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZXJGbihldmVudCkge1xuICAgICAgICBzY29wZS4kYXBwbHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChmb3JtQ29udHJvbGxlciAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBmb3JtQ29udHJvbGxlciAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgZm9ybUNvbnRyb2xsZXIuYXV0b1ZhbGlkYXRlRm9ybU9wdGlvbnMgJiZcbiAgICAgICAgICAgIGZvcm1Db250cm9sbGVyLmF1dG9WYWxpZGF0ZUZvcm1PcHRpb25zLmRpc2FibGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICBmbihzY29wZSwge1xuICAgICAgICAgICAgICAkZXZlbnQ6IGV2ZW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZvcm1Db250cm9sbGVyLiRzZXRTdWJtaXR0ZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAvLyB3ZSBwcm9iYWJseSBoYXZlIGFuZ3VsYXIgPD0gMS4yXG4gICAgICAgICAgICAgIGZvcm1Db250cm9sbGVyLiRzdWJtaXR0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodmFsaWRhdGlvbk1hbmFnZXIudmFsaWRhdGVGb3JtKGVsZW1lbnQpIHx8IGZvcmNlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIGZuKHNjb3BlLCB7XG4gICAgICAgICAgICAgICAgJGV2ZW50OiBldmVudFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiByZXNldEZvcm1GbigpIHtcbiAgICAgICAgaWYgKGVsZW1lbnRbMF0ucmVzZXQpIHtcbiAgICAgICAgICBlbGVtZW50WzBdLnJlc2V0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsaWRhdGlvbk1hbmFnZXIucmVzZXRGb3JtKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmb3JtQ29udHJvbGxlciAmJiBmb3JtQ29udHJvbGxlci5hdXRvVmFsaWRhdGVGb3JtT3B0aW9ucykge1xuICAgICAgICAvLyBhbGxvdyB0aGUgZm9ybSB0byBiZSByZXNldCBwcm9ncmFtYXRpY2FsbHkgb3IgdmlhIHJhaXNpbmcgdGhlIGV2ZW50XG4gICAgICAgIC8vIGZvcm06Zm9ybU5hbWU6cmVzZXRcbiAgICAgICAgZm9ybUNvbnRyb2xsZXIuYXV0b1ZhbGlkYXRlRm9ybU9wdGlvbnMucmVzZXRGb3JtID0gcmVzZXRGb3JtRm47XG4gICAgICAgIGlmIChmb3JtQ29udHJvbGxlci4kbmFtZSAhPT0gdW5kZWZpbmVkICYmIGZvcm1Db250cm9sbGVyLiRuYW1lICE9PSAnJykge1xuICAgICAgICAgIHJlc2V0TGlzdGVuZXJPZmZGbiA9IHNjb3BlLiRvbignZm9ybTonICsgZm9ybUNvbnRyb2xsZXIuJG5hbWUgKyAnOnJlc2V0JywgcmVzZXRGb3JtRm4pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGVsZW1lbnQub24oJ3N1Ym1pdCcsIGhhbmRsZXJGbik7XG4gICAgICBzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24gKCkge1xuICAgICAgICBlbGVtZW50Lm9mZignc3VibWl0JywgaGFuZGxlckZuKTtcbiAgICAgICAgaWYgKHJlc2V0TGlzdGVuZXJPZmZGbikge1xuICAgICAgICAgIHJlc2V0TGlzdGVuZXJPZmZGbigpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICB9O1xuXG4gIHJldHVybiAkZGVsZWdhdGU7XG59XG5cblN1Ym1pdERlY29yYXRvci4kaW5qZWN0ID0gW1xuICAnJGRlbGVnYXRlJyxcbiAgJyRwYXJzZScsXG4gICd2YWxpZGF0aW9uTWFuYWdlcidcbl07XG5cbmZ1bmN0aW9uIFByb3ZpZGVyRm4oJHByb3ZpZGUpIHtcbiAgJHByb3ZpZGUuZGVjb3JhdG9yKCduZ1N1Ym1pdERpcmVjdGl2ZScsIFN1Ym1pdERlY29yYXRvcik7XG59XG5cblByb3ZpZGVyRm4uJGluamVjdCA9IFtcbiAgJyRwcm92aWRlJ1xuXTtcblxuYW5ndWxhci5tb2R1bGUoJ2pjcy1hdXRvVmFsaWRhdGUnKS5jb25maWcoUHJvdmlkZXJGbik7XG5cclxuYW5ndWxhci5tb2R1bGUoJ2pjcy1hdXRvVmFsaWRhdGUnKS5jb25maWcoWyckcHJvdmlkZScsXG4gIGZ1bmN0aW9uICgkcHJvdmlkZSkge1xuICAgICRwcm92aWRlLmRlY29yYXRvcignbmdNb2RlbERpcmVjdGl2ZScsIFtcbiAgICAgICckdGltZW91dCcsXG4gICAgICAnJGRlbGVnYXRlJyxcbiAgICAgICd2YWxpZGF0aW9uTWFuYWdlcicsXG4gICAgICAnamNzLWRlYm91bmNlJyxcbiAgICAgIGZ1bmN0aW9uICgkdGltZW91dCwgJGRlbGVnYXRlLCB2YWxpZGF0aW9uTWFuYWdlciwgZGVib3VuY2UpIHtcbiAgICAgICAgdmFyIGRpcmVjdGl2ZSA9ICRkZWxlZ2F0ZVswXSxcbiAgICAgICAgICBsaW5rID0gZGlyZWN0aXZlLmxpbmsgfHwgZGlyZWN0aXZlLmNvbXBpbGU7XG5cbiAgICAgICAgZGlyZWN0aXZlLmNvbXBpbGUgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICB2YXIgc3VwcG9ydHNOZ01vZGVsT3B0aW9ucyA9IGFuZ3VsYXIudmVyc2lvbi5tYWpvciA+PSAxICYmIGFuZ3VsYXIudmVyc2lvbi5taW5vciA+PSAzLFxuICAgICAgICAgICAgb3JpZ2luYWxMaW5rID0gbGluaztcblxuICAgICAgICAgIC8vIGluIHRoZSBSQyBvZiAxLjMgdGhlcmUgaXMgbm8gZGlyZWN0aXZlLmxpbmsgb25seSB0aGUgZGlyZWN0aXZlLmNvbXBpbGUgd2hpY2hcbiAgICAgICAgICAvLyBuZWVkcyB0byBiZSBpbnZva2VkIHRvIGdldCBhdCB0aGUgbGluayBmdW5jdGlvbnMuXG4gICAgICAgICAgaWYgKHN1cHBvcnRzTmdNb2RlbE9wdGlvbnMgJiYgYW5ndWxhci5pc0Z1bmN0aW9uKGxpbmspKSB7XG4gICAgICAgICAgICBvcmlnaW5hbExpbmsgPSBsaW5rKGVsKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJlOiBmdW5jdGlvbiAoc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBjdHJscykge1xuICAgICAgICAgICAgICB2YXIgbmdNb2RlbEN0cmwgPSBjdHJsc1swXSxcbiAgICAgICAgICAgICAgICBmcm1DdHJsID0gY3RybHNbMV0sXG4gICAgICAgICAgICAgICAgbmdNb2RlbE9wdGlvbnMgPSBhdHRycy5uZ01vZGVsT3B0aW9ucyA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogc2NvcGUuJGV2YWwoYXR0cnMubmdNb2RlbE9wdGlvbnMpLFxuICAgICAgICAgICAgICAgIHNldFZhbGlkaXR5ID0gbmdNb2RlbEN0cmwuJHNldFZhbGlkaXR5LFxuICAgICAgICAgICAgICAgIHNldFByaXN0aW5lID0gbmdNb2RlbEN0cmwuJHNldFByaXN0aW5lLFxuICAgICAgICAgICAgICAgIHNldFZhbGlkYXRpb25TdGF0ZSA9IGRlYm91bmNlLmRlYm91bmNlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHZhciB2YWxpZGF0ZU9wdGlvbnMgPSBmcm1DdHJsICE9PSB1bmRlZmluZWQgJiYgZnJtQ3RybCAhPT0gbnVsbCA/IGZybUN0cmwuYXV0b1ZhbGlkYXRlRm9ybU9wdGlvbnMgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uTWFuYWdlci52YWxpZGF0ZUVsZW1lbnQobmdNb2RlbEN0cmwsIGVsZW1lbnQsIHZhbGlkYXRlT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfSwgMTAwKTtcblxuICAgICAgICAgICAgICBpZiAoYXR0cnMuZm9ybW5vdmFsaWRhdGUgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIChmcm1DdHJsICE9PSB1bmRlZmluZWQgJiYgZnJtQ3RybCAhPT0gbnVsbCAmJiBmcm1DdHJsLmF1dG9WYWxpZGF0ZUZvcm1PcHRpb25zICYmXG4gICAgICAgICAgICAgICAgICBmcm1DdHJsLmF1dG9WYWxpZGF0ZUZvcm1PcHRpb25zLmRpc2FibGVkID09PSBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXN1cHBvcnRzTmdNb2RlbE9wdGlvbnMgfHwgbmdNb2RlbE9wdGlvbnMgPT09IHVuZGVmaW5lZCB8fCBuZ01vZGVsT3B0aW9ucy51cGRhdGVPbiA9PT0gdW5kZWZpbmVkIHx8IG5nTW9kZWxPcHRpb25zLnVwZGF0ZU9uID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgbmdNb2RlbEN0cmwuJHNldFZhbGlkaXR5ID0gZnVuY3Rpb24gKHZhbGlkYXRpb25FcnJvcktleSwgaXNWYWxpZCkge1xuICAgICAgICAgICAgICAgICAgICBzZXRWYWxpZGl0eS5jYWxsKG5nTW9kZWxDdHJsLCB2YWxpZGF0aW9uRXJyb3JLZXksIGlzVmFsaWQpO1xuICAgICAgICAgICAgICAgICAgICBzZXRWYWxpZGF0aW9uU3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGVsZW1lbnQub24obmdNb2RlbE9wdGlvbnMudXBkYXRlT24sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VmFsaWRhdGlvblN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgc2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5vZmYobmdNb2RlbE9wdGlvbnMudXBkYXRlT24pO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gV2Ugb3ZlcnJpZGUgdGhpcyBzbyB3ZSBjYW4gcmVzZXQgdGhlIGVsZW1lbnQgc3RhdGUgd2hlbiBpdCBpcyBjYWxsZWQuXG4gICAgICAgICAgICAgICAgbmdNb2RlbEN0cmwuJHNldFByaXN0aW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgc2V0UHJpc3RpbmUuY2FsbChuZ01vZGVsQ3RybCk7XG4gICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uTWFuYWdlci5yZXNldEVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIG5nTW9kZWxDdHJsLmF1dG9WYWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbmdNb2RlbEN0cmwuc2V0RXh0ZXJuYWxWYWxpZGF0aW9uID0gZnVuY3Rpb24gKGVycm9yTXNnS2V5LCBlcnJvck1lc3NhZ2UsIGFkZFRvTW9kZWxFcnJvcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWRkVG9Nb2RlbEVycm9ycykge1xuICAgICAgICAgICAgICAgICAgdmFyIGNvbGxlY3Rpb24gPSBuZ01vZGVsQ3RybC4kZXJyb3IgfHwgbmdNb2RlbEN0cmwuJGVycm9ycztcbiAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25bZXJyb3JNc2dLZXldID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbmdNb2RlbEN0cmwuZXh0ZXJuYWxFcnJvcnMgPSBuZ01vZGVsQ3RybC5leHRlcm5hbEVycm9ycyB8fCB7fTtcbiAgICAgICAgICAgICAgICBuZ01vZGVsQ3RybC5leHRlcm5hbEVycm9yc1tlcnJvck1zZ0tleV0gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB2YWxpZGF0aW9uTWFuYWdlci5zZXRFbGVtZW50VmFsaWRhdGlvbkVycm9yKGVsZW1lbnQsIGVycm9yTXNnS2V5LCBlcnJvck1lc3NhZ2UpO1xuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIG5nTW9kZWxDdHJsLnJlbW92ZUV4dGVybmFsVmFsaWRhdGlvbiA9IGZ1bmN0aW9uIChlcnJvck1zZ0tleSwgYWRkVG9Nb2RlbEVycm9ycykge1xuICAgICAgICAgICAgICAgIGlmIChhZGRUb01vZGVsRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY29sbGVjdGlvbiA9IG5nTW9kZWxDdHJsLiRlcnJvciB8fCBuZ01vZGVsQ3RybC4kZXJyb3JzO1xuICAgICAgICAgICAgICAgICAgZGVsZXRlIGNvbGxlY3Rpb25bZXJyb3JNc2dLZXldO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChuZ01vZGVsQ3RybC5leHRlcm5hbEVycm9ycykge1xuICAgICAgICAgICAgICAgICAgZGVsZXRlIG5nTW9kZWxDdHJsLmV4dGVybmFsRXJyb3JzW2Vycm9yTXNnS2V5XTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YWxpZGF0aW9uTWFuYWdlci5yZXNldEVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgbmdNb2RlbEN0cmwucmVtb3ZlQWxsRXh0ZXJuYWxWYWxpZGF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChuZ01vZGVsQ3RybC5leHRlcm5hbEVycm9ycykge1xuICAgICAgICAgICAgICAgICAgdmFyIGVycm9yQ29sbGVjdGlvbiA9IG5nTW9kZWxDdHJsLiRlcnJvciB8fCBuZ01vZGVsQ3RybC4kZXJyb3JzO1xuICAgICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKG5nTW9kZWxDdHJsLmV4dGVybmFsRXJyb3JzLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgZXJyb3JDb2xsZWN0aW9uW2tleV07XG4gICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgbmdNb2RlbEN0cmwuZXh0ZXJuYWxFcnJvcnMgPSB7fTtcblxuICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbk1hbmFnZXIucmVzZXRFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICBpZiAoZnJtQ3RybCkge1xuICAgICAgICAgICAgICAgIGZybUN0cmwuc2V0RXh0ZXJuYWxWYWxpZGF0aW9uID0gZnVuY3Rpb24gKG1vZGVsUHJvcGVydHksIGVycm9yTXNnS2V5LCBlcnJvck1lc3NhZ2VPdmVycmlkZSwgYWRkVG9Nb2RlbEVycm9ycykge1xuICAgICAgICAgICAgICAgICAgdmFyIHN1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIGlmIChmcm1DdHJsW21vZGVsUHJvcGVydHldKSB7XG4gICAgICAgICAgICAgICAgICAgIGZybUN0cmxbbW9kZWxQcm9wZXJ0eV0uc2V0RXh0ZXJuYWxWYWxpZGF0aW9uKGVycm9yTXNnS2V5LCBlcnJvck1lc3NhZ2VPdmVycmlkZSwgYWRkVG9Nb2RlbEVycm9ycyk7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gc3VjY2VzcztcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgZnJtQ3RybC5yZW1vdmVFeHRlcm5hbFZhbGlkYXRpb24gPSBmdW5jdGlvbiAobW9kZWxQcm9wZXJ0eSwgZXJyb3JNc2dLZXksIGVycm9yTWVzc2FnZU92ZXJyaWRlLCBhZGRUb01vZGVsRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgc3VjY2VzcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgaWYgKGZybUN0cmxbbW9kZWxQcm9wZXJ0eV0pIHtcbiAgICAgICAgICAgICAgICAgICAgZnJtQ3RybFttb2RlbFByb3BlcnR5XS5yZW1vdmVFeHRlcm5hbFZhbGlkYXRpb24oZXJyb3JNc2dLZXksIGFkZFRvTW9kZWxFcnJvcnMpO1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3M7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbExpbmsucHJlID9cbiAgICAgICAgICAgICAgICBvcmlnaW5hbExpbmsucHJlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOlxuICAgICAgICAgICAgICAgIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcG9zdDogZnVuY3Rpb24gKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY3RybHMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsTGluay5wb3N0ID9cbiAgICAgICAgICAgICAgICBvcmlnaW5hbExpbmsucG9zdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDpcbiAgICAgICAgICAgICAgICBvcmlnaW5hbExpbmsuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiAkZGVsZWdhdGU7XG4gICAgICB9XG4gICAgXSk7XG4gIH1cbl0pO1xuXHJcbmZ1bmN0aW9uIEF1dG9WYWxpZGF0ZVJ1bkZuKHZhbGlkYXRvciwgZGVmYXVsdEVycm9yTWVzc2FnZVJlc29sdmVyLCBib290c3RyYXAzRWxlbWVudE1vZGlmaWVyLCBmb3VuZGF0aW9uNUVsZW1lbnRNb2RpZmllcikge1xuICB2YWxpZGF0b3Iuc2V0RXJyb3JNZXNzYWdlUmVzb2x2ZXIoZGVmYXVsdEVycm9yTWVzc2FnZVJlc29sdmVyLnJlc29sdmUpO1xuICB2YWxpZGF0b3IucmVnaXN0ZXJEb21Nb2RpZmllcihib290c3RyYXAzRWxlbWVudE1vZGlmaWVyLmtleSwgYm9vdHN0cmFwM0VsZW1lbnRNb2RpZmllcik7XG4gIHZhbGlkYXRvci5yZWdpc3RlckRvbU1vZGlmaWVyKGZvdW5kYXRpb241RWxlbWVudE1vZGlmaWVyLmtleSwgZm91bmRhdGlvbjVFbGVtZW50TW9kaWZpZXIpO1xuICB2YWxpZGF0b3Iuc2V0RGVmYXVsdEVsZW1lbnRNb2RpZmllcihib290c3RyYXAzRWxlbWVudE1vZGlmaWVyLmtleSk7XG59XG5cbkF1dG9WYWxpZGF0ZVJ1bkZuLiRpbmplY3QgPSBbXG4gICd2YWxpZGF0b3InLFxuICAnZGVmYXVsdEVycm9yTWVzc2FnZVJlc29sdmVyJyxcbiAgJ2Jvb3RzdHJhcDNFbGVtZW50TW9kaWZpZXInLFxuICAnZm91bmRhdGlvbjVFbGVtZW50TW9kaWZpZXInXG5dO1xuXG5hbmd1bGFyLm1vZHVsZSgnamNzLWF1dG9WYWxpZGF0ZScpLnJ1bihBdXRvVmFsaWRhdGVSdW5Gbik7XG5cclxufShTdHJpbmcsIGFuZ3VsYXIpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hbmd1bGFyLWF1dG8tdmFsaWRhdGUvZGlzdC9qY3MtYXV0by12YWxpZGF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	eval("/*!\n * Ladda 1.0.0 (2016-03-08, 09:31)\n * http://lab.hakim.se/ladda\n * MIT licensed\n *\n * Copyright (C) 2016 Hakim El Hattab, http://hakim.se\n */\n!function(a,b){ true?module.exports=b(__webpack_require__(9)):\"function\"==typeof define&&define.amd?define([\"spin\"],b):a.Ladda=b(a.Spinner)}(this,function(a){\"use strict\";function b(a){if(\"undefined\"==typeof a)return void console.warn(\"Ladda button target must be defined.\");if(/ladda-button/i.test(a.className)||(a.className+=\" ladda-button\"),a.hasAttribute(\"data-style\")||a.setAttribute(\"data-style\",\"expand-right\"),!a.querySelector(\".ladda-label\")){var b=document.createElement(\"span\");b.className=\"ladda-label\",i(a,b)}var c,d=a.querySelector(\".ladda-spinner\");d||(d=document.createElement(\"span\"),d.className=\"ladda-spinner\"),a.appendChild(d);var e,f={start:function(){return c||(c=g(a)),a.setAttribute(\"disabled\",\"\"),a.setAttribute(\"data-loading\",\"\"),clearTimeout(e),c.spin(d),this.setProgress(0),this},startAfter:function(a){return clearTimeout(e),e=setTimeout(function(){f.start()},a),this},stop:function(){return a.removeAttribute(\"disabled\"),a.removeAttribute(\"data-loading\"),clearTimeout(e),c&&(e=setTimeout(function(){c.stop()},1e3)),this},toggle:function(){return this.isLoading()?this.stop():this.start(),this},setProgress:function(b){b=Math.max(Math.min(b,1),0);var c=a.querySelector(\".ladda-progress\");0===b&&c&&c.parentNode?c.parentNode.removeChild(c):(c||(c=document.createElement(\"div\"),c.className=\"ladda-progress\",a.appendChild(c)),c.style.width=(b||0)*a.offsetWidth+\"px\")},enable:function(){return this.stop(),this},disable:function(){return this.stop(),a.setAttribute(\"disabled\",\"\"),this},isLoading:function(){return a.hasAttribute(\"data-loading\")},remove:function(){clearTimeout(e),a.removeAttribute(\"disabled\",\"\"),a.removeAttribute(\"data-loading\",\"\"),c&&(c.stop(),c=null);for(var b=0,d=j.length;d>b;b++)if(f===j[b]){j.splice(b,1);break}}};return j.push(f),f}function c(a,b){for(;a.parentNode&&a.tagName!==b;)a=a.parentNode;return b===a.tagName?a:void 0}function d(a){for(var b=[\"input\",\"textarea\",\"select\"],c=[],d=0;d<b.length;d++)for(var e=a.getElementsByTagName(b[d]),f=0;f<e.length;f++)e[f].hasAttribute(\"required\")&&c.push(e[f]);return c}function e(a,e){e=e||{};var f=[];\"string\"==typeof a?f=h(document.querySelectorAll(a)):\"object\"==typeof a&&\"string\"==typeof a.nodeName&&(f=[a]);for(var g=0,i=f.length;i>g;g++)!function(){var a=f[g];if(\"function\"==typeof a.addEventListener){var h=b(a),i=-1;a.addEventListener(\"click\",function(b){var f=!0,g=c(a,\"FORM\");if(\"undefined\"!=typeof g)if(\"function\"==typeof g.checkValidity)f=g.checkValidity();else for(var j=d(g),k=0;k<j.length;k++)\"\"===j[k].value.replace(/^\\s+|\\s+$/g,\"\")&&(f=!1),\"checkbox\"!==j[k].type&&\"radio\"!==j[k].type||j[k].checked||(f=!1),\"email\"===j[k].type&&(f=/^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$/.test(j[k].value));f&&(h.startAfter(1),\"number\"==typeof e.timeout&&(clearTimeout(i),i=setTimeout(h.stop,e.timeout)),\"function\"==typeof e.callback&&e.callback.apply(null,[h]))},!1)}}()}function f(){for(var a=0,b=j.length;b>a;a++)j[a].stop()}function g(b){var c,d,e=b.offsetHeight;0===e&&(e=parseFloat(window.getComputedStyle(b).height)),e>32&&(e*=.8),b.hasAttribute(\"data-spinner-size\")&&(e=parseInt(b.getAttribute(\"data-spinner-size\"),10)),b.hasAttribute(\"data-spinner-color\")&&(c=b.getAttribute(\"data-spinner-color\")),b.hasAttribute(\"data-spinner-lines\")&&(d=parseInt(b.getAttribute(\"data-spinner-lines\"),10));var f=.2*e,g=.6*f,h=7>f?2:3;return new a({color:c||\"#fff\",lines:d||12,radius:f,length:g,width:h,zIndex:\"auto\",top:\"auto\",left:\"auto\",className:\"\"})}function h(a){for(var b=[],c=0;c<a.length;c++)b.push(a[c]);return b}function i(a,b){var c=document.createRange();c.selectNodeContents(a),c.surroundContents(b),a.appendChild(b)}var j=[];return{bind:e,create:b,stopAll:f}});//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2xhZGRhL2Rpc3QvbGFkZGEubWluLmpzP2RiOGYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDZIQUE0SSxrQkFBa0IsYUFBYSxjQUFjLDBGQUEwRixpTEFBaUwscUNBQXFDLGlDQUFpQywwQ0FBMEMsbUZBQW1GLFNBQVMsaUJBQWlCLHNJQUFzSSx3QkFBd0IsK0NBQStDLFVBQVUsU0FBUyxpQkFBaUIsbUhBQW1ILFNBQVMsWUFBWSxtQkFBbUIsc0RBQXNELHlCQUF5Qiw0QkFBNEIseUNBQXlDLGdMQUFnTCxtQkFBbUIsd0JBQXdCLG9CQUFvQixzREFBc0Qsc0JBQXNCLHNDQUFzQyxtQkFBbUIsMkdBQTJHLHVCQUF1QixJQUFJLGlCQUFpQixjQUFjLFNBQVMsbUJBQW1CLGdCQUFnQixLQUFLLDRCQUE0QixnQkFBZ0IsOEJBQThCLGNBQWMsaURBQWlELFdBQVcsK0NBQStDLFdBQVcsZ0RBQWdELFNBQVMsZ0JBQWdCLFFBQVEsU0FBUyw4R0FBOEcsdUJBQXVCLElBQUksZ0JBQWdCLFdBQVcsMENBQTBDLGdCQUFnQix1Q0FBdUMsdUJBQXVCLG1GQUFtRix3QkFBd0IsV0FBVyxvTkFBb04sNEpBQTRKLE1BQU0sR0FBRyxhQUFhLHVCQUF1QixJQUFJLGdCQUFnQixjQUFjLHlCQUF5Qiw0VUFBNFUsNEJBQTRCLGNBQWMsd0dBQXdHLEVBQUUsY0FBYyxpQkFBaUIsV0FBVyxpQkFBaUIsU0FBUyxnQkFBZ0IsNkJBQTZCLCtEQUErRCxTQUFTLE9BQU8sMkJBQTJCIiwiZmlsZSI6IjguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIExhZGRhIDEuMC4wICgyMDE2LTAzLTA4LCAwOTozMSlcbiAqIGh0dHA6Ly9sYWIuaGFraW0uc2UvbGFkZGFcbiAqIE1JVCBsaWNlbnNlZFxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNiBIYWtpbSBFbCBIYXR0YWIsIGh0dHA6Ly9oYWtpbS5zZVxuICovXG4hZnVuY3Rpb24oYSxiKXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9tb2R1bGUuZXhwb3J0cz1iKHJlcXVpcmUoXCJzcGluLmpzXCIpKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcInNwaW5cIl0sYik6YS5MYWRkYT1iKGEuU3Bpbm5lcil9KHRoaXMsZnVuY3Rpb24oYSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYihhKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgYSlyZXR1cm4gdm9pZCBjb25zb2xlLndhcm4oXCJMYWRkYSBidXR0b24gdGFyZ2V0IG11c3QgYmUgZGVmaW5lZC5cIik7aWYoL2xhZGRhLWJ1dHRvbi9pLnRlc3QoYS5jbGFzc05hbWUpfHwoYS5jbGFzc05hbWUrPVwiIGxhZGRhLWJ1dHRvblwiKSxhLmhhc0F0dHJpYnV0ZShcImRhdGEtc3R5bGVcIil8fGEuc2V0QXR0cmlidXRlKFwiZGF0YS1zdHlsZVwiLFwiZXhwYW5kLXJpZ2h0XCIpLCFhLnF1ZXJ5U2VsZWN0b3IoXCIubGFkZGEtbGFiZWxcIikpe3ZhciBiPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO2IuY2xhc3NOYW1lPVwibGFkZGEtbGFiZWxcIixpKGEsYil9dmFyIGMsZD1hLnF1ZXJ5U2VsZWN0b3IoXCIubGFkZGEtc3Bpbm5lclwiKTtkfHwoZD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKSxkLmNsYXNzTmFtZT1cImxhZGRhLXNwaW5uZXJcIiksYS5hcHBlbmRDaGlsZChkKTt2YXIgZSxmPXtzdGFydDpmdW5jdGlvbigpe3JldHVybiBjfHwoYz1nKGEpKSxhLnNldEF0dHJpYnV0ZShcImRpc2FibGVkXCIsXCJcIiksYS5zZXRBdHRyaWJ1dGUoXCJkYXRhLWxvYWRpbmdcIixcIlwiKSxjbGVhclRpbWVvdXQoZSksYy5zcGluKGQpLHRoaXMuc2V0UHJvZ3Jlc3MoMCksdGhpc30sc3RhcnRBZnRlcjpmdW5jdGlvbihhKXtyZXR1cm4gY2xlYXJUaW1lb3V0KGUpLGU9c2V0VGltZW91dChmdW5jdGlvbigpe2Yuc3RhcnQoKX0sYSksdGhpc30sc3RvcDpmdW5jdGlvbigpe3JldHVybiBhLnJlbW92ZUF0dHJpYnV0ZShcImRpc2FibGVkXCIpLGEucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS1sb2FkaW5nXCIpLGNsZWFyVGltZW91dChlKSxjJiYoZT1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7Yy5zdG9wKCl9LDFlMykpLHRoaXN9LHRvZ2dsZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzTG9hZGluZygpP3RoaXMuc3RvcCgpOnRoaXMuc3RhcnQoKSx0aGlzfSxzZXRQcm9ncmVzczpmdW5jdGlvbihiKXtiPU1hdGgubWF4KE1hdGgubWluKGIsMSksMCk7dmFyIGM9YS5xdWVyeVNlbGVjdG9yKFwiLmxhZGRhLXByb2dyZXNzXCIpOzA9PT1iJiZjJiZjLnBhcmVudE5vZGU/Yy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGMpOihjfHwoYz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLGMuY2xhc3NOYW1lPVwibGFkZGEtcHJvZ3Jlc3NcIixhLmFwcGVuZENoaWxkKGMpKSxjLnN0eWxlLndpZHRoPShifHwwKSphLm9mZnNldFdpZHRoK1wicHhcIil9LGVuYWJsZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnN0b3AoKSx0aGlzfSxkaXNhYmxlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3RvcCgpLGEuc2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIixcIlwiKSx0aGlzfSxpc0xvYWRpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gYS5oYXNBdHRyaWJ1dGUoXCJkYXRhLWxvYWRpbmdcIil9LHJlbW92ZTpmdW5jdGlvbigpe2NsZWFyVGltZW91dChlKSxhLnJlbW92ZUF0dHJpYnV0ZShcImRpc2FibGVkXCIsXCJcIiksYS5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLWxvYWRpbmdcIixcIlwiKSxjJiYoYy5zdG9wKCksYz1udWxsKTtmb3IodmFyIGI9MCxkPWoubGVuZ3RoO2Q+YjtiKyspaWYoZj09PWpbYl0pe2ouc3BsaWNlKGIsMSk7YnJlYWt9fX07cmV0dXJuIGoucHVzaChmKSxmfWZ1bmN0aW9uIGMoYSxiKXtmb3IoO2EucGFyZW50Tm9kZSYmYS50YWdOYW1lIT09YjspYT1hLnBhcmVudE5vZGU7cmV0dXJuIGI9PT1hLnRhZ05hbWU/YTp2b2lkIDB9ZnVuY3Rpb24gZChhKXtmb3IodmFyIGI9W1wiaW5wdXRcIixcInRleHRhcmVhXCIsXCJzZWxlY3RcIl0sYz1bXSxkPTA7ZDxiLmxlbmd0aDtkKyspZm9yKHZhciBlPWEuZ2V0RWxlbWVudHNCeVRhZ05hbWUoYltkXSksZj0wO2Y8ZS5sZW5ndGg7ZisrKWVbZl0uaGFzQXR0cmlidXRlKFwicmVxdWlyZWRcIikmJmMucHVzaChlW2ZdKTtyZXR1cm4gY31mdW5jdGlvbiBlKGEsZSl7ZT1lfHx7fTt2YXIgZj1bXTtcInN0cmluZ1wiPT10eXBlb2YgYT9mPWgoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChhKSk6XCJvYmplY3RcIj09dHlwZW9mIGEmJlwic3RyaW5nXCI9PXR5cGVvZiBhLm5vZGVOYW1lJiYoZj1bYV0pO2Zvcih2YXIgZz0wLGk9Zi5sZW5ndGg7aT5nO2crKykhZnVuY3Rpb24oKXt2YXIgYT1mW2ddO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGEuYWRkRXZlbnRMaXN0ZW5lcil7dmFyIGg9YihhKSxpPS0xO2EuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsZnVuY3Rpb24oYil7dmFyIGY9ITAsZz1jKGEsXCJGT1JNXCIpO2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBnKWlmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGcuY2hlY2tWYWxpZGl0eSlmPWcuY2hlY2tWYWxpZGl0eSgpO2Vsc2UgZm9yKHZhciBqPWQoZyksaz0wO2s8ai5sZW5ndGg7aysrKVwiXCI9PT1qW2tdLnZhbHVlLnJlcGxhY2UoL15cXHMrfFxccyskL2csXCJcIikmJihmPSExKSxcImNoZWNrYm94XCIhPT1qW2tdLnR5cGUmJlwicmFkaW9cIiE9PWpba10udHlwZXx8altrXS5jaGVja2VkfHwoZj0hMSksXCJlbWFpbFwiPT09altrXS50eXBlJiYoZj0vXlthLXpBLVowLTlfListXStAW2EtekEtWjAtOS1dK1xcLlthLXpBLVowLTktLl0rJC8udGVzdChqW2tdLnZhbHVlKSk7ZiYmKGguc3RhcnRBZnRlcigxKSxcIm51bWJlclwiPT10eXBlb2YgZS50aW1lb3V0JiYoY2xlYXJUaW1lb3V0KGkpLGk9c2V0VGltZW91dChoLnN0b3AsZS50aW1lb3V0KSksXCJmdW5jdGlvblwiPT10eXBlb2YgZS5jYWxsYmFjayYmZS5jYWxsYmFjay5hcHBseShudWxsLFtoXSkpfSwhMSl9fSgpfWZ1bmN0aW9uIGYoKXtmb3IodmFyIGE9MCxiPWoubGVuZ3RoO2I+YTthKyspalthXS5zdG9wKCl9ZnVuY3Rpb24gZyhiKXt2YXIgYyxkLGU9Yi5vZmZzZXRIZWlnaHQ7MD09PWUmJihlPXBhcnNlRmxvYXQod2luZG93LmdldENvbXB1dGVkU3R5bGUoYikuaGVpZ2h0KSksZT4zMiYmKGUqPS44KSxiLmhhc0F0dHJpYnV0ZShcImRhdGEtc3Bpbm5lci1zaXplXCIpJiYoZT1wYXJzZUludChiLmdldEF0dHJpYnV0ZShcImRhdGEtc3Bpbm5lci1zaXplXCIpLDEwKSksYi5oYXNBdHRyaWJ1dGUoXCJkYXRhLXNwaW5uZXItY29sb3JcIikmJihjPWIuZ2V0QXR0cmlidXRlKFwiZGF0YS1zcGlubmVyLWNvbG9yXCIpKSxiLmhhc0F0dHJpYnV0ZShcImRhdGEtc3Bpbm5lci1saW5lc1wiKSYmKGQ9cGFyc2VJbnQoYi5nZXRBdHRyaWJ1dGUoXCJkYXRhLXNwaW5uZXItbGluZXNcIiksMTApKTt2YXIgZj0uMiplLGc9LjYqZixoPTc+Zj8yOjM7cmV0dXJuIG5ldyBhKHtjb2xvcjpjfHxcIiNmZmZcIixsaW5lczpkfHwxMixyYWRpdXM6ZixsZW5ndGg6Zyx3aWR0aDpoLHpJbmRleDpcImF1dG9cIix0b3A6XCJhdXRvXCIsbGVmdDpcImF1dG9cIixjbGFzc05hbWU6XCJcIn0pfWZ1bmN0aW9uIGgoYSl7Zm9yKHZhciBiPVtdLGM9MDtjPGEubGVuZ3RoO2MrKyliLnB1c2goYVtjXSk7cmV0dXJuIGJ9ZnVuY3Rpb24gaShhLGIpe3ZhciBjPWRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7Yy5zZWxlY3ROb2RlQ29udGVudHMoYSksYy5zdXJyb3VuZENvbnRlbnRzKGIpLGEuYXBwZW5kQ2hpbGQoYil9dmFyIGo9W107cmV0dXJue2JpbmQ6ZSxjcmVhdGU6YixzdG9wQWxsOmZ9fSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xhZGRhL2Rpc3QvbGFkZGEubWluLmpzXG4vLyBtb2R1bGUgaWQgPSA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright (c) 2011-2014 Felix Gnass\n * Licensed under the MIT license\n */\n(function(root, factory) {\n\n  // CommonJS\n  if (true) {\n    module.exports = factory();\n  }\n  // AMD module\n  else if (typeof define == 'function' && define.amd) {\n    define(factory);\n  }\n  // Browser global\n  else {\n    root.Spinner = factory();\n  }\n\n}\n(this, function() {\n  \"use strict\";\n\n  var prefixes = ['webkit', 'Moz', 'ms', 'O'] /* Vendor prefixes */\n    , animations = {} /* Animation rules keyed by their name */\n    , useCssAnimations /* Whether to use CSS animations or setTimeout */\n\n  /**\n   * Utility function to create elements. If no tag name is given,\n   * a DIV is created. Optionally properties can be passed.\n   */\n  function createEl(tag, prop) {\n    var el = document.createElement(tag || 'div')\n      , n\n\n    for(n in prop) el[n] = prop[n]\n    return el\n  }\n\n  /**\n   * Appends children and returns the parent.\n   */\n  function ins(parent /* child1, child2, ...*/) {\n    for (var i=1, n=arguments.length; i<n; i++)\n      parent.appendChild(arguments[i])\n\n    return parent\n  }\n\n  /**\n   * Insert a new stylesheet to hold the @keyframe or VML rules.\n   */\n  var sheet = (function() {\n    var el = createEl('style', {type : 'text/css'})\n    ins(document.getElementsByTagName('head')[0], el)\n    return el.sheet || el.styleSheet\n  }())\n\n  /**\n   * Creates an opacity keyframe animation rule and returns its name.\n   * Since most mobile Webkits have timing issues with animation-delay,\n   * we create separate rules for each line/segment.\n   */\n  function addAnimation(alpha, trail, i, lines) {\n    var name = ['opacity', trail, ~~(alpha*100), i, lines].join('-')\n      , start = 0.01 + i/lines * 100\n      , z = Math.max(1 - (1-alpha) / trail * (100-start), alpha)\n      , prefix = useCssAnimations.substring(0, useCssAnimations.indexOf('Animation')).toLowerCase()\n      , pre = prefix && '-' + prefix + '-' || ''\n\n    if (!animations[name]) {\n      sheet.insertRule(\n        '@' + pre + 'keyframes ' + name + '{' +\n        '0%{opacity:' + z + '}' +\n        start + '%{opacity:' + alpha + '}' +\n        (start+0.01) + '%{opacity:1}' +\n        (start+trail) % 100 + '%{opacity:' + alpha + '}' +\n        '100%{opacity:' + z + '}' +\n        '}', sheet.cssRules.length)\n\n      animations[name] = 1\n    }\n\n    return name\n  }\n\n  /**\n   * Tries various vendor prefixes and returns the first supported property.\n   */\n  function vendor(el, prop) {\n    var s = el.style\n      , pp\n      , i\n\n    prop = prop.charAt(0).toUpperCase() + prop.slice(1)\n    for(i=0; i<prefixes.length; i++) {\n      pp = prefixes[i]+prop\n      if(s[pp] !== undefined) return pp\n    }\n    if(s[prop] !== undefined) return prop\n  }\n\n  /**\n   * Sets multiple style properties at once.\n   */\n  function css(el, prop) {\n    for (var n in prop)\n      el.style[vendor(el, n)||n] = prop[n]\n\n    return el\n  }\n\n  /**\n   * Fills in default values.\n   */\n  function merge(obj) {\n    for (var i=1; i < arguments.length; i++) {\n      var def = arguments[i]\n      for (var n in def)\n        if (obj[n] === undefined) obj[n] = def[n]\n    }\n    return obj\n  }\n\n  /**\n   * Returns the absolute page-offset of the given element.\n   */\n  function pos(el) {\n    var o = { x:el.offsetLeft, y:el.offsetTop }\n    while((el = el.offsetParent))\n      o.x+=el.offsetLeft, o.y+=el.offsetTop\n\n    return o\n  }\n\n  /**\n   * Returns the line color from the given string or array.\n   */\n  function getColor(color, idx) {\n    return typeof color == 'string' ? color : color[idx % color.length]\n  }\n\n  // Built-in defaults\n\n  var defaults = {\n    lines: 12,            // The number of lines to draw\n    length: 7,            // The length of each line\n    width: 5,             // The line thickness\n    radius: 10,           // The radius of the inner circle\n    rotate: 0,            // Rotation offset\n    corners: 1,           // Roundness (0..1)\n    color: '#000',        // #rgb or #rrggbb\n    direction: 1,         // 1: clockwise, -1: counterclockwise\n    speed: 1,             // Rounds per second\n    trail: 100,           // Afterglow percentage\n    opacity: 1/4,         // Opacity of the lines\n    fps: 20,              // Frames per second when using setTimeout()\n    zIndex: 2e9,          // Use a high z-index by default\n    className: 'spinner', // CSS class to assign to the element\n    top: '50%',           // center vertically\n    left: '50%',          // center horizontally\n    position: 'absolute'  // element position\n  }\n\n  /** The constructor */\n  function Spinner(o) {\n    this.opts = merge(o || {}, Spinner.defaults, defaults)\n  }\n\n  // Global defaults that override the built-ins:\n  Spinner.defaults = {}\n\n  merge(Spinner.prototype, {\n\n    /**\n     * Adds the spinner to the given target element. If this instance is already\n     * spinning, it is automatically removed from its previous target b calling\n     * stop() internally.\n     */\n    spin: function(target) {\n      this.stop()\n\n      var self = this\n        , o = self.opts\n        , el = self.el = css(createEl(0, {className: o.className}), {position: o.position, width: 0, zIndex: o.zIndex})\n        , mid = o.radius+o.length+o.width\n\n      css(el, {\n        left: o.left,\n        top: o.top\n      })\n        \n      if (target) {\n        target.insertBefore(el, target.firstChild||null)\n      }\n\n      el.setAttribute('role', 'progressbar')\n      self.lines(el, self.opts)\n\n      if (!useCssAnimations) {\n        // No CSS animation support, use setTimeout() instead\n        var i = 0\n          , start = (o.lines - 1) * (1 - o.direction) / 2\n          , alpha\n          , fps = o.fps\n          , f = fps/o.speed\n          , ostep = (1-o.opacity) / (f*o.trail / 100)\n          , astep = f/o.lines\n\n        ;(function anim() {\n          i++;\n          for (var j = 0; j < o.lines; j++) {\n            alpha = Math.max(1 - (i + (o.lines - j) * astep) % f * ostep, o.opacity)\n\n            self.opacity(el, j * o.direction + start, alpha, o)\n          }\n          self.timeout = self.el && setTimeout(anim, ~~(1000/fps))\n        })()\n      }\n      return self\n    },\n\n    /**\n     * Stops and removes the Spinner.\n     */\n    stop: function() {\n      var el = this.el\n      if (el) {\n        clearTimeout(this.timeout)\n        if (el.parentNode) el.parentNode.removeChild(el)\n        this.el = undefined\n      }\n      return this\n    },\n\n    /**\n     * Internal method that draws the individual lines. Will be overwritten\n     * in VML fallback mode below.\n     */\n    lines: function(el, o) {\n      var i = 0\n        , start = (o.lines - 1) * (1 - o.direction) / 2\n        , seg\n\n      function fill(color, shadow) {\n        return css(createEl(), {\n          position: 'absolute',\n          width: (o.length+o.width) + 'px',\n          height: o.width + 'px',\n          background: color,\n          boxShadow: shadow,\n          transformOrigin: 'left',\n          transform: 'rotate(' + ~~(360/o.lines*i+o.rotate) + 'deg) translate(' + o.radius+'px' +',0)',\n          borderRadius: (o.corners * o.width>>1) + 'px'\n        })\n      }\n\n      for (; i < o.lines; i++) {\n        seg = css(createEl(), {\n          position: 'absolute',\n          top: 1+~(o.width/2) + 'px',\n          transform: o.hwaccel ? 'translate3d(0,0,0)' : '',\n          opacity: o.opacity,\n          animation: useCssAnimations && addAnimation(o.opacity, o.trail, start + i * o.direction, o.lines) + ' ' + 1/o.speed + 's linear infinite'\n        })\n\n        if (o.shadow) ins(seg, css(fill('#000', '0 0 4px ' + '#000'), {top: 2+'px'}))\n        ins(el, ins(seg, fill(getColor(o.color, i), '0 0 1px rgba(0,0,0,.1)')))\n      }\n      return el\n    },\n\n    /**\n     * Internal method that adjusts the opacity of a single line.\n     * Will be overwritten in VML fallback mode below.\n     */\n    opacity: function(el, i, val) {\n      if (i < el.childNodes.length) el.childNodes[i].style.opacity = val\n    }\n\n  })\n\n\n  function initVML() {\n\n    /* Utility function to create a VML tag */\n    function vml(tag, attr) {\n      return createEl('<' + tag + ' xmlns=\"urn:schemas-microsoft.com:vml\" class=\"spin-vml\">', attr)\n    }\n\n    // No CSS transforms but VML support, add a CSS rule for VML elements:\n    sheet.addRule('.spin-vml', 'behavior:url(#default#VML)')\n\n    Spinner.prototype.lines = function(el, o) {\n      var r = o.length+o.width\n        , s = 2*r\n\n      function grp() {\n        return css(\n          vml('group', {\n            coordsize: s + ' ' + s,\n            coordorigin: -r + ' ' + -r\n          }),\n          { width: s, height: s }\n        )\n      }\n\n      var margin = -(o.width+o.length)*2 + 'px'\n        , g = css(grp(), {position: 'absolute', top: margin, left: margin})\n        , i\n\n      function seg(i, dx, filter) {\n        ins(g,\n          ins(css(grp(), {rotation: 360 / o.lines * i + 'deg', left: ~~dx}),\n            ins(css(vml('roundrect', {arcsize: o.corners}), {\n                width: r,\n                height: o.width,\n                left: o.radius,\n                top: -o.width>>1,\n                filter: filter\n              }),\n              vml('fill', {color: getColor(o.color, i), opacity: o.opacity}),\n              vml('stroke', {opacity: 0}) // transparent stroke to fix color bleeding upon opacity change\n            )\n          )\n        )\n      }\n\n      if (o.shadow)\n        for (i = 1; i <= o.lines; i++)\n          seg(i, -2, 'progid:DXImageTransform.Microsoft.Blur(pixelradius=2,makeshadow=1,shadowopacity=.3)')\n\n      for (i = 1; i <= o.lines; i++) seg(i)\n      return ins(el, g)\n    }\n\n    Spinner.prototype.opacity = function(el, i, val, o) {\n      var c = el.firstChild\n      o = o.shadow && o.lines || 0\n      if (c && i+o < c.childNodes.length) {\n        c = c.childNodes[i+o]; c = c && c.firstChild; c = c && c.firstChild\n        if (c) c.opacity = val\n      }\n    }\n  }\n\n  var probe = css(createEl('group'), {behavior: 'url(#default#VML)'})\n\n  if (!vendor(probe, 'transform') && probe.adj) initVML()\n  else useCssAnimations = vendor(probe, 'animation')\n\n  return Spinner\n\n}));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2xhZGRhL2pzL3NwaW4uanM/MDZkNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLEtBQUs7QUFDMUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrQkFBa0I7QUFDbEQ7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLFlBQVksa0JBQWtCO0FBQzlCLG1CQUFtQixzQkFBc0I7QUFDekMsMEJBQTBCLFVBQVU7QUFDcEMsaUNBQWlDLHNCQUFzQjtBQUN2RCxjQUFjLGtCQUFrQjtBQUNoQyxVQUFVOztBQUVWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDLHVCQUF1QixJQUFJLGlEQUFpRDtBQUN0SDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQSx5QkFBeUIsYUFBYTtBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVCx1RUFBdUUsWUFBWTtBQUNuRjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7OztBQUdIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsZ0RBQWdEO0FBQzFFOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEIsZ0RBQWdEO0FBQzFFLHNDQUFzQyxtQkFBbUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZiwyQkFBMkIsZ0RBQWdEO0FBQzNFLDZCQUE2QixXQUFXO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGNBQWM7QUFDakM7O0FBRUEsaUJBQWlCLGNBQWM7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix1QkFBdUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDLDhCQUE4Qjs7QUFFcEU7QUFDQTs7QUFFQTs7QUFFQSxDQUFDIiwiZmlsZSI6IjkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDE0IEZlbGl4IEduYXNzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblxuICAvLyBDb21tb25KU1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgfVxuICAvLyBBTUQgbW9kdWxlXG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKGZhY3RvcnkpO1xuICB9XG4gIC8vIEJyb3dzZXIgZ2xvYmFsXG4gIGVsc2Uge1xuICAgIHJvb3QuU3Bpbm5lciA9IGZhY3RvcnkoKTtcbiAgfVxuXG59XG4odGhpcywgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBwcmVmaXhlcyA9IFsnd2Via2l0JywgJ01veicsICdtcycsICdPJ10gLyogVmVuZG9yIHByZWZpeGVzICovXG4gICAgLCBhbmltYXRpb25zID0ge30gLyogQW5pbWF0aW9uIHJ1bGVzIGtleWVkIGJ5IHRoZWlyIG5hbWUgKi9cbiAgICAsIHVzZUNzc0FuaW1hdGlvbnMgLyogV2hldGhlciB0byB1c2UgQ1NTIGFuaW1hdGlvbnMgb3Igc2V0VGltZW91dCAqL1xuXG4gIC8qKlxuICAgKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIGNyZWF0ZSBlbGVtZW50cy4gSWYgbm8gdGFnIG5hbWUgaXMgZ2l2ZW4sXG4gICAqIGEgRElWIGlzIGNyZWF0ZWQuIE9wdGlvbmFsbHkgcHJvcGVydGllcyBjYW4gYmUgcGFzc2VkLlxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlRWwodGFnLCBwcm9wKSB7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcgfHwgJ2RpdicpXG4gICAgICAsIG5cblxuICAgIGZvcihuIGluIHByb3ApIGVsW25dID0gcHJvcFtuXVxuICAgIHJldHVybiBlbFxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGVuZHMgY2hpbGRyZW4gYW5kIHJldHVybnMgdGhlIHBhcmVudC5cbiAgICovXG4gIGZ1bmN0aW9uIGlucyhwYXJlbnQgLyogY2hpbGQxLCBjaGlsZDIsIC4uLiovKSB7XG4gICAgZm9yICh2YXIgaT0xLCBuPWFyZ3VtZW50cy5sZW5ndGg7IGk8bjsgaSsrKVxuICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGFyZ3VtZW50c1tpXSlcblxuICAgIHJldHVybiBwYXJlbnRcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnQgYSBuZXcgc3R5bGVzaGVldCB0byBob2xkIHRoZSBAa2V5ZnJhbWUgb3IgVk1MIHJ1bGVzLlxuICAgKi9cbiAgdmFyIHNoZWV0ID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBlbCA9IGNyZWF0ZUVsKCdzdHlsZScsIHt0eXBlIDogJ3RleHQvY3NzJ30pXG4gICAgaW5zKGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0sIGVsKVxuICAgIHJldHVybiBlbC5zaGVldCB8fCBlbC5zdHlsZVNoZWV0XG4gIH0oKSlcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBvcGFjaXR5IGtleWZyYW1lIGFuaW1hdGlvbiBydWxlIGFuZCByZXR1cm5zIGl0cyBuYW1lLlxuICAgKiBTaW5jZSBtb3N0IG1vYmlsZSBXZWJraXRzIGhhdmUgdGltaW5nIGlzc3VlcyB3aXRoIGFuaW1hdGlvbi1kZWxheSxcbiAgICogd2UgY3JlYXRlIHNlcGFyYXRlIHJ1bGVzIGZvciBlYWNoIGxpbmUvc2VnbWVudC5cbiAgICovXG4gIGZ1bmN0aW9uIGFkZEFuaW1hdGlvbihhbHBoYSwgdHJhaWwsIGksIGxpbmVzKSB7XG4gICAgdmFyIG5hbWUgPSBbJ29wYWNpdHknLCB0cmFpbCwgfn4oYWxwaGEqMTAwKSwgaSwgbGluZXNdLmpvaW4oJy0nKVxuICAgICAgLCBzdGFydCA9IDAuMDEgKyBpL2xpbmVzICogMTAwXG4gICAgICAsIHogPSBNYXRoLm1heCgxIC0gKDEtYWxwaGEpIC8gdHJhaWwgKiAoMTAwLXN0YXJ0KSwgYWxwaGEpXG4gICAgICAsIHByZWZpeCA9IHVzZUNzc0FuaW1hdGlvbnMuc3Vic3RyaW5nKDAsIHVzZUNzc0FuaW1hdGlvbnMuaW5kZXhPZignQW5pbWF0aW9uJykpLnRvTG93ZXJDYXNlKClcbiAgICAgICwgcHJlID0gcHJlZml4ICYmICctJyArIHByZWZpeCArICctJyB8fCAnJ1xuXG4gICAgaWYgKCFhbmltYXRpb25zW25hbWVdKSB7XG4gICAgICBzaGVldC5pbnNlcnRSdWxlKFxuICAgICAgICAnQCcgKyBwcmUgKyAna2V5ZnJhbWVzICcgKyBuYW1lICsgJ3snICtcbiAgICAgICAgJzAle29wYWNpdHk6JyArIHogKyAnfScgK1xuICAgICAgICBzdGFydCArICcle29wYWNpdHk6JyArIGFscGhhICsgJ30nICtcbiAgICAgICAgKHN0YXJ0KzAuMDEpICsgJyV7b3BhY2l0eToxfScgK1xuICAgICAgICAoc3RhcnQrdHJhaWwpICUgMTAwICsgJyV7b3BhY2l0eTonICsgYWxwaGEgKyAnfScgK1xuICAgICAgICAnMTAwJXtvcGFjaXR5OicgKyB6ICsgJ30nICtcbiAgICAgICAgJ30nLCBzaGVldC5jc3NSdWxlcy5sZW5ndGgpXG5cbiAgICAgIGFuaW1hdGlvbnNbbmFtZV0gPSAxXG4gICAgfVxuXG4gICAgcmV0dXJuIG5hbWVcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmllcyB2YXJpb3VzIHZlbmRvciBwcmVmaXhlcyBhbmQgcmV0dXJucyB0aGUgZmlyc3Qgc3VwcG9ydGVkIHByb3BlcnR5LlxuICAgKi9cbiAgZnVuY3Rpb24gdmVuZG9yKGVsLCBwcm9wKSB7XG4gICAgdmFyIHMgPSBlbC5zdHlsZVxuICAgICAgLCBwcFxuICAgICAgLCBpXG5cbiAgICBwcm9wID0gcHJvcC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3Auc2xpY2UoMSlcbiAgICBmb3IoaT0wOyBpPHByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwcCA9IHByZWZpeGVzW2ldK3Byb3BcbiAgICAgIGlmKHNbcHBdICE9PSB1bmRlZmluZWQpIHJldHVybiBwcFxuICAgIH1cbiAgICBpZihzW3Byb3BdICE9PSB1bmRlZmluZWQpIHJldHVybiBwcm9wXG4gIH1cblxuICAvKipcbiAgICogU2V0cyBtdWx0aXBsZSBzdHlsZSBwcm9wZXJ0aWVzIGF0IG9uY2UuXG4gICAqL1xuICBmdW5jdGlvbiBjc3MoZWwsIHByb3ApIHtcbiAgICBmb3IgKHZhciBuIGluIHByb3ApXG4gICAgICBlbC5zdHlsZVt2ZW5kb3IoZWwsIG4pfHxuXSA9IHByb3Bbbl1cblxuICAgIHJldHVybiBlbFxuICB9XG5cbiAgLyoqXG4gICAqIEZpbGxzIGluIGRlZmF1bHQgdmFsdWVzLlxuICAgKi9cbiAgZnVuY3Rpb24gbWVyZ2Uob2JqKSB7XG4gICAgZm9yICh2YXIgaT0xOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVmID0gYXJndW1lbnRzW2ldXG4gICAgICBmb3IgKHZhciBuIGluIGRlZilcbiAgICAgICAgaWYgKG9ialtuXSA9PT0gdW5kZWZpbmVkKSBvYmpbbl0gPSBkZWZbbl1cbiAgICB9XG4gICAgcmV0dXJuIG9ialxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFic29sdXRlIHBhZ2Utb2Zmc2V0IG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgKi9cbiAgZnVuY3Rpb24gcG9zKGVsKSB7XG4gICAgdmFyIG8gPSB7IHg6ZWwub2Zmc2V0TGVmdCwgeTplbC5vZmZzZXRUb3AgfVxuICAgIHdoaWxlKChlbCA9IGVsLm9mZnNldFBhcmVudCkpXG4gICAgICBvLngrPWVsLm9mZnNldExlZnQsIG8ueSs9ZWwub2Zmc2V0VG9wXG5cbiAgICByZXR1cm4gb1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxpbmUgY29sb3IgZnJvbSB0aGUgZ2l2ZW4gc3RyaW5nIG9yIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0Q29sb3IoY29sb3IsIGlkeCkge1xuICAgIHJldHVybiB0eXBlb2YgY29sb3IgPT0gJ3N0cmluZycgPyBjb2xvciA6IGNvbG9yW2lkeCAlIGNvbG9yLmxlbmd0aF1cbiAgfVxuXG4gIC8vIEJ1aWx0LWluIGRlZmF1bHRzXG5cbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgIGxpbmVzOiAxMiwgICAgICAgICAgICAvLyBUaGUgbnVtYmVyIG9mIGxpbmVzIHRvIGRyYXdcbiAgICBsZW5ndGg6IDcsICAgICAgICAgICAgLy8gVGhlIGxlbmd0aCBvZiBlYWNoIGxpbmVcbiAgICB3aWR0aDogNSwgICAgICAgICAgICAgLy8gVGhlIGxpbmUgdGhpY2tuZXNzXG4gICAgcmFkaXVzOiAxMCwgICAgICAgICAgIC8vIFRoZSByYWRpdXMgb2YgdGhlIGlubmVyIGNpcmNsZVxuICAgIHJvdGF0ZTogMCwgICAgICAgICAgICAvLyBSb3RhdGlvbiBvZmZzZXRcbiAgICBjb3JuZXJzOiAxLCAgICAgICAgICAgLy8gUm91bmRuZXNzICgwLi4xKVxuICAgIGNvbG9yOiAnIzAwMCcsICAgICAgICAvLyAjcmdiIG9yICNycmdnYmJcbiAgICBkaXJlY3Rpb246IDEsICAgICAgICAgLy8gMTogY2xvY2t3aXNlLCAtMTogY291bnRlcmNsb2Nrd2lzZVxuICAgIHNwZWVkOiAxLCAgICAgICAgICAgICAvLyBSb3VuZHMgcGVyIHNlY29uZFxuICAgIHRyYWlsOiAxMDAsICAgICAgICAgICAvLyBBZnRlcmdsb3cgcGVyY2VudGFnZVxuICAgIG9wYWNpdHk6IDEvNCwgICAgICAgICAvLyBPcGFjaXR5IG9mIHRoZSBsaW5lc1xuICAgIGZwczogMjAsICAgICAgICAgICAgICAvLyBGcmFtZXMgcGVyIHNlY29uZCB3aGVuIHVzaW5nIHNldFRpbWVvdXQoKVxuICAgIHpJbmRleDogMmU5LCAgICAgICAgICAvLyBVc2UgYSBoaWdoIHotaW5kZXggYnkgZGVmYXVsdFxuICAgIGNsYXNzTmFtZTogJ3NwaW5uZXInLCAvLyBDU1MgY2xhc3MgdG8gYXNzaWduIHRvIHRoZSBlbGVtZW50XG4gICAgdG9wOiAnNTAlJywgICAgICAgICAgIC8vIGNlbnRlciB2ZXJ0aWNhbGx5XG4gICAgbGVmdDogJzUwJScsICAgICAgICAgIC8vIGNlbnRlciBob3Jpem9udGFsbHlcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyAgLy8gZWxlbWVudCBwb3NpdGlvblxuICB9XG5cbiAgLyoqIFRoZSBjb25zdHJ1Y3RvciAqL1xuICBmdW5jdGlvbiBTcGlubmVyKG8pIHtcbiAgICB0aGlzLm9wdHMgPSBtZXJnZShvIHx8IHt9LCBTcGlubmVyLmRlZmF1bHRzLCBkZWZhdWx0cylcbiAgfVxuXG4gIC8vIEdsb2JhbCBkZWZhdWx0cyB0aGF0IG92ZXJyaWRlIHRoZSBidWlsdC1pbnM6XG4gIFNwaW5uZXIuZGVmYXVsdHMgPSB7fVxuXG4gIG1lcmdlKFNwaW5uZXIucHJvdG90eXBlLCB7XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBzcGlubmVyIHRvIHRoZSBnaXZlbiB0YXJnZXQgZWxlbWVudC4gSWYgdGhpcyBpbnN0YW5jZSBpcyBhbHJlYWR5XG4gICAgICogc3Bpbm5pbmcsIGl0IGlzIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZCBmcm9tIGl0cyBwcmV2aW91cyB0YXJnZXQgYiBjYWxsaW5nXG4gICAgICogc3RvcCgpIGludGVybmFsbHkuXG4gICAgICovXG4gICAgc3BpbjogZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICB0aGlzLnN0b3AoKVxuXG4gICAgICB2YXIgc2VsZiA9IHRoaXNcbiAgICAgICAgLCBvID0gc2VsZi5vcHRzXG4gICAgICAgICwgZWwgPSBzZWxmLmVsID0gY3NzKGNyZWF0ZUVsKDAsIHtjbGFzc05hbWU6IG8uY2xhc3NOYW1lfSksIHtwb3NpdGlvbjogby5wb3NpdGlvbiwgd2lkdGg6IDAsIHpJbmRleDogby56SW5kZXh9KVxuICAgICAgICAsIG1pZCA9IG8ucmFkaXVzK28ubGVuZ3RoK28ud2lkdGhcblxuICAgICAgY3NzKGVsLCB7XG4gICAgICAgIGxlZnQ6IG8ubGVmdCxcbiAgICAgICAgdG9wOiBvLnRvcFxuICAgICAgfSlcbiAgICAgICAgXG4gICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgIHRhcmdldC5pbnNlcnRCZWZvcmUoZWwsIHRhcmdldC5maXJzdENoaWxkfHxudWxsKVxuICAgICAgfVxuXG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAncHJvZ3Jlc3NiYXInKVxuICAgICAgc2VsZi5saW5lcyhlbCwgc2VsZi5vcHRzKVxuXG4gICAgICBpZiAoIXVzZUNzc0FuaW1hdGlvbnMpIHtcbiAgICAgICAgLy8gTm8gQ1NTIGFuaW1hdGlvbiBzdXBwb3J0LCB1c2Ugc2V0VGltZW91dCgpIGluc3RlYWRcbiAgICAgICAgdmFyIGkgPSAwXG4gICAgICAgICAgLCBzdGFydCA9IChvLmxpbmVzIC0gMSkgKiAoMSAtIG8uZGlyZWN0aW9uKSAvIDJcbiAgICAgICAgICAsIGFscGhhXG4gICAgICAgICAgLCBmcHMgPSBvLmZwc1xuICAgICAgICAgICwgZiA9IGZwcy9vLnNwZWVkXG4gICAgICAgICAgLCBvc3RlcCA9ICgxLW8ub3BhY2l0eSkgLyAoZipvLnRyYWlsIC8gMTAwKVxuICAgICAgICAgICwgYXN0ZXAgPSBmL28ubGluZXNcblxuICAgICAgICA7KGZ1bmN0aW9uIGFuaW0oKSB7XG4gICAgICAgICAgaSsrO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgby5saW5lczsgaisrKSB7XG4gICAgICAgICAgICBhbHBoYSA9IE1hdGgubWF4KDEgLSAoaSArIChvLmxpbmVzIC0gaikgKiBhc3RlcCkgJSBmICogb3N0ZXAsIG8ub3BhY2l0eSlcblxuICAgICAgICAgICAgc2VsZi5vcGFjaXR5KGVsLCBqICogby5kaXJlY3Rpb24gKyBzdGFydCwgYWxwaGEsIG8pXG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGYudGltZW91dCA9IHNlbGYuZWwgJiYgc2V0VGltZW91dChhbmltLCB+figxMDAwL2ZwcykpXG4gICAgICAgIH0pKClcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN0b3BzIGFuZCByZW1vdmVzIHRoZSBTcGlubmVyLlxuICAgICAqL1xuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGVsID0gdGhpcy5lbFxuICAgICAgaWYgKGVsKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpXG4gICAgICAgIGlmIChlbC5wYXJlbnROb2RlKSBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKVxuICAgICAgICB0aGlzLmVsID0gdW5kZWZpbmVkXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBtZXRob2QgdGhhdCBkcmF3cyB0aGUgaW5kaXZpZHVhbCBsaW5lcy4gV2lsbCBiZSBvdmVyd3JpdHRlblxuICAgICAqIGluIFZNTCBmYWxsYmFjayBtb2RlIGJlbG93LlxuICAgICAqL1xuICAgIGxpbmVzOiBmdW5jdGlvbihlbCwgbykge1xuICAgICAgdmFyIGkgPSAwXG4gICAgICAgICwgc3RhcnQgPSAoby5saW5lcyAtIDEpICogKDEgLSBvLmRpcmVjdGlvbikgLyAyXG4gICAgICAgICwgc2VnXG5cbiAgICAgIGZ1bmN0aW9uIGZpbGwoY29sb3IsIHNoYWRvdykge1xuICAgICAgICByZXR1cm4gY3NzKGNyZWF0ZUVsKCksIHtcbiAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICB3aWR0aDogKG8ubGVuZ3RoK28ud2lkdGgpICsgJ3B4JyxcbiAgICAgICAgICBoZWlnaHQ6IG8ud2lkdGggKyAncHgnLFxuICAgICAgICAgIGJhY2tncm91bmQ6IGNvbG9yLFxuICAgICAgICAgIGJveFNoYWRvdzogc2hhZG93LFxuICAgICAgICAgIHRyYW5zZm9ybU9yaWdpbjogJ2xlZnQnLFxuICAgICAgICAgIHRyYW5zZm9ybTogJ3JvdGF0ZSgnICsgfn4oMzYwL28ubGluZXMqaStvLnJvdGF0ZSkgKyAnZGVnKSB0cmFuc2xhdGUoJyArIG8ucmFkaXVzKydweCcgKycsMCknLFxuICAgICAgICAgIGJvcmRlclJhZGl1czogKG8uY29ybmVycyAqIG8ud2lkdGg+PjEpICsgJ3B4J1xuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBmb3IgKDsgaSA8IG8ubGluZXM7IGkrKykge1xuICAgICAgICBzZWcgPSBjc3MoY3JlYXRlRWwoKSwge1xuICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgIHRvcDogMSt+KG8ud2lkdGgvMikgKyAncHgnLFxuICAgICAgICAgIHRyYW5zZm9ybTogby5od2FjY2VsID8gJ3RyYW5zbGF0ZTNkKDAsMCwwKScgOiAnJyxcbiAgICAgICAgICBvcGFjaXR5OiBvLm9wYWNpdHksXG4gICAgICAgICAgYW5pbWF0aW9uOiB1c2VDc3NBbmltYXRpb25zICYmIGFkZEFuaW1hdGlvbihvLm9wYWNpdHksIG8udHJhaWwsIHN0YXJ0ICsgaSAqIG8uZGlyZWN0aW9uLCBvLmxpbmVzKSArICcgJyArIDEvby5zcGVlZCArICdzIGxpbmVhciBpbmZpbml0ZSdcbiAgICAgICAgfSlcblxuICAgICAgICBpZiAoby5zaGFkb3cpIGlucyhzZWcsIGNzcyhmaWxsKCcjMDAwJywgJzAgMCA0cHggJyArICcjMDAwJyksIHt0b3A6IDIrJ3B4J30pKVxuICAgICAgICBpbnMoZWwsIGlucyhzZWcsIGZpbGwoZ2V0Q29sb3Ioby5jb2xvciwgaSksICcwIDAgMXB4IHJnYmEoMCwwLDAsLjEpJykpKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGVsXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIG1ldGhvZCB0aGF0IGFkanVzdHMgdGhlIG9wYWNpdHkgb2YgYSBzaW5nbGUgbGluZS5cbiAgICAgKiBXaWxsIGJlIG92ZXJ3cml0dGVuIGluIFZNTCBmYWxsYmFjayBtb2RlIGJlbG93LlxuICAgICAqL1xuICAgIG9wYWNpdHk6IGZ1bmN0aW9uKGVsLCBpLCB2YWwpIHtcbiAgICAgIGlmIChpIDwgZWwuY2hpbGROb2Rlcy5sZW5ndGgpIGVsLmNoaWxkTm9kZXNbaV0uc3R5bGUub3BhY2l0eSA9IHZhbFxuICAgIH1cblxuICB9KVxuXG5cbiAgZnVuY3Rpb24gaW5pdFZNTCgpIHtcblxuICAgIC8qIFV0aWxpdHkgZnVuY3Rpb24gdG8gY3JlYXRlIGEgVk1MIHRhZyAqL1xuICAgIGZ1bmN0aW9uIHZtbCh0YWcsIGF0dHIpIHtcbiAgICAgIHJldHVybiBjcmVhdGVFbCgnPCcgKyB0YWcgKyAnIHhtbG5zPVwidXJuOnNjaGVtYXMtbWljcm9zb2Z0LmNvbTp2bWxcIiBjbGFzcz1cInNwaW4tdm1sXCI+JywgYXR0cilcbiAgICB9XG5cbiAgICAvLyBObyBDU1MgdHJhbnNmb3JtcyBidXQgVk1MIHN1cHBvcnQsIGFkZCBhIENTUyBydWxlIGZvciBWTUwgZWxlbWVudHM6XG4gICAgc2hlZXQuYWRkUnVsZSgnLnNwaW4tdm1sJywgJ2JlaGF2aW9yOnVybCgjZGVmYXVsdCNWTUwpJylcblxuICAgIFNwaW5uZXIucHJvdG90eXBlLmxpbmVzID0gZnVuY3Rpb24oZWwsIG8pIHtcbiAgICAgIHZhciByID0gby5sZW5ndGgrby53aWR0aFxuICAgICAgICAsIHMgPSAyKnJcblxuICAgICAgZnVuY3Rpb24gZ3JwKCkge1xuICAgICAgICByZXR1cm4gY3NzKFxuICAgICAgICAgIHZtbCgnZ3JvdXAnLCB7XG4gICAgICAgICAgICBjb29yZHNpemU6IHMgKyAnICcgKyBzLFxuICAgICAgICAgICAgY29vcmRvcmlnaW46IC1yICsgJyAnICsgLXJcbiAgICAgICAgICB9KSxcbiAgICAgICAgICB7IHdpZHRoOiBzLCBoZWlnaHQ6IHMgfVxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIHZhciBtYXJnaW4gPSAtKG8ud2lkdGgrby5sZW5ndGgpKjIgKyAncHgnXG4gICAgICAgICwgZyA9IGNzcyhncnAoKSwge3Bvc2l0aW9uOiAnYWJzb2x1dGUnLCB0b3A6IG1hcmdpbiwgbGVmdDogbWFyZ2lufSlcbiAgICAgICAgLCBpXG5cbiAgICAgIGZ1bmN0aW9uIHNlZyhpLCBkeCwgZmlsdGVyKSB7XG4gICAgICAgIGlucyhnLFxuICAgICAgICAgIGlucyhjc3MoZ3JwKCksIHtyb3RhdGlvbjogMzYwIC8gby5saW5lcyAqIGkgKyAnZGVnJywgbGVmdDogfn5keH0pLFxuICAgICAgICAgICAgaW5zKGNzcyh2bWwoJ3JvdW5kcmVjdCcsIHthcmNzaXplOiBvLmNvcm5lcnN9KSwge1xuICAgICAgICAgICAgICAgIHdpZHRoOiByLFxuICAgICAgICAgICAgICAgIGhlaWdodDogby53aWR0aCxcbiAgICAgICAgICAgICAgICBsZWZ0OiBvLnJhZGl1cyxcbiAgICAgICAgICAgICAgICB0b3A6IC1vLndpZHRoPj4xLFxuICAgICAgICAgICAgICAgIGZpbHRlcjogZmlsdGVyXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICB2bWwoJ2ZpbGwnLCB7Y29sb3I6IGdldENvbG9yKG8uY29sb3IsIGkpLCBvcGFjaXR5OiBvLm9wYWNpdHl9KSxcbiAgICAgICAgICAgICAgdm1sKCdzdHJva2UnLCB7b3BhY2l0eTogMH0pIC8vIHRyYW5zcGFyZW50IHN0cm9rZSB0byBmaXggY29sb3IgYmxlZWRpbmcgdXBvbiBvcGFjaXR5IGNoYW5nZVxuICAgICAgICAgICAgKVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICBpZiAoby5zaGFkb3cpXG4gICAgICAgIGZvciAoaSA9IDE7IGkgPD0gby5saW5lczsgaSsrKVxuICAgICAgICAgIHNlZyhpLCAtMiwgJ3Byb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5CbHVyKHBpeGVscmFkaXVzPTIsbWFrZXNoYWRvdz0xLHNoYWRvd29wYWNpdHk9LjMpJylcblxuICAgICAgZm9yIChpID0gMTsgaSA8PSBvLmxpbmVzOyBpKyspIHNlZyhpKVxuICAgICAgcmV0dXJuIGlucyhlbCwgZylcbiAgICB9XG5cbiAgICBTcGlubmVyLnByb3RvdHlwZS5vcGFjaXR5ID0gZnVuY3Rpb24oZWwsIGksIHZhbCwgbykge1xuICAgICAgdmFyIGMgPSBlbC5maXJzdENoaWxkXG4gICAgICBvID0gby5zaGFkb3cgJiYgby5saW5lcyB8fCAwXG4gICAgICBpZiAoYyAmJiBpK28gPCBjLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgIGMgPSBjLmNoaWxkTm9kZXNbaStvXTsgYyA9IGMgJiYgYy5maXJzdENoaWxkOyBjID0gYyAmJiBjLmZpcnN0Q2hpbGRcbiAgICAgICAgaWYgKGMpIGMub3BhY2l0eSA9IHZhbFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBwcm9iZSA9IGNzcyhjcmVhdGVFbCgnZ3JvdXAnKSwge2JlaGF2aW9yOiAndXJsKCNkZWZhdWx0I1ZNTCknfSlcblxuICBpZiAoIXZlbmRvcihwcm9iZSwgJ3RyYW5zZm9ybScpICYmIHByb2JlLmFkaikgaW5pdFZNTCgpXG4gIGVsc2UgdXNlQ3NzQW5pbWF0aW9ucyA9IHZlbmRvcihwcm9iZSwgJ2FuaW1hdGlvbicpXG5cbiAgcmV0dXJuIFNwaW5uZXJcblxufSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xhZGRhL2pzL3NwaW4uanNcbi8vIG1vZHVsZSBpZCA9IDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! angular-ladda 0.4.3 */\n/**!\n * AngularJS Ladda directive\n * @author Chungsub Kim <subicura@subicura.com>\n */\n\n/* global Ladda */\n/* exported Ladda */\n(function (root, factory)\n{\n  'use strict';\n  if (true) {\n    // AMD. Register as an anonymous module.\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1), __webpack_require__(8)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else if (typeof module !== 'undefined' && typeof module.exports === 'object') {\n    // CommonJS support (for us webpack/browserify/ComponentJS folks)\n    module.exports = factory(window.angular || require('angular'), require('ladda'));\n  } else {\n    // in the case of no module loading system\n    return factory(root.angular, root.Ladda);\n  }\n}(this, function (angular, Ladda){\n  'use strict';\n\n  var moduleName = 'angular-ladda';\n  \n  angular.module(moduleName, [])\n    .provider('ladda', function () {\n      var opts = {\n        'style': 'zoom-in'\n      };\n      return {\n        setOption: function (newOpts) {\n          angular.extend(opts, newOpts);\n        },\n        $get: function () {\n          return opts;\n        }\n      };\n    })\n    .directive('ladda', ['ladda', '$timeout', function (laddaOption, $timeout) {\n      return {\n        restrict: 'A',\n        priority: -1,\n        link: function (scope, element, attrs) {\n          $timeout(function() {\n            element.addClass('ladda-button');\n            if(angular.isUndefined(element.attr('data-style'))) {\n              element.attr('data-style', laddaOption.style || 'zoom-in');\n            }\n            if(angular.isUndefined(element.attr('data-spinner-size')) && laddaOption.spinnerSize) {\n              element.attr('data-spinner-size', laddaOption.spinnerSize);\n            }\n            if(angular.isUndefined(element.attr('data-spinner-color')) && laddaOption.spinnerColor) {\n              element.attr('data-spinner-color', laddaOption.spinnerColor);\n            }\n\n            // ladda breaks childNode's event property.\n            // because ladda use innerHTML instead of append node\n            if(!element[0].querySelector('.ladda-label')) {\n              var labelWrapper = document.createElement('span');\n              labelWrapper.className = 'ladda-label';\n              angular.element(labelWrapper).append(element.contents());\n              element.append(labelWrapper);\n            }\n\n            // create ladda button\n            var ladda = Ladda.create( element[0] );\n\n            // add watch!\n            scope.$watch(attrs.ladda, function(loading) {\n              if(!loading && !angular.isNumber(loading)) {\n                ladda.stop();\n                // When the button also have the ng-disabled directive it needs to be\n                // re-evaluated since the disabled attribute is removed by the 'stop' method.\n                if (attrs.ngDisabled) {\n                  element.attr('disabled', scope.$eval(attrs.ngDisabled));\n                }\n                return;\n              }\n              if(!ladda.isLoading()) {\n                ladda.start();\n              }\n              if(angular.isNumber(loading)) {\n                ladda.setProgress(loading);\n              }\n            });\n            \n            // use remove on scope destroy to stop memory leaks \n            scope.$on('$destroy', function () {\n              if (ladda) { // prevent null reference\n                ladda.remove();\n              }\n            });\n          });\n        }\n      };\n    }]);\n    \n  return moduleName;\n}));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2FuZ3VsYXItbGFkZGEvZGlzdC9hbmd1bGFyLWxhZGRhLmpzPzc4MGEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxDQUFDIiwiZmlsZSI6IjEwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohIGFuZ3VsYXItbGFkZGEgMC40LjMgKi9cbi8qKiFcbiAqIEFuZ3VsYXJKUyBMYWRkYSBkaXJlY3RpdmVcbiAqIEBhdXRob3IgQ2h1bmdzdWIgS2ltIDxzdWJpY3VyYUBzdWJpY3VyYS5jb20+XG4gKi9cblxuLyogZ2xvYmFsIExhZGRhICovXG4vKiBleHBvcnRlZCBMYWRkYSAqL1xuKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KVxue1xuICAndXNlIHN0cmljdCc7XG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG4gICAgZGVmaW5lKFsnYW5ndWxhcicsICdsYWRkYSddLCBmYWN0b3J5KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgLy8gQ29tbW9uSlMgc3VwcG9ydCAoZm9yIHVzIHdlYnBhY2svYnJvd3NlcmlmeS9Db21wb25lbnRKUyBmb2xrcylcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3Rvcnkod2luZG93LmFuZ3VsYXIgfHwgcmVxdWlyZSgnYW5ndWxhcicpLCByZXF1aXJlKCdsYWRkYScpKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBpbiB0aGUgY2FzZSBvZiBubyBtb2R1bGUgbG9hZGluZyBzeXN0ZW1cbiAgICByZXR1cm4gZmFjdG9yeShyb290LmFuZ3VsYXIsIHJvb3QuTGFkZGEpO1xuICB9XG59KHRoaXMsIGZ1bmN0aW9uIChhbmd1bGFyLCBMYWRkYSl7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgbW9kdWxlTmFtZSA9ICdhbmd1bGFyLWxhZGRhJztcbiAgXG4gIGFuZ3VsYXIubW9kdWxlKG1vZHVsZU5hbWUsIFtdKVxuICAgIC5wcm92aWRlcignbGFkZGEnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgb3B0cyA9IHtcbiAgICAgICAgJ3N0eWxlJzogJ3pvb20taW4nXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2V0T3B0aW9uOiBmdW5jdGlvbiAobmV3T3B0cykge1xuICAgICAgICAgIGFuZ3VsYXIuZXh0ZW5kKG9wdHMsIG5ld09wdHMpO1xuICAgICAgICB9LFxuICAgICAgICAkZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIG9wdHM7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSlcbiAgICAuZGlyZWN0aXZlKCdsYWRkYScsIFsnbGFkZGEnLCAnJHRpbWVvdXQnLCBmdW5jdGlvbiAobGFkZGFPcHRpb24sICR0aW1lb3V0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXN0cmljdDogJ0EnLFxuICAgICAgICBwcmlvcml0eTogLTEsXG4gICAgICAgIGxpbms6IGZ1bmN0aW9uIChzY29wZSwgZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgICAgICAkdGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuYWRkQ2xhc3MoJ2xhZGRhLWJ1dHRvbicpO1xuICAgICAgICAgICAgaWYoYW5ndWxhci5pc1VuZGVmaW5lZChlbGVtZW50LmF0dHIoJ2RhdGEtc3R5bGUnKSkpIHtcbiAgICAgICAgICAgICAgZWxlbWVudC5hdHRyKCdkYXRhLXN0eWxlJywgbGFkZGFPcHRpb24uc3R5bGUgfHwgJ3pvb20taW4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGFuZ3VsYXIuaXNVbmRlZmluZWQoZWxlbWVudC5hdHRyKCdkYXRhLXNwaW5uZXItc2l6ZScpKSAmJiBsYWRkYU9wdGlvbi5zcGlubmVyU2l6ZSkge1xuICAgICAgICAgICAgICBlbGVtZW50LmF0dHIoJ2RhdGEtc3Bpbm5lci1zaXplJywgbGFkZGFPcHRpb24uc3Bpbm5lclNpemUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoYW5ndWxhci5pc1VuZGVmaW5lZChlbGVtZW50LmF0dHIoJ2RhdGEtc3Bpbm5lci1jb2xvcicpKSAmJiBsYWRkYU9wdGlvbi5zcGlubmVyQ29sb3IpIHtcbiAgICAgICAgICAgICAgZWxlbWVudC5hdHRyKCdkYXRhLXNwaW5uZXItY29sb3InLCBsYWRkYU9wdGlvbi5zcGlubmVyQ29sb3IpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBsYWRkYSBicmVha3MgY2hpbGROb2RlJ3MgZXZlbnQgcHJvcGVydHkuXG4gICAgICAgICAgICAvLyBiZWNhdXNlIGxhZGRhIHVzZSBpbm5lckhUTUwgaW5zdGVhZCBvZiBhcHBlbmQgbm9kZVxuICAgICAgICAgICAgaWYoIWVsZW1lbnRbMF0ucXVlcnlTZWxlY3RvcignLmxhZGRhLWxhYmVsJykpIHtcbiAgICAgICAgICAgICAgdmFyIGxhYmVsV3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgICAgbGFiZWxXcmFwcGVyLmNsYXNzTmFtZSA9ICdsYWRkYS1sYWJlbCc7XG4gICAgICAgICAgICAgIGFuZ3VsYXIuZWxlbWVudChsYWJlbFdyYXBwZXIpLmFwcGVuZChlbGVtZW50LmNvbnRlbnRzKCkpO1xuICAgICAgICAgICAgICBlbGVtZW50LmFwcGVuZChsYWJlbFdyYXBwZXIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjcmVhdGUgbGFkZGEgYnV0dG9uXG4gICAgICAgICAgICB2YXIgbGFkZGEgPSBMYWRkYS5jcmVhdGUoIGVsZW1lbnRbMF0gKTtcblxuICAgICAgICAgICAgLy8gYWRkIHdhdGNoIVxuICAgICAgICAgICAgc2NvcGUuJHdhdGNoKGF0dHJzLmxhZGRhLCBmdW5jdGlvbihsb2FkaW5nKSB7XG4gICAgICAgICAgICAgIGlmKCFsb2FkaW5nICYmICFhbmd1bGFyLmlzTnVtYmVyKGxvYWRpbmcpKSB7XG4gICAgICAgICAgICAgICAgbGFkZGEuc3RvcCgpO1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIGJ1dHRvbiBhbHNvIGhhdmUgdGhlIG5nLWRpc2FibGVkIGRpcmVjdGl2ZSBpdCBuZWVkcyB0byBiZVxuICAgICAgICAgICAgICAgIC8vIHJlLWV2YWx1YXRlZCBzaW5jZSB0aGUgZGlzYWJsZWQgYXR0cmlidXRlIGlzIHJlbW92ZWQgYnkgdGhlICdzdG9wJyBtZXRob2QuXG4gICAgICAgICAgICAgICAgaWYgKGF0dHJzLm5nRGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgIGVsZW1lbnQuYXR0cignZGlzYWJsZWQnLCBzY29wZS4kZXZhbChhdHRycy5uZ0Rpc2FibGVkKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZighbGFkZGEuaXNMb2FkaW5nKCkpIHtcbiAgICAgICAgICAgICAgICBsYWRkYS5zdGFydCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmKGFuZ3VsYXIuaXNOdW1iZXIobG9hZGluZykpIHtcbiAgICAgICAgICAgICAgICBsYWRkYS5zZXRQcm9ncmVzcyhsb2FkaW5nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIHVzZSByZW1vdmUgb24gc2NvcGUgZGVzdHJveSB0byBzdG9wIG1lbW9yeSBsZWFrcyBcbiAgICAgICAgICAgIHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmIChsYWRkYSkgeyAvLyBwcmV2ZW50IG51bGwgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgbGFkZGEucmVtb3ZlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1dKTtcbiAgICBcbiAgcmV0dXJuIG1vZHVsZU5hbWU7XG59KSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYW5ndWxhci1sYWRkYS9kaXN0L2FuZ3VsYXItbGFkZGEuanNcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	eval("/*! ListController.js © yamoo9.net, 2016 */\n'use strict';\n\nvar angular = __webpack_require__(1);\n\nangular.module('BipanListApp').controller('ListController', ['$scope', 'ListDataShareService', function ($scope, ListDataShareService) {\n\n  // bipan 모델 데이터\n  $scope.share_data = ListDataShareService;\n\n  // 컨트롤러 $scope 객체의 속성\n  // $scope.search = {};\n  $scope.search = '';\n  $scope.order = 'name';\n\n  // 컨트롤러 $scope 객체의 메소드\n  $scope.selectPerson = function (person) {\n    $scope.share_data.selected_person = person;\n  };\n  $scope.loadMore = function () {\n    // 사용자가 브라우저의 하단 끝에서 스크롤 이벤트 발생\n    // 다음 페이지의 콘텐츠를 불러와야 합니다.\n    $scope.share_data.loadMore();\n  };\n\n  // 사용자가 입력하는 값을 관찰(Watch)\n  $scope.$watch('search', function (newValue) {\n    // 사용자 입력한 새로운 값: newValue\n    // 사용자 입력한 이전 값: oldValue\n    $scope.share_data.doSearch(newValue);\n  });\n  $scope.$watch('order', function (newValue) {\n    $scope.share_data.doOrder(newValue);\n  });\n\n  // 엄격하게 일치하는 검색 기능\n  // $scope.sensitiveSearch = function(person) {\n  //   var search = $scope.search;\n  //   if ( search ) {\n  //     return person.title.indexOf(search) === 0 ||\n  //            person.director.indexOf(search) === 0 ||\n  //            person.year.indexOf(search) === 0 ||\n  //            person.category.indexOf(search) === 0;\n  //   }\n  //   return true;\n  // };\n}]);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvY29udHJvbGxlcnMvTGlzdENvbnRyb2xsZXIuZXM2P2FmMmYiXSwibmFtZXMiOlsiYW5ndWxhciIsInJlcXVpcmUiLCJtb2R1bGUiLCJjb250cm9sbGVyIiwiJHNjb3BlIiwiTGlzdERhdGFTaGFyZVNlcnZpY2UiLCJzaGFyZV9kYXRhIiwic2VhcmNoIiwib3JkZXIiLCJzZWxlY3RQZXJzb24iLCJwZXJzb24iLCJzZWxlY3RlZF9wZXJzb24iLCJsb2FkTW9yZSIsIiR3YXRjaCIsIm5ld1ZhbHVlIiwiZG9TZWFyY2giLCJkb09yZGVyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBLElBQUlBLFVBQVUsbUJBQUFDLENBQVEsQ0FBUixDQUFkOztBQUVBRCxRQUNHRSxNQURILENBQ1UsY0FEVixFQUVHQyxVQUZILENBRWMsZ0JBRmQsRUFHSSxDQUFDLFFBQUQsRUFBVyxzQkFBWCxFQUFtQyxVQUFDQyxNQUFELEVBQVNDLG9CQUFULEVBQWdDOztBQUVuRTtBQUNBRCxTQUFPRSxVQUFQLEdBQW9CRCxvQkFBcEI7O0FBRUE7QUFDQTtBQUNBRCxTQUFPRyxNQUFQLEdBQWdCLEVBQWhCO0FBQ0FILFNBQU9JLEtBQVAsR0FBZ0IsTUFBaEI7O0FBRUE7QUFDQUosU0FBT0ssWUFBUCxHQUFzQixVQUFDQyxNQUFELEVBQVc7QUFDL0JOLFdBQU9FLFVBQVAsQ0FBa0JLLGVBQWxCLEdBQW9DRCxNQUFwQztBQUNELEdBRkQ7QUFHQU4sU0FBT1EsUUFBUCxHQUFrQixZQUFJO0FBQ3BCO0FBQ0E7QUFDQVIsV0FBT0UsVUFBUCxDQUFrQk0sUUFBbEI7QUFDRCxHQUpEOztBQU1BO0FBQ0FSLFNBQU9TLE1BQVAsQ0FBYyxRQUFkLEVBQXdCLFVBQUNDLFFBQUQsRUFBYTtBQUNuQztBQUNBO0FBQ0FWLFdBQU9FLFVBQVAsQ0FBa0JTLFFBQWxCLENBQTJCRCxRQUEzQjtBQUNELEdBSkQ7QUFLQVYsU0FBT1MsTUFBUCxDQUFjLE9BQWQsRUFBdUIsVUFBQ0MsUUFBRCxFQUFhO0FBQ2xDVixXQUFPRSxVQUFQLENBQWtCVSxPQUFsQixDQUEwQkYsUUFBMUI7QUFDRCxHQUZEOztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFRCxDQTFDQyxDQUhKIiwiZmlsZSI6IjExLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohIExpc3RDb250cm9sbGVyLmpzIMKpIHlhbW9vOS5uZXQsIDIwMTYgKi9cbid1c2Ugc3RyaWN0JztcblxubGV0IGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XG5cbmFuZ3VsYXJcbiAgLm1vZHVsZSgnQmlwYW5MaXN0QXBwJylcbiAgLmNvbnRyb2xsZXIoJ0xpc3RDb250cm9sbGVyJyxcbiAgICBbJyRzY29wZScsICdMaXN0RGF0YVNoYXJlU2VydmljZScsICgkc2NvcGUsIExpc3REYXRhU2hhcmVTZXJ2aWNlKT0+e1xuXG4gICAgLy8gYmlwYW4g66qo6424IOuNsOydtO2EsFxuICAgICRzY29wZS5zaGFyZV9kYXRhID0gTGlzdERhdGFTaGFyZVNlcnZpY2U7XG5cbiAgICAvLyDsu6jtirjroaTrn6wgJHNjb3BlIOqwneyytOydmCDsho3shLFcbiAgICAvLyAkc2NvcGUuc2VhcmNoID0ge307XG4gICAgJHNjb3BlLnNlYXJjaCA9ICcnO1xuICAgICRzY29wZS5vcmRlciAgPSAnbmFtZSc7XG5cbiAgICAvLyDsu6jtirjroaTrn6wgJHNjb3BlIOqwneyytOydmCDrqZTshozrk5xcbiAgICAkc2NvcGUuc2VsZWN0UGVyc29uID0gKHBlcnNvbik9PiB7XG4gICAgICAkc2NvcGUuc2hhcmVfZGF0YS5zZWxlY3RlZF9wZXJzb24gPSBwZXJzb247XG4gICAgfTtcbiAgICAkc2NvcGUubG9hZE1vcmUgPSAoKT0+e1xuICAgICAgLy8g7IKs7Jqp7J6Q6rCAIOu4jOudvOyasOyggOydmCDtlZjri6gg64Gd7JeQ7IScIOyKpO2BrOuhpCDsnbTrsqTtirgg67Cc7IOdXG4gICAgICAvLyDri6TsnYwg7Y6Y7J207KeA7J2YIOy9mO2FkOy4oOulvCDrtojrn6zsmYDslbwg7ZWp64uI64ukLlxuICAgICAgJHNjb3BlLnNoYXJlX2RhdGEubG9hZE1vcmUoKTtcbiAgICB9O1xuXG4gICAgLy8g7IKs7Jqp7J6Q6rCAIOyeheugpe2VmOuKlCDqsJLsnYQg6rSA7LCwKFdhdGNoKVxuICAgICRzY29wZS4kd2F0Y2goJ3NlYXJjaCcsIChuZXdWYWx1ZSk9PiB7XG4gICAgICAvLyDsgqzsmqnsnpAg7J6F66Cl7ZWcIOyDiOuhnOyatCDqsJI6IG5ld1ZhbHVlXG4gICAgICAvLyDsgqzsmqnsnpAg7J6F66Cl7ZWcIOydtOyghCDqsJI6IG9sZFZhbHVlXG4gICAgICAkc2NvcGUuc2hhcmVfZGF0YS5kb1NlYXJjaChuZXdWYWx1ZSk7XG4gICAgfSk7XG4gICAgJHNjb3BlLiR3YXRjaCgnb3JkZXInLCAobmV3VmFsdWUpPT4ge1xuICAgICAgJHNjb3BlLnNoYXJlX2RhdGEuZG9PcmRlcihuZXdWYWx1ZSk7XG4gICAgfSk7XG5cbiAgICAvLyDsl4TqsqntlZjqsowg7J287LmY7ZWY64qUIOqygOyDiSDquLDriqVcbiAgICAvLyAkc2NvcGUuc2Vuc2l0aXZlU2VhcmNoID0gZnVuY3Rpb24ocGVyc29uKSB7XG4gICAgLy8gICB2YXIgc2VhcmNoID0gJHNjb3BlLnNlYXJjaDtcbiAgICAvLyAgIGlmICggc2VhcmNoICkge1xuICAgIC8vICAgICByZXR1cm4gcGVyc29uLnRpdGxlLmluZGV4T2Yoc2VhcmNoKSA9PT0gMCB8fFxuICAgIC8vICAgICAgICAgICAgcGVyc29uLmRpcmVjdG9yLmluZGV4T2Yoc2VhcmNoKSA9PT0gMCB8fFxuICAgIC8vICAgICAgICAgICAgcGVyc29uLnllYXIuaW5kZXhPZihzZWFyY2gpID09PSAwIHx8XG4gICAgLy8gICAgICAgICAgICBwZXJzb24uY2F0ZWdvcnkuaW5kZXhPZihzZWFyY2gpID09PSAwO1xuICAgIC8vICAgfVxuICAgIC8vICAgcmV0dXJuIHRydWU7XG4gICAgLy8gfTtcblxuICB9XSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvY29udHJvbGxlcnMvTGlzdENvbnRyb2xsZXIuZXM2Il0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	eval("/*! DetailController.js © yamoo9.net, 2016 */\n'use strict';\n\nvar angular = __webpack_require__(1);\n\nangular.module('BipanListApp').controller('DetailController', ['$scope', 'ListDataShareService', function ($scope, ListDataShareService) {\n  $scope.share_data = ListDataShareService;\n\n  $scope.save = function () {\n    $scope.share_data.updateContact($scope.share_data.selected_person);\n  };\n\n  $scope.remove = function () {\n    $scope.share_data.removeContact($scope.share_data.selected_person);\n  };\n\n  $scope.create = function () {\n    $scope.share_data.createContact($scope.share_data.selected_person);\n  };\n}]);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvY29udHJvbGxlcnMvRGV0YWlsQ29udHJvbGxlci5lczY/MThmNyJdLCJuYW1lcyI6WyJhbmd1bGFyIiwicmVxdWlyZSIsIm1vZHVsZSIsImNvbnRyb2xsZXIiLCIkc2NvcGUiLCJMaXN0RGF0YVNoYXJlU2VydmljZSIsInNoYXJlX2RhdGEiLCJzYXZlIiwidXBkYXRlQ29udGFjdCIsInNlbGVjdGVkX3BlcnNvbiIsInJlbW92ZSIsInJlbW92ZUNvbnRhY3QiLCJjcmVhdGUiLCJjcmVhdGVDb250YWN0Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBLElBQUlBLFVBQVUsbUJBQUFDLENBQVEsQ0FBUixDQUFkOztBQUVBRCxRQUNHRSxNQURILENBQ1UsY0FEVixFQUVHQyxVQUZILENBRWMsa0JBRmQsRUFHSSxDQUFDLFFBQUQsRUFBVyxzQkFBWCxFQUFtQyxVQUFDQyxNQUFELEVBQVNDLG9CQUFULEVBQWdDO0FBQ2pFRCxTQUFPRSxVQUFQLEdBQW9CRCxvQkFBcEI7O0FBRUFELFNBQU9HLElBQVAsR0FBYyxZQUFJO0FBQ2hCSCxXQUFPRSxVQUFQLENBQWtCRSxhQUFsQixDQUFnQ0osT0FBT0UsVUFBUCxDQUFrQkcsZUFBbEQ7QUFDRCxHQUZEOztBQUlBTCxTQUFPTSxNQUFQLEdBQWdCLFlBQUk7QUFDbEJOLFdBQU9FLFVBQVAsQ0FBa0JLLGFBQWxCLENBQWdDUCxPQUFPRSxVQUFQLENBQWtCRyxlQUFsRDtBQUNELEdBRkQ7O0FBSUFMLFNBQU9RLE1BQVAsR0FBZ0IsWUFBSztBQUNuQlIsV0FBT0UsVUFBUCxDQUFrQk8sYUFBbEIsQ0FBZ0NULE9BQU9FLFVBQVAsQ0FBa0JHLGVBQWxEO0FBQ0QsR0FGRDtBQUlILENBZkMsQ0FISiIsImZpbGUiOiIxMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qISBEZXRhaWxDb250cm9sbGVyLmpzIMKpIHlhbW9vOS5uZXQsIDIwMTYgKi9cbid1c2Ugc3RyaWN0JztcblxubGV0IGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XG5cbmFuZ3VsYXJcbiAgLm1vZHVsZSgnQmlwYW5MaXN0QXBwJylcbiAgLmNvbnRyb2xsZXIoJ0RldGFpbENvbnRyb2xsZXInLFxuICAgIFsnJHNjb3BlJywgJ0xpc3REYXRhU2hhcmVTZXJ2aWNlJywgKCRzY29wZSwgTGlzdERhdGFTaGFyZVNlcnZpY2UpPT57XG4gICAgICAkc2NvcGUuc2hhcmVfZGF0YSA9IExpc3REYXRhU2hhcmVTZXJ2aWNlO1xuXG4gICAgICAkc2NvcGUuc2F2ZSA9ICgpPT57XG4gICAgICAgICRzY29wZS5zaGFyZV9kYXRhLnVwZGF0ZUNvbnRhY3QoJHNjb3BlLnNoYXJlX2RhdGEuc2VsZWN0ZWRfcGVyc29uKTtcbiAgICAgIH07XG5cbiAgICAgICRzY29wZS5yZW1vdmUgPSAoKT0+e1xuICAgICAgICAkc2NvcGUuc2hhcmVfZGF0YS5yZW1vdmVDb250YWN0KCRzY29wZS5zaGFyZV9kYXRhLnNlbGVjdGVkX3BlcnNvbik7XG4gICAgICB9O1xuXG4gICAgICAkc2NvcGUuY3JlYXRlID0gKCk9PiB7XG4gICAgICAgICRzY29wZS5zaGFyZV9kYXRhLmNyZWF0ZUNvbnRhY3QoJHNjb3BlLnNoYXJlX2RhdGEuc2VsZWN0ZWRfcGVyc29uKTtcbiAgICAgIH07XG5cbiAgfV0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2NvbnRyb2xsZXJzL0RldGFpbENvbnRyb2xsZXIuZXM2Il0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	eval("/*! ListDataShareService.js © yamoo9.net, 2016 */\n'use strict';\n\nvar angular = __webpack_require__(1);\n\nangular.module('BipanListApp').factory('Contact', ['$resource', function ($resource) {\n  var url = 'https://codecraftpro.com/api/samples/v1/contact/:id/';\n  var params = { 'id': '@id' };\n  var actions = {\n    'update': {\n      'method': 'PUT'\n    },\n    'remove': {\n      'method': 'DELETE'\n    },\n    'create': {\n      'method': 'POST'\n    }\n  };\n  return $resource(url, params, actions);\n}]).service('ListDataShareService', ['Contact', function (Contact) {\n\n  // 서비스 객체 초기화 함수(비공개)\n  var initServiceSetting = function initServiceSetting() {\n    _service.people = [];\n    _service.page = 1;\n    _service.has_more = true;\n  };\n\n  var _service = {\n    // 초기 선택된 사람 초기화\n    'selected_person': null,\n    // 초기 피플 데이터 리스트\n    'people': [],\n    // 초기 페이지 인덱스\n    'page': 1,\n    'has_more': true,\n    'is_loading': false,\n    'is_saving': false,\n    'is_deleting': false,\n    'is_creating': false,\n    // doSearch Method\n    'doSearch': function doSearch(search) {\n      _service.search = search;\n      initServiceSetting();\n      _service.loadContacts();\n    },\n    // doOrder Method\n    'doOrder': function doOrder(order) {\n      _service.ordering = order;\n      initServiceSetting();\n      _service.loadContacts();\n    },\n    // loadContacts Method\n    'loadContacts': function loadContacts() {\n      if (_service.has_more && !_service.is_loading) {\n\n        _service.is_loading = true;\n\n        // 서버에 전송할 파라미터(매개변수)\n        var params = {\n          'page': _service.page,\n          'search': _service.search,\n          'ordering': _service.ordering\n        };\n        // 서버에 요청(GET)\n        Contact.get(params, function (data) {\n          angular.forEach(data.results, function (person) {\n            _service.people.push(new Contact(person));\n          });\n          // 더 이상 불러올 다음 데이터가 존재하지 않을 경우\n          // _service 객체의 has_more 속성을 false로 변경\n          if (!data.next) {\n            _service.has_more = false;\n          }\n          _service.is_loading = false;\n        });\n      }\n    },\n    'loadMore': function loadMore() {\n      if (_service.has_more && !_service.is_loading) {\n        // 다음 페이지를 불러오기 위한 페이지 값 증가\n        _service.page += 1;\n        // 콘텐츠 로드 처리 실행\n        _service.loadContacts(); // page = 2, 3, ...\n      }\n    },\n    'updateContact': function updateContact(person) {\n      _service.is_saving = true;\n      console.log(person);\n      person.$update().then(function () {\n        _service.is_saving = false;\n      });\n    },\n    'removeContact': function removeContact(person) {\n      _service.is_deleting = true;\n      person.$remove().then(function () {\n        var index = _service.people.indexOf(person);\n        // 사용자가 선택한 인덱스의 사람을 목록에서 제거\n        _service.people.splice(index, 1);\n        _service.selected_person = null;\n        _service.is_deleting = false;\n      });\n    },\n    'createContact': function createContact(person) {\n      _service.is_creating = true;\n      // Contact.save(person).$promise.then(()=> {\n      new Contact(person).$create().then(function () {\n        initServiceSetting();\n        _service.loadContacts();\n        _service.is_creating = false;\n      });\n    }\n  };\n\n  _service.loadContacts(); // 초기 실행 page = 1\n\n  return _service;\n}]);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvc2VydmljZXMvTGlzdERhdGFTaGFyZVNlcnZpY2UuZXM2PzBmZWEiXSwibmFtZXMiOlsiYW5ndWxhciIsInJlcXVpcmUiLCJtb2R1bGUiLCJmYWN0b3J5IiwiJHJlc291cmNlIiwidXJsIiwicGFyYW1zIiwiYWN0aW9ucyIsInNlcnZpY2UiLCJDb250YWN0IiwiaW5pdFNlcnZpY2VTZXR0aW5nIiwiX3NlcnZpY2UiLCJwZW9wbGUiLCJwYWdlIiwiaGFzX21vcmUiLCJzZWFyY2giLCJsb2FkQ29udGFjdHMiLCJvcmRlciIsIm9yZGVyaW5nIiwiaXNfbG9hZGluZyIsImdldCIsImRhdGEiLCJmb3JFYWNoIiwicmVzdWx0cyIsInBlcnNvbiIsInB1c2giLCJuZXh0IiwiaXNfc2F2aW5nIiwiY29uc29sZSIsImxvZyIsIiR1cGRhdGUiLCJ0aGVuIiwiaXNfZGVsZXRpbmciLCIkcmVtb3ZlIiwiaW5kZXgiLCJpbmRleE9mIiwic3BsaWNlIiwic2VsZWN0ZWRfcGVyc29uIiwiaXNfY3JlYXRpbmciLCIkY3JlYXRlIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBLElBQUlBLFVBQVUsbUJBQUFDLENBQVEsQ0FBUixDQUFkOztBQUVBRCxRQUNHRSxNQURILENBQ1UsY0FEVixFQUVHQyxPQUZILENBRVcsU0FGWCxFQUVzQixDQUFDLFdBQUQsRUFBYyxVQUFTQyxTQUFULEVBQW1CO0FBQ25ELE1BQUlDLE1BQU0sc0RBQVY7QUFDQSxNQUFJQyxTQUFTLEVBQUMsTUFBTSxLQUFQLEVBQWI7QUFDQSxNQUFJQyxVQUFVO0FBQ1osY0FBUztBQUNQLGdCQUFVO0FBREgsS0FERztBQUlaLGNBQVU7QUFDUixnQkFBVTtBQURGLEtBSkU7QUFPWixjQUFVO0FBQ1IsZ0JBQVU7QUFERjtBQVBFLEdBQWQ7QUFXQSxTQUFPSCxVQUFVQyxHQUFWLEVBQWVDLE1BQWYsRUFBdUJDLE9BQXZCLENBQVA7QUFDRCxDQWZtQixDQUZ0QixFQWtCR0MsT0FsQkgsQ0FrQlcsc0JBbEJYLEVBa0JtQyxDQUFDLFNBQUQsRUFBWSxVQUFDQyxPQUFELEVBQVc7O0FBRXREO0FBQ0EsTUFBSUMscUJBQXFCLFNBQXJCQSxrQkFBcUIsR0FBSztBQUM1QkMsYUFBU0MsTUFBVCxHQUFvQixFQUFwQjtBQUNBRCxhQUFTRSxJQUFULEdBQW9CLENBQXBCO0FBQ0FGLGFBQVNHLFFBQVQsR0FBb0IsSUFBcEI7QUFDRCxHQUpEOztBQU1BLE1BQUlILFdBQVc7QUFDYjtBQUNBLHVCQUFvQixJQUZQO0FBR2I7QUFDQSxjQUFlLEVBSkY7QUFLYjtBQUNBLFlBQWUsQ0FORjtBQU9iLGdCQUFlLElBUEY7QUFRYixrQkFBZSxLQVJGO0FBU2IsaUJBQWUsS0FURjtBQVViLG1CQUFlLEtBVkY7QUFXYixtQkFBZSxLQVhGO0FBWWI7QUFDQSxnQkFBWSxrQkFBQ0ksTUFBRCxFQUFXO0FBQ3JCSixlQUFTSSxNQUFULEdBQWtCQSxNQUFsQjtBQUNBTDtBQUNBQyxlQUFTSyxZQUFUO0FBQ0QsS0FqQlk7QUFrQmI7QUFDQSxlQUFXLGlCQUFDQyxLQUFELEVBQVU7QUFDbkJOLGVBQVNPLFFBQVQsR0FBb0JELEtBQXBCO0FBQ0FQO0FBQ0FDLGVBQVNLLFlBQVQ7QUFDRCxLQXZCWTtBQXdCYjtBQUNBLG9CQUFnQix3QkFBSztBQUNuQixVQUFLTCxTQUFTRyxRQUFULElBQXFCLENBQUNILFNBQVNRLFVBQXBDLEVBQWlEOztBQUUvQ1IsaUJBQVNRLFVBQVQsR0FBc0IsSUFBdEI7O0FBRUE7QUFDQSxZQUFJYixTQUFTO0FBQ1gsa0JBQWFLLFNBQVNFLElBRFg7QUFFWCxvQkFBYUYsU0FBU0ksTUFGWDtBQUdYLHNCQUFhSixTQUFTTztBQUhYLFNBQWI7QUFLQTtBQUNBVCxnQkFBUVcsR0FBUixDQUFZZCxNQUFaLEVBQW9CLFVBQUNlLElBQUQsRUFBUTtBQUMxQnJCLGtCQUFRc0IsT0FBUixDQUFnQkQsS0FBS0UsT0FBckIsRUFBOEIsVUFBQ0MsTUFBRCxFQUFVO0FBQ3RDYixxQkFBU0MsTUFBVCxDQUFnQmEsSUFBaEIsQ0FBc0IsSUFBSWhCLE9BQUosQ0FBWWUsTUFBWixDQUF0QjtBQUNELFdBRkQ7QUFHQTtBQUNBO0FBQ0EsY0FBSSxDQUFDSCxLQUFLSyxJQUFWLEVBQWdCO0FBQ2RmLHFCQUFTRyxRQUFULEdBQW9CLEtBQXBCO0FBQ0Q7QUFDREgsbUJBQVNRLFVBQVQsR0FBc0IsS0FBdEI7QUFDRCxTQVZEO0FBWUQ7QUFDRixLQWxEWTtBQW1EYixnQkFBWSxvQkFBSztBQUNmLFVBQUtSLFNBQVNHLFFBQVQsSUFBcUIsQ0FBQ0gsU0FBU1EsVUFBcEMsRUFBaUQ7QUFDL0M7QUFDQVIsaUJBQVNFLElBQVQsSUFBaUIsQ0FBakI7QUFDQTtBQUNBRixpQkFBU0ssWUFBVCxHQUorQyxDQUl0QjtBQUMxQjtBQUNGLEtBMURZO0FBMkRiLHFCQUFpQix1QkFBQ1EsTUFBRCxFQUFXO0FBQzFCYixlQUFTZ0IsU0FBVCxHQUFxQixJQUFyQjtBQUNBQyxjQUFRQyxHQUFSLENBQVlMLE1BQVo7QUFDQUEsYUFBT00sT0FBUCxHQUFpQkMsSUFBakIsQ0FBc0IsWUFBSztBQUN6QnBCLGlCQUFTZ0IsU0FBVCxHQUFxQixLQUFyQjtBQUNELE9BRkQ7QUFHRCxLQWpFWTtBQWtFYixxQkFBaUIsdUJBQUNILE1BQUQsRUFBVztBQUMxQmIsZUFBU3FCLFdBQVQsR0FBdUIsSUFBdkI7QUFDQVIsYUFBT1MsT0FBUCxHQUFpQkYsSUFBakIsQ0FBc0IsWUFBSztBQUN6QixZQUFJRyxRQUFRdkIsU0FBU0MsTUFBVCxDQUFnQnVCLE9BQWhCLENBQXdCWCxNQUF4QixDQUFaO0FBQ0E7QUFDQWIsaUJBQVNDLE1BQVQsQ0FBZ0J3QixNQUFoQixDQUF1QkYsS0FBdkIsRUFBOEIsQ0FBOUI7QUFDQXZCLGlCQUFTMEIsZUFBVCxHQUEyQixJQUEzQjtBQUNBMUIsaUJBQVNxQixXQUFULEdBQXVCLEtBQXZCO0FBQ0QsT0FORDtBQU9ELEtBM0VZO0FBNEViLHFCQUFpQix1QkFBQ1IsTUFBRCxFQUFXO0FBQzFCYixlQUFTMkIsV0FBVCxHQUF1QixJQUF2QjtBQUNBO0FBQ0MsVUFBSTdCLE9BQUosQ0FBWWUsTUFBWixDQUFELENBQXNCZSxPQUF0QixHQUFnQ1IsSUFBaEMsQ0FBcUMsWUFBSztBQUN4Q3JCO0FBQ0FDLGlCQUFTSyxZQUFUO0FBQ0FMLGlCQUFTMkIsV0FBVCxHQUF1QixLQUF2QjtBQUNELE9BSkQ7QUFLRDtBQXBGWSxHQUFmOztBQXVGQTNCLFdBQVNLLFlBQVQsR0FoR3NELENBZ0c3Qjs7QUFFekIsU0FBT0wsUUFBUDtBQUVELENBcEdnQyxDQWxCbkMiLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgTGlzdERhdGFTaGFyZVNlcnZpY2UuanMgwqkgeWFtb285Lm5ldCwgMjAxNiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5sZXQgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcblxuYW5ndWxhclxuICAubW9kdWxlKCdCaXBhbkxpc3RBcHAnKVxuICAuZmFjdG9yeSgnQ29udGFjdCcsIFsnJHJlc291cmNlJywgZnVuY3Rpb24oJHJlc291cmNlKXtcbiAgICBsZXQgdXJsID0gJ2h0dHBzOi8vY29kZWNyYWZ0cHJvLmNvbS9hcGkvc2FtcGxlcy92MS9jb250YWN0LzppZC8nO1xuICAgIGxldCBwYXJhbXMgPSB7J2lkJzogJ0BpZCd9O1xuICAgIGxldCBhY3Rpb25zID0ge1xuICAgICAgJ3VwZGF0ZSc6e1xuICAgICAgICAnbWV0aG9kJzogJ1BVVCdcbiAgICAgIH0sXG4gICAgICAncmVtb3ZlJzoge1xuICAgICAgICAnbWV0aG9kJzogJ0RFTEVURSdcbiAgICAgIH0sXG4gICAgICAnY3JlYXRlJzoge1xuICAgICAgICAnbWV0aG9kJzogJ1BPU1QnXG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gJHJlc291cmNlKHVybCwgcGFyYW1zLCBhY3Rpb25zKTtcbiAgfV0pXG4gIC5zZXJ2aWNlKCdMaXN0RGF0YVNoYXJlU2VydmljZScsIFsnQ29udGFjdCcsIChDb250YWN0KT0+e1xuXG4gICAgLy8g7ISc67mE7IqkIOqwneyytCDstIjquLDtmZQg7ZWo7IiYKOu5hOqzteqwnClcbiAgICBsZXQgaW5pdFNlcnZpY2VTZXR0aW5nID0gKCk9PiB7XG4gICAgICBfc2VydmljZS5wZW9wbGUgICA9IFtdO1xuICAgICAgX3NlcnZpY2UucGFnZSAgICAgPSAxO1xuICAgICAgX3NlcnZpY2UuaGFzX21vcmUgPSB0cnVlO1xuICAgIH07XG5cbiAgICBsZXQgX3NlcnZpY2UgPSB7XG4gICAgICAvLyDstIjquLAg7ISg7YOd65CcIOyCrOuejCDstIjquLDtmZRcbiAgICAgICdzZWxlY3RlZF9wZXJzb24nIDogbnVsbCxcbiAgICAgIC8vIOy0iOq4sCDtlLztlIwg642w7J207YSwIOumrOyKpO2KuFxuICAgICAgJ3Blb3BsZScgICAgIDogW10sXG4gICAgICAvLyDstIjquLAg7Y6Y7J207KeAIOyduOuNseyKpFxuICAgICAgJ3BhZ2UnICAgICAgIDogMSxcbiAgICAgICdoYXNfbW9yZScgICA6IHRydWUsXG4gICAgICAnaXNfbG9hZGluZycgOiBmYWxzZSxcbiAgICAgICdpc19zYXZpbmcnICA6IGZhbHNlLFxuICAgICAgJ2lzX2RlbGV0aW5nJzogZmFsc2UsXG4gICAgICAnaXNfY3JlYXRpbmcnOiBmYWxzZSxcbiAgICAgIC8vIGRvU2VhcmNoIE1ldGhvZFxuICAgICAgJ2RvU2VhcmNoJzogKHNlYXJjaCk9PiB7XG4gICAgICAgIF9zZXJ2aWNlLnNlYXJjaCA9IHNlYXJjaDtcbiAgICAgICAgaW5pdFNlcnZpY2VTZXR0aW5nKCk7XG4gICAgICAgIF9zZXJ2aWNlLmxvYWRDb250YWN0cygpO1xuICAgICAgfSxcbiAgICAgIC8vIGRvT3JkZXIgTWV0aG9kXG4gICAgICAnZG9PcmRlcic6IChvcmRlcik9PiB7XG4gICAgICAgIF9zZXJ2aWNlLm9yZGVyaW5nID0gb3JkZXI7XG4gICAgICAgIGluaXRTZXJ2aWNlU2V0dGluZygpO1xuICAgICAgICBfc2VydmljZS5sb2FkQ29udGFjdHMoKTtcbiAgICAgIH0sXG4gICAgICAvLyBsb2FkQ29udGFjdHMgTWV0aG9kXG4gICAgICAnbG9hZENvbnRhY3RzJzogKCk9PiB7XG4gICAgICAgIGlmICggX3NlcnZpY2UuaGFzX21vcmUgJiYgIV9zZXJ2aWNlLmlzX2xvYWRpbmcgKSB7XG5cbiAgICAgICAgICBfc2VydmljZS5pc19sb2FkaW5nID0gdHJ1ZTtcblxuICAgICAgICAgIC8vIOyEnOuyhOyXkCDsoITshqHtlaAg7YyM652866+47YSwKOunpOqwnOuzgOyImClcbiAgICAgICAgICBsZXQgcGFyYW1zID0ge1xuICAgICAgICAgICAgJ3BhZ2UnICAgICA6IF9zZXJ2aWNlLnBhZ2UsXG4gICAgICAgICAgICAnc2VhcmNoJyAgIDogX3NlcnZpY2Uuc2VhcmNoLFxuICAgICAgICAgICAgJ29yZGVyaW5nJyA6IF9zZXJ2aWNlLm9yZGVyaW5nLFxuICAgICAgICAgIH07XG4gICAgICAgICAgLy8g7ISc67KE7JeQIOyalOyyrShHRVQpXG4gICAgICAgICAgQ29udGFjdC5nZXQocGFyYW1zLCAoZGF0YSk9PntcbiAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChkYXRhLnJlc3VsdHMsIChwZXJzb24pPT57XG4gICAgICAgICAgICAgIF9zZXJ2aWNlLnBlb3BsZS5wdXNoKCBuZXcgQ29udGFjdChwZXJzb24pICk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIOuNlCDsnbTsg4Eg67aI65+s7JisIOuLpOydjCDrjbDsnbTthLDqsIAg7KG07J6s7ZWY7KeAIOyViuydhCDqsr3smrBcbiAgICAgICAgICAgIC8vIF9zZXJ2aWNlIOqwneyytOydmCBoYXNfbW9yZSDsho3shLHsnYQgZmFsc2XroZwg67OA6rK9XG4gICAgICAgICAgICBpZiAoIWRhdGEubmV4dCkge1xuICAgICAgICAgICAgICBfc2VydmljZS5oYXNfbW9yZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3NlcnZpY2UuaXNfbG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAnbG9hZE1vcmUnOiAoKT0+IHtcbiAgICAgICAgaWYgKCBfc2VydmljZS5oYXNfbW9yZSAmJiAhX3NlcnZpY2UuaXNfbG9hZGluZyApIHtcbiAgICAgICAgICAvLyDri6TsnYwg7Y6Y7J207KeA66W8IOu2iOufrOyYpOq4sCDsnITtlZwg7Y6Y7J207KeAIOqwkiDspp3qsIBcbiAgICAgICAgICBfc2VydmljZS5wYWdlICs9IDE7XG4gICAgICAgICAgLy8g7L2Y7YWQ7LigIOuhnOuTnCDsspjrpqwg7Iuk7ZaJXG4gICAgICAgICAgX3NlcnZpY2UubG9hZENvbnRhY3RzKCk7IC8vIHBhZ2UgPSAyLCAzLCAuLi5cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgICd1cGRhdGVDb250YWN0JzogKHBlcnNvbik9PiB7XG4gICAgICAgIF9zZXJ2aWNlLmlzX3NhdmluZyA9IHRydWU7XG4gICAgICAgIGNvbnNvbGUubG9nKHBlcnNvbik7XG4gICAgICAgIHBlcnNvbi4kdXBkYXRlKCkudGhlbigoKT0+IHtcbiAgICAgICAgICBfc2VydmljZS5pc19zYXZpbmcgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgJ3JlbW92ZUNvbnRhY3QnOiAocGVyc29uKT0+IHtcbiAgICAgICAgX3NlcnZpY2UuaXNfZGVsZXRpbmcgPSB0cnVlO1xuICAgICAgICBwZXJzb24uJHJlbW92ZSgpLnRoZW4oKCk9PiB7XG4gICAgICAgICAgbGV0IGluZGV4ID0gX3NlcnZpY2UucGVvcGxlLmluZGV4T2YocGVyc29uKTtcbiAgICAgICAgICAvLyDsgqzsmqnsnpDqsIAg7ISg7YOd7ZWcIOyduOuNseyKpOydmCDsgqzrnozsnYQg66qp66Gd7JeQ7IScIOygnOqxsFxuICAgICAgICAgIF9zZXJ2aWNlLnBlb3BsZS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgIF9zZXJ2aWNlLnNlbGVjdGVkX3BlcnNvbiA9IG51bGw7XG4gICAgICAgICAgX3NlcnZpY2UuaXNfZGVsZXRpbmcgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgJ2NyZWF0ZUNvbnRhY3QnOiAocGVyc29uKT0+IHtcbiAgICAgICAgX3NlcnZpY2UuaXNfY3JlYXRpbmcgPSB0cnVlO1xuICAgICAgICAvLyBDb250YWN0LnNhdmUocGVyc29uKS4kcHJvbWlzZS50aGVuKCgpPT4ge1xuICAgICAgICAobmV3IENvbnRhY3QocGVyc29uKSkuJGNyZWF0ZSgpLnRoZW4oKCk9PiB7XG4gICAgICAgICAgaW5pdFNlcnZpY2VTZXR0aW5nKCk7XG4gICAgICAgICAgX3NlcnZpY2UubG9hZENvbnRhY3RzKCk7XG4gICAgICAgICAgX3NlcnZpY2UuaXNfY3JlYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgIH07XG5cbiAgICBfc2VydmljZS5sb2FkQ29udGFjdHMoKTsgLy8g7LSI6riwIOyLpO2WiSBwYWdlID0gMVxuXG4gICAgcmV0dXJuIF9zZXJ2aWNlO1xuXG4gIH1dKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9zZXJ2aWNlcy9MaXN0RGF0YVNoYXJlU2VydmljZS5lczYiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	eval("/*! readingZeroFilter.js © yamoo9.net, 2016 */\n'use strict';\n\nvar angular = __webpack_require__(1);\n\nangular.module('BipanListApp').filter('readingZero', function () {\n  return function (input) {\n    return input < 10 ? '0' + input : input;\n  };\n});//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvZmlsdGVycy9yZWFkaW5nWmVyb0ZpbHRlci5lczY/OTg2MiJdLCJuYW1lcyI6WyJhbmd1bGFyIiwicmVxdWlyZSIsIm1vZHVsZSIsImZpbHRlciIsImlucHV0Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBLElBQUlBLFVBQVUsbUJBQUFDLENBQVEsQ0FBUixDQUFkOztBQUVBRCxRQUNHRSxNQURILENBQ1UsY0FEVixFQUVHQyxNQUZILENBRVUsYUFGVixFQUV5QixZQUFLO0FBQzFCLFNBQU8sVUFBQ0MsS0FBRCxFQUFVO0FBQ2YsV0FBT0EsUUFBUSxFQUFSLEdBQWMsTUFBTUEsS0FBcEIsR0FBNkJBLEtBQXBDO0FBQ0QsR0FGRDtBQUdELENBTkgiLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgcmVhZGluZ1plcm9GaWx0ZXIuanMgwqkgeWFtb285Lm5ldCwgMjAxNiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5sZXQgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcblxuYW5ndWxhclxuICAubW9kdWxlKCdCaXBhbkxpc3RBcHAnKVxuICAuZmlsdGVyKCdyZWFkaW5nWmVybycsICgpPT4ge1xuICAgIHJldHVybiAoaW5wdXQpPT4ge1xuICAgICAgcmV0dXJuIGlucHV0IDwgMTAgPyAoJzAnICsgaW5wdXQpIDogaW5wdXQ7XG4gICAgfTtcbiAgfSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvZmlsdGVycy9yZWFkaW5nWmVyb0ZpbHRlci5lczYiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	eval("/*! defaultImageFilter.js © yamoo9.net, 2016 */\n'use strict';\n\nvar angular = __webpack_require__(1);\n\nangular.module('BipanListApp').filter('defaultImage', function () {\n  return function (input) {\n    var param = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'http://mealib.nic.in/photogalleryphp/p3293.jpg';\n\n    return input || param;\n  };\n});//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvZmlsdGVycy9kZWZhdWx0SW1hZ2VGaWx0ZXIuZXM2P2FlOTIiXSwibmFtZXMiOlsiYW5ndWxhciIsInJlcXVpcmUiLCJtb2R1bGUiLCJmaWx0ZXIiLCJpbnB1dCIsInBhcmFtIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBLElBQUlBLFVBQVUsbUJBQUFDLENBQVEsQ0FBUixDQUFkOztBQUVBRCxRQUNHRSxNQURILENBQ1UsY0FEVixFQUVHQyxNQUZILENBRVUsY0FGVixFQUUwQixZQUFLO0FBQzNCLFNBQU8sVUFBQ0MsS0FBRCxFQUFrRTtBQUFBLFFBQTFEQyxLQUEwRCx1RUFBcEQsZ0RBQW9EOztBQUN2RSxXQUFPRCxTQUFTQyxLQUFoQjtBQUNELEdBRkQ7QUFHRCxDQU5IIiwiZmlsZSI6IjE1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohIGRlZmF1bHRJbWFnZUZpbHRlci5qcyDCqSB5YW1vbzkubmV0LCAyMDE2ICovXG4ndXNlIHN0cmljdCc7XG5cbmxldCBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xuXG5hbmd1bGFyXG4gIC5tb2R1bGUoJ0JpcGFuTGlzdEFwcCcpXG4gIC5maWx0ZXIoJ2RlZmF1bHRJbWFnZScsICgpPT4ge1xuICAgIHJldHVybiAoaW5wdXQsIHBhcmFtPSdodHRwOi8vbWVhbGliLm5pYy5pbi9waG90b2dhbGxlcnlwaHAvcDMyOTMuanBnJyk9PiB7XG4gICAgICByZXR1cm4gaW5wdXQgfHwgcGFyYW07XG4gICAgfTtcbiAgfSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvZmlsdGVycy9kZWZhdWx0SW1hZ2VGaWx0ZXIuZXM2Il0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }
/******/ ]);